<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/laughter.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/laughter.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/laughter.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sun-gliang.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="TODOcommand line  initiate    participate    redeem    refund  doc  ReadMe  ReadMe_CN">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm">
<meta property="og:url" content="https://sun-gliang.github.io/post/d92ce365.html">
<meta property="og:site_name" content="ooopSok">
<meta property="og:description" content="TODOcommand line  initiate    participate    redeem    refund  doc  ReadMe  ReadMe_CN">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sun-gliang.github.io/merge.png">
<meta property="og:image" content="https://sun-gliang.github.io/bfs.png">
<meta property="article:published_time" content="2023-03-24T16:25:41.000Z">
<meta property="article:modified_time" content="2023-03-25T06:37:39.900Z">
<meta property="article:author" content="ooopSok">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sun-gliang.github.io/merge.png">

<link rel="canonical" href="https://sun-gliang.github.io/post/d92ce365.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Algorithm | ooopSok</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7afc37b9fc5e1f6dee6dce06c06eacde";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="ooopSok" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ooopSok</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be Happy Every Day</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sun-gliang.github.io/post/d92ce365.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/image.jpg">
      <meta itemprop="name" content="ooopSok">
      <meta itemprop="description" content="iiiismmmmme">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ooopSok">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Algorithm
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-25 00:25:41 / Modified: 14:37:39" itemprop="dateCreated datePublished" datetime="2023-03-25T00:25:41+08:00">2023-03-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/Learning/" itemprop="url" rel="index"><span itemprop="name">Learning</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="command-line"><a href="#command-line" class="headerlink" title="command line"></a>command line</h3><ul>
<li><input disabled="" type="checkbox"> initiate  </li>
<li><input disabled="" type="checkbox"> participate  </li>
<li><input disabled="" type="checkbox"> redeem  </li>
<li><input disabled="" type="checkbox"> refund</li>
</ul>
<h3 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h3><ul>
<li><input checked="" disabled="" type="checkbox"> ReadMe</li>
<li><input disabled="" type="checkbox"> ReadMe_CN</li>
</ul>
<span id="more"></span>


<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h2><h2 id="平均为nlogn-，最坏为n-2"><a href="#平均为nlogn-，最坏为n-2" class="headerlink" title="平均为nlogn ，最坏为n^2"></a>平均为nlogn ，最坏为n^2</h2><p>  <strong>分治思想</strong></p>
<p>1.选择分界点x     x  &#x3D;  q[l]  &#x2F;  q[(l+r)&#x2F;2]  &#x2F;  q[r]  &#x2F;  随机</p>
<p>2.调整区间       <strong>重难点</strong></p>
<p>3.递归处理左右两段</p>
<!-- more -->

<p>通过设置两个指针i，j分别指向初始序列的两端      i 和 j 相遇后只可能会出现  i &#x3D;&#x3D; j   和   i &#x3D; j + 1  两种情况</p>
<p>**注意   j -  - **</p>
<p><strong>注意  i &#x3D; l - 1 ,   r &#x3D; r + 1</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x 取q的中间值万能</span></span><br><span class="line">    <span class="type">int</span> x = q[(l + r) / <span class="number">2</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指针i 和 j 一旦相遇就结束</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);  <span class="comment">// 注意是j--</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    注意若取j j+1，则x=q[*]，*不能取右边界 </span></span><br><span class="line"><span class="comment">    若取i-1 i，则x=q[*]，不能取左边界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    quick_sort(q, l, i - 1);</span></span><br><span class="line"><span class="comment">    quick_sort(q, i, r);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.baidu.com/">百度</a></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.baidu.com/">百度</a></p>
<h2 id="2-快速选择"><a href="#2-快速选择" class="headerlink" title="2.快速选择"></a>2.快速选择</h2><h2 id="（o-n-）"><a href="#（o-n-）" class="headerlink" title="（o(n)）"></a>（o(n)）</h2><p>与快速排序差不多，只是快速选择需要再输入一个 k 值，最后不用对左右两个区间递归，而只需要对左或右区间进行递归</p>
<p><img src="/merge.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++里面的函数参数与全局变量重名，优先使用局部变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h2><h2 id="（nlogn）"><a href="#（nlogn）" class="headerlink" title="（nlogn）"></a>（nlogn）</h2><p> <strong>分治思想</strong></p>
<p>1.确定分界点  x &#x3D; (l + r) &#x2F; 2</p>
<p>2.递归排序左右两端</p>
<p>3.对左右两端排序好的序列归并（合二为一） <strong>重难点</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], tmp[N];</span><br><span class="line"><span class="comment">// 因为q[N]已经是全局变量了， 所以函数参数有没有q无所谓 了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid); <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    	<span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">    	<span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-二分"><a href="#4-二分" class="headerlink" title="4.二分"></a>4.二分</h2><p><strong><u>用来查找</u></strong></p>
<h4 id="4-1整数二分"><a href="#4-1整数二分" class="headerlink" title="4.1整数二分"></a>4.1整数二分</h4><p>二分的本质是找到一个性质，可以确定一个边界问题</p>
<p>有单调性一定可以二分， 而可以二分的不一定有单调性</p>
<p>求最值考虑一下二分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while里面的模板直接使用，具体check函数根据题目来分析</p>
<p>二分一定是有解的      无解情况取决于题目</p>
<p>每次二分之后保证答案在所选区间内部</p>
<h4 id="4-2浮点数二分"><a href="#4-2浮点数二分" class="headerlink" title="4.2浮点数二分"></a>4.2浮点数二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dou_bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l - r &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dou_bsearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l - r &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般1e8这个地方看题目要求， 总是比题目要求保留小数位数多2</p>
<p>eg：保留4位小数，1e6</p>
<h2 id="5-高精度"><a href="#5-高精度" class="headerlink" title="5.高精度"></a>5.高精度</h2><h5 id="高精度相加"><a href="#高精度相加" class="headerlink" title="高精度相加"></a>高精度相加</h5><p>A + B      len(A), len(B) &lt;&#x3D; 1e6</p>
<h5 id="高精度相减"><a href="#高精度相减" class="headerlink" title="高精度相减"></a>高精度相减</h5><p>A - B       len(A), len(B) &lt;&#x3D; 1e6</p>
<h5 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h5><p>A * a      len(A) &lt;&#x3D; 1e6      a &lt;&#x3D; 1e9</p>
<h5 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h5><p>A * a      len(A) &lt;&#x3D; 1e6      a &lt;&#x3D; 1e9</p>
<h5 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h5><p>大整数在c++里面用数组来表示（存储）</p>
<p>把大整数的每一位存到数组里面，按照低位在前进行存储（即第零位存个位）</p>
<p>原因：两个数进行运算会出现进位的可能，这时将高位数放到数组最后一位会使得数据处理起来更方便（否则便会从数组第一位依次后移，效率降低）（栈？？？）</p>
<p>用库函数<vector>来表示一个大整数，一个size函数， 表示一个数组的长度，就不用再额外开一个内存来存储数组的长度了</p>
<p>模拟人工加法</p>
<h2 id="6-前缀和"><a href="#6-前缀和" class="headerlink" title="6.前缀和"></a>6.前缀和</h2><h2 id="从1开始"><a href="#从1开始" class="headerlink" title="从1开始"></a>从1开始</h2><h4 id="6-1一维前缀和"><a href="#6-1一维前缀和" class="headerlink" title="6.1一维前缀和"></a>6.1一维前缀和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_i = a_1 + a_2 + ... + a_i</span><br></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> <em><strong>下标设置从1开始</strong></em></li>
</ul>
<p>意味着<em><strong>S_0 &#x3D; 0</strong></em>，对应于后面，与后面S_r - S_l-1 保持一致</p>
<p>如何求S_i            一维前缀和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    S_i = <span class="built_in">S_</span>(i - <span class="number">1</span>) + a_i</span><br></pre></td></tr></table></figure>



<p>作用：<strong>能够快速地求出原数组中一段数的和</strong></p>
<p>区间 [l, r] 这一段的和：<em><strong>S_r - S_l-1</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀和</span></span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line"><span class="comment">// 原数组中一段数的和</span></span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>





<h4 id="6-2二维前缀和"><a href="#6-2二维前缀和" class="headerlink" title="6.2二维前缀和"></a>6.2二维前缀和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S[i, j] 表示 第 i 行 j 列格子左上部分所有元素的和</span></span><br><span class="line"></span><br><span class="line">S[i, j] = S[i - <span class="number">1</span>][j] + S[i][j - <span class="number">1</span>] - S[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 ( x1 ,  y1 ) 为左上角， ( x2 ,  y2 ) 为右下角的子矩阵的和为：</span></span><br><span class="line"></span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>





<h2 id="7-差分-从1开始"><a href="#7-差分-从1开始" class="headerlink" title="7.差分 从1开始"></a>7.差分 从1开始</h2><p>前缀和的逆运算</p>
<h4 id="7-1一维差分"><a href="#7-1一维差分" class="headerlink" title="7.1一维差分"></a>7.1一维差分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定a[1], a[2], ... , a[n]，构造差分数组b[N] ，使得 a[i] = b[1] + b[2] + ... + b[i]，即 a 数组是 b 数组的一个前缀和</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心操作：将a[L, R]区间所有数字加上C， 等价于 b[L] += C, b[R + 1] -= C</span></span><br></pre></td></tr></table></figure>

<p>构造b数组        即假设a数组全为0， 则b数组也全为0，但实际上，a数组不全为0。这里构造一个插入函数，</p>
<p>bits&#x2F;stdc++.h  ——-     万能头文件</p>
<h4 id="7-2二维差分"><a href="#7-2二维差分" class="headerlink" title="7.2二维差分"></a>7.2二维差分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span></span><br><span class="line"><span class="comment">// S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c</span></span><br></pre></td></tr></table></figure>





<h2 id="8-双指针算法"><a href="#8-双指针算法" class="headerlink" title="8.双指针算法"></a>8.双指针算法</h2><p><strong>单调–考虑二分或双指针</strong></p>
<p><u><strong>优化</strong></u></p>
<p>核心思想：将双重for循环的O(n^2)的暴力法优化到O(n)</p>
<p>先写出暴力解法，再看枚举时i j 的单调关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>()) j++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check()寻找i j 之间的关系（比如单调性）</span></span><br><span class="line">    <span class="comment">// 以上是基本模板格式，下面具体问题具体分析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h2><h5 id="①-n的二进制表示中第k位是几（个位是第0位，依次）"><a href="#①-n的二进制表示中第k位是几（个位是第0位，依次）" class="headerlink" title="① n的二进制表示中第k位是几（个位是第0位，依次）"></a>① n的二进制表示中第k位是几（个位是第0位，依次）</h5><p>​				先把n的第k位移到第0位   n &gt;&gt; k</p>
<p>​				再看个位数是几   (n &gt;&gt; k) &amp; 1</p>
<p>​				综述	———–&gt;	(n &gt;&gt; k) &amp; 1</p>
<h5 id="②lobit-x-return-x-amp-x-（与运算，将x变为二进制进行与运算）"><a href="#②lobit-x-return-x-amp-x-（与运算，将x变为二进制进行与运算）" class="headerlink" title="②lobit(x)   return x&amp;-x;（与运算，将x变为二进制进行与运算）"></a>②lobit(x)   return x&amp;-x;（与运算，将x变为二进制进行与运算）</h5><p>​				返回x的二进制的最右边的一个1 </p>
<h2 id="10-离散化"><a href="#10-离散化" class="headerlink" title="10.离散化"></a>10.离散化</h2><p>类似于在一个很大的给定区间范围上，但是可以用到的区域占比很小（类比稀疏矩阵）</p>
<p>通过将所需要用到的数据点坐标映射为1， 2， 3， … 这样的序列（二分实现），来达到离散化算法的功效。</p>
<p>必须加入下面这两行代码（先排序，再去重）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>())</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure>





<h2 id="11-区间合并"><a href="#11-区间合并" class="headerlink" title="11.区间合并"></a>11.区间合并</h2><p>贪心思想</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul>
<li><u><del>都是用来做优化的</del></u></li>
</ul>
<h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1.链表"></a>1.链表</h2><h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h3><p>在算法中用的最多的是邻接表（n个链表）</p>
<p>邻接表主要存储数和图</p>
<p>用数组模拟链表（用于笔试）</p>
<p>结构体指针构造链表会超时（用于面试）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i]表示结点i的值</span></span><br><span class="line"><span class="comment">// ne[i]表示结点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx表示当前所用的是第几个结点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>, idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插入到头结点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插入到下标是k的结点的后面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点的后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2.双链表"></a>2.双链表</h3><p>用来优化某些问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[Nl, l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0表示左端点，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下标是k的点的右边，插入x</span></span><br><span class="line"><span class="comment">// 在下标是k的点的左边插入x只要执行操作add(l[k], x);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第k个点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">stk[++tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">tt--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>) <span class="keyword">not</span> empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出栈顶元素</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="单调栈应用"><a href="#单调栈应用" class="headerlink" title="单调栈应用"></a>单调栈应用</h3><p>给定一个序列，求序列中每一个数左边离它最近的且比它小的数字，若不存在则返回-1</p>
<p>与双指针思路类似，先暴力求解，再探究规律</p>
<h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="type">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">q[++tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">hh++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出队头元素</span></span><br><span class="line">q[hh]</span><br></pre></td></tr></table></figure>



<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>典型应用：滑动窗口</p>
<p>与双指针思路类似，先暴力求解，再探究规律，删去没有用的元素</p>
<h2 id="4-KMP"><a href="#4-KMP" class="headerlink" title="4.KMP"></a>4.KMP</h2><p>可以用来求循环节，其他体型好像都不如字符串前缀哈希了</p>
<h2 id="5-Trie"><a href="#5-Trie" class="headerlink" title="5.Trie"></a>5.Trie</h2><p>应用：AC自动机</p>
<p><u><strong>一般出现的字符串类型：全是小写字母、全是大写字母、只有数字、只有0&#x2F;1</strong></u></p>
<p><u>用来快速（高效）<strong>存储和查找字符串集合</strong>的数据结构</u></p>
<h2 id="6-并查集"><a href="#6-并查集" class="headerlink" title="6.并查集"></a>6.并查集</h2><p><strong><del>面试笔试    思维</del></strong></p>
<p>应用之一：Kruskal</p>
<ul>
<li>用途：</li>
</ul>
<ol>
<li><p>将两个集合合并</p>
</li>
<li><p>询问两个元素是否在一个集合中</p>
</li>
</ol>
<p>近乎O(1)的时间复杂度，很快</p>
<p>基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，即p[x]表示x的父节点。</p>
<ol>
<li>判断树根： if（p[x] &#x3D;&#x3D; x）</li>
<li>求x的集合编号：while（p[x] !&#x3D; x） x &#x3D; p[x];    ———&gt;        优化：路径压缩：一旦找到根节点，就将所有节点都指向根节点</li>
<li>合并两个集合：设p[x]是x的集合编号，p[y]是y的集合编号。则合并操作：p[x] &#x3D; y或p[y] &#x3D; x</li>
</ol>
<p><u>核心操作</u></p>
<p>寻找x结点的祖宗节点 + 路径优化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="7-堆"><a href="#7-堆" class="headerlink" title="7.堆"></a>7.堆</h2><p><u>维护一个数据集合</u></p>
<ul>
<li>基本操作</li>
<li>插入与删除都只与树的高度有关，故是logn的</li>
</ul>
<ol>
<li>向集合中插入一个数</li>
<li>求集合当中的最小值</li>
<li>在集合中删除最小值</li>
<li>删除集合中任意一个元素</li>
<li>修改集合中任意一个元素</li>
</ol>
<p>这里规定高度&#x2F;深度&#x2F;层数都是从1开始的</p>
<p>直接建堆是O(nlogn)的       -PS：因为插入是logn的</p>
<p>可以使用O(n)来建堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>

<p>完全二叉树的第n&#x2F;2个结点是最后一个非叶子节点</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设堆是heap[], 堆的大小是size</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">heap[++size] = x; <span class="built_in">up</span>(size);</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">heap[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//3.  拿最后一个结点把第一个结点覆盖掉，再down      PS：因为是用一维数组存储的，所有删掉第一个元素是O(n)的，而删除最后一个元素是O(1)的</span></span><br><span class="line">heap[<span class="number">1</span>] = heap[size]; size--; <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line">heap[k] = heap[size]; size--; <span class="built_in">down</span>(k) / <span class="built_in">up</span>(k);</span><br><span class="line"><span class="comment">//5.</span></span><br><span class="line">heap[k] = x; <span class="built_in">down</span>(k) / <span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure>



<p>堆是一个完全二叉树           堆中某个节点的值总是不大于或不小于其父节点的值</p>
<p>小根堆：每个节点的值都 ≤ 它的左右儿子的值</p>
<ul>
<li>堆的存储结构（堆状数据结构&#x2F;完全二叉树）：一维数组         一维数组就可以存下一棵树</li>
</ul>
<p><em><strong>1号点是根节点   下标是x的结点的左儿子下标是2x，右儿子下标是2x+1</strong></em></p>
<p>下面的一维数组即表示下面的小根堆</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	1--&gt;2;</span><br><span class="line">	1--&gt;3;</span><br><span class="line">	2--&gt;4;</span><br><span class="line">	2--&gt;5;</span><br><span class="line">	3--&gt;6;</span><br><span class="line">	3--&gt;7;</span><br><span class="line">	4--&gt;8;</span><br><span class="line">	4--&gt;9;</span><br><span class="line">	5--&gt;10;</span><br></pre></td></tr></table></figure>



<p><em><strong>基本操作</strong></em></p>
<ol>
<li>down(x)（将结点往下调整）</li>
<li>up(x)（将结点往上调整）</li>
</ol>
<h2 id="8-Hash"><a href="#8-Hash" class="headerlink" title="8.Hash"></a>8.Hash</h2><p>离散化是一种特殊的hash          离散化 &#x3D; 排序 + hash</p>
<p>离散化保证了映射后原数据的顺序保持不变，hash并没有保证；且离散化是nlogn（maybe），hash是O(1)的</p>
<p>把一堆数据映射到0<del>N的小空间（N&#x3D;10^5</del>10^6）</p>
<p>将所有的数放在小空间中，解决冲突问题（<strong>冲突问题是指利用hash函数映射后，可能会出现多个数映射到同一个数的情况</strong>）</p>
<p>利用hash函数进行映射，一般取对10^5取模这个操作作为hash函数 h(x) &#x3D; x mod 10^5，其中10^5取质数，且取距离2的整次幂尽可能远（冲突的概率是最低的）</p>
<p>根据处理冲突问题的不同的解决方案，分为开放寻址法和拉链法</p>
<h3 id="哈希表的存储结构"><a href="#哈希表的存储结构" class="headerlink" title="哈希表的存储结构"></a>哈希表的存储结构</h3><p>hashmap是拉链法，threadlocal是开放寻址法？？？？</p>
<p>hash在算法题中一般只有插入和查找这两个操作，没有删除</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开了一个一维数组，数组大小为题目要求大小的2~3倍</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心函数</span></span><br><span class="line"><span class="comment">// find函数  如果x在哈希表中已经存在，就返回x所在的位置；如果x在哈希表中不存在，则返回x应该存储的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 茅厕寻址法：当当前坑位有人且当前坑位中的人不是你要找的人才进入循环</span></span><br><span class="line">    <span class="keyword">while</span> (h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span> (k == N) k = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>开一个一维数组（数组大小为“利用hash函数进行映射，一般取对10^5取模这个操作作为hash函数 h(x) &#x3D; x mod 10^5，其中10^5取质数，且取距离2的整次幂尽可能远（冲突的概率是最低的）“这样大小的）来存储所有的hash值，该一维数组每个结点都表示一个表头</p>
<p>若经过hash映射后，出现了两个相同的映射值，则依次将这两个数插到对应一维数组头节点下面，形成邻接链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x, ne[idx] = h[k], h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="字符串前缀哈希法"><a href="#字符串前缀哈希法" class="headerlink" title="字符串前缀哈希法"></a>字符串前缀哈希法</h3><h3 id="假定不存在冲突"><a href="#假定不存在冲突" class="headerlink" title="假定不存在冲突"></a>假定不存在冲突</h3><p>快速判断两个字符串是否相等</p>
<hr>
<ol>
<li>先预处理出所有前缀的哈希值</li>
<li>求出所有的前缀字符串的哈希值</li>
<li>利用这些前缀字符串哈希值可以表示出字符串中任意子串</li>
</ol>
<hr>
<hr>
<p><strong><u>将任意字符串转化为哈希值的方法：</u></strong></p>
<p>把字符串看作p进制数</p>
<p>把p进制数转化为10进制数</p>
<p>对该字符串哈希值mod Q</p>
<p>则对于任意一个字符串，都可以将其表示为0~Q-1的一个数字（通常不将字符串映射成0）</p>
<p><em><strong>取p &#x3D; 131或13331，Q &#x3D; 2^64</strong></em></p>
<hr>
<h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><p>DFS和BFS都可以对整个空间搜索，搜索结构都是树的形式。</p>
<p>但是DFS尽可能往深了搜，一旦达到叶节点就会回溯</p>
<p>BFS会将当前这一层搜索完了才会继续搜索下一层</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><strong>思路比较奇怪就用DFS或对空间要求比较高</strong></p>
<p>依靠stack</p>
<p>空间复杂度为 O(h)   即与高度成正比</p>
<p>不具有最短路性质</p>
<p>时间复杂度为线性的</p>
<p>DFS俗称“暴搜”</p>
<p>要考虑好<strong>顺序</strong></p>
<p>从搜索树的角度考虑</p>
<p>回溯</p>
<p>剪枝</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><strong>问最短距离，最小步数，最少操作几次</strong> （前提是每个边的权重都是一样的）</p>
<p><img src="/bfs.png"></p>
<p>依靠queue</p>
<p>空间复杂度为O(2^h)</p>
<p>具有最短路性质</p>
<h2 id="树和图的存储"><a href="#树和图的存储" class="headerlink" title="树和图的存储"></a>树和图的存储</h2><p>树是无环连通图，是一种特殊的图</p>
<p>可以把无向图变成两个方向的有向图，只用考虑有向图的存储即可实现无向图的存储</p>
<p>存储方式分为<strong>邻接矩阵</strong>和<strong>邻接表</strong>两种</p>
<p><strong>邻接矩阵</strong> 用一个二维数组实现 g[a][b] 存储边a到边b的信息（即权重）不能存储重边 适合存储稠密图  O(n^2)</p>
<p><strong>邻接表</strong> 就是n个单链表（其中n表示节点个数），每个单链表用来存储这个结点可以到达的结点 </p>
<p>往邻接表中插入数据时，选择在链表头进行插入</p>
<p>常用<strong>邻接表</strong>来存储</p>
<h2 id="树和图的遍历"><a href="#树和图的遍历" class="headerlink" title="树和图的遍历"></a>树和图的遍历</h2><p>分为深度优先遍历和广度优先遍历，每个点只需遍历一次   时间复杂度是O(n + m)   n为节点数，m为边数</p>
<p>只用考虑有向图的遍历即可（无向图是一种特殊的有向图，树是一种特殊的图）</p>
<p>遍历只需要找到一条路即可，不必再像dfs中再恢复现场</p>
<p>这两种搜索方式的思想就是dfs和bfs</p>
<p>####深度优先遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dfs会求得每一个子树的大小</p>
<p>####广度优先遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h2><p>针对有向图，无向图没有拓扑序列</p>
<p>是广度优先算法的应用</p>
<p>有向无环图一定存在一个拓扑序列    有向无环图也被称为拓扑图</p>
<p>有向环图一定不存在拓扑序列</p>
<p>所有入度为0的点都可以排在当前序列中最前面的位置</p>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>n表示结点数，m表示边数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	最短路--&gt;单源最短路;</span><br><span class="line">	最短路--&gt;多源汇最短路;</span><br><span class="line">	单源最短路--&gt;所有边权都是正数;</span><br><span class="line">	单源最短路--&gt;存在负权边;</span><br><span class="line">	所有边权都是正数--&gt;朴素Dijkstra算法;</span><br><span class="line">	所有边权都是正数--&gt;堆优化版的Dijkstra算法;</span><br><span class="line">	朴素Dijkstra算法--&gt;n2适合稠密图;</span><br><span class="line">	堆优化版的Dijkstra算法--&gt;mlongn适合稀疏图;</span><br><span class="line">	存在负权边--&gt;Bellman-Ford;</span><br><span class="line">	Bellman-Ford--&gt;nm;</span><br><span class="line">	Bellman-Ford--&gt;不超过k条边的最短路问题;</span><br><span class="line">	存在负权边--&gt;SPFA;</span><br><span class="line">	SPFA--&gt;一般是m,最坏是nm;</span><br><span class="line">	多源汇最短路--&gt;Floyd算法;</span><br><span class="line">	Floyd算法--&gt;n3;</span><br></pre></td></tr></table></figure>



<p>最短路问题的核心是如何把题干抽象为一个图，如何定义点和边来确定最短路问题</p>
<h3 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.初始化dist数组</span></span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>, dist[i] = <span class="number">0x3f3f3f3f</span>; <span class="comment">// i = 2,3,...,n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// （1）</span></span><br><span class="line">    先找出不在s中的最短距离的点t</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// （2）</span></span><br><span class="line">    将此最短距离的点t加入最短路数组s中</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// （3）</span></span><br><span class="line">    用此次的最短距离的点t来更新其他点的距离</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="堆优化版Dijkstra算法"><a href="#堆优化版Dijkstra算法" class="headerlink" title="堆优化版Dijkstra算法"></a>堆优化版Dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化dist数组</span></span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>, dist[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">利用priority_queue来存储，可以将朴素Dijkstra的（<span class="number">1</span>）优化到<span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line">priority_queue 更新操作是logn的，而低（<span class="number">3</span>）步一共需要更新所有的边共m次，故时间复杂度为mlogn</span><br><span class="line">但是priority_queue 中不支持修改任意一个元素，只能接受冗余的存在，即每次修改都往堆里面插入一个新的数</span><br><span class="line">所以本来堆里面是有n个数（手写堆可以保证），但是此时用的STL，priority_queue里面会有m个数</span><br><span class="line">所以实际上的时间复杂度为mlogm</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// （1）</span></span><br><span class="line">    先找出不在s中的最短距离的点t <span class="comment">// O(1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// （2）</span></span><br><span class="line">    将此最短距离的点t加入最短路数组s中 <span class="comment">// O(1)</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// （3）</span></span><br><span class="line">    用此次的最短距离的点t来更新其他点的距离 <span class="comment">// logn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>如果图中存在负权回路，则最短路可能会不存在（为-∞）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    备份<span class="function">dist</span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="params">(循环所有边 a b w  由a-&gt;b，权重为w)</span></span></span><br><span class="line"><span class="function">        更新每一条边 dist[b] </span>= <span class="built_in">min</span>(dist[b], dist[a] + w); <span class="comment">// 松弛操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	</p>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>只要图中没有负环，就可以用SPFA</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列中存储的是从起点到该节点距离变小的结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    取出队列的首元素t，弹出首元素</span><br><span class="line">    </span><br><span class="line">    更新t的所有出边，并把对应的出边的结点加到队列里面（因为t的所有出边由于t是变小的，所以它的所有出边也变小了，也要加入到队列中）（如果队列里面有了就不用了）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵存储所有的边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br></pre></td></tr></table></figure>





<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树一般涉及到的图都是无向图</p>
<p>稠密图，一般就用朴素版Prim算法</p>
<p>稀疏图，一般用Kruskal算法</p>
<p>堆优化版Prim算法不常用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	最小生成树--&gt;Prim算法;</span><br><span class="line">	最小生成树--&gt;Kruskal算法;</span><br><span class="line">	Prim算法--&gt;朴素版Prim算法;</span><br><span class="line">	Prim算法--&gt;堆优化版Prim算法;</span><br><span class="line">	朴素版Prim算法--&gt;适用于稠密图n2;</span><br><span class="line">	堆优化版Prim算法--&gt;适用于稀疏图mlogn;</span><br><span class="line">	Kruskal算法--&gt;mlogm;</span><br></pre></td></tr></table></figure>

<h3 id="朴素版Prim算法"><a href="#朴素版Prim算法" class="headerlink" title="朴素版Prim算法"></a>朴素版Prim算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化dist[N] &lt;- <span class="number">0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 循环n次</span></span><br><span class="line">&#123;</span><br><span class="line">    找到集合外距离最近的点t</span><br><span class="line">    </span><br><span class="line">    用t来更新其他点到集合的距离</span><br><span class="line">        </span><br><span class="line">    st[t] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将所有边按权重从小到大进行排序  <span class="comment">//O(mlongm)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 并查集思想   并查集是O(1) 总共就是O(m)</span></span><br><span class="line">枚举每条边a-b，权重为c</span><br><span class="line">    若a-b不连通，则将a-b这条边加入到集合中</span><br></pre></td></tr></table></figure>













<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	二分图--&gt;染色法...就是一个dfs,判断图是否为二分图--&gt;m+n;</span><br><span class="line">	二分图--&gt;匈牙利算法--&gt;最坏是mn,实际运行时间一般远小于mn;</span><br></pre></td></tr></table></figure>

<h3 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h3><p>一个图是二分图当且仅当图中不含奇数环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (i未被染色)</span><br><span class="line">        <span class="built_in">dfs</span>(i, color)</span><br></pre></td></tr></table></figure>





<h3 id="匈牙利算法-NTR算法bushi"><a href="#匈牙利算法-NTR算法bushi" class="headerlink" title="匈牙利算法[NTR算法bushi]"></a>匈牙利算法[NTR算法bushi]</h3><p>存储用邻接表</p>
<p>最坏时间复杂度是</p>
<h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p>在大于1的整数中，如果只包含1和其本身这两个约数，则该数就称为质数&#x2F;素数</p>
<h4 id="质数的判定—-试除法"><a href="#质数的判定—-试除法" class="headerlink" title="质数的判定—-试除法"></a>质数的判定—-试除法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从定义来</span></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; x; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="comment">// O(sqrt(n))</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原理见下方的数学块中内容</span></span><br></pre></td></tr></table></figure>

<p>$$<br>如果d|n，则\frac{n}{d}|n。因此若要枚举n的所有大于1的约数，只需要有d \lt \frac{n}{d}，即枚举到\frac{n}{d}即可\<br>$$</p>
<h4 id="分解质因数—-试除法"><a href="#分解质因数—-试除法" class="headerlink" title="分解质因数—-试除法"></a>分解质因数—-试除法</h4><p>$$<br>分解质因数：一个数x可以分解为，x &#x3D; {p_1}^{\alpha_1}{p_2}^{\alpha_2}…{p_k}^{\alpha_k}，其中p_1,p_2,…,p_k均为质数<br>$$</p>
<p>$$<br>一个数x中至多只包含一个大于\sqrt{n}的质因数<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最坏是O(sqrt(x))，最好的O(logn)---比如x=2^k;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h4><p>将所有小于等于x的质数筛出来</p>
<h5 id="朴素筛法"><a href="#朴素筛法" class="headerlink" title="朴素筛法"></a>朴素筛法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N]; <span class="comment">// 用来存储筛出来的质数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 如果当前这个数被筛去了，则赋值为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素筛法 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++] = i;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>朴素筛法时间复杂度分析</strong><br>$$<br>朴素筛法时间复杂度分析：当i&#x3D;2时，第二层循环循环\frac{n}{2}；当i&#x3D;3时，第二层循环循环\frac{n}{3}…当i&#x3D;n时，第三层循环循环1次。\故第二层循环总的循环次数为\frac{n}{2} + … + \frac{n}{n}&#x3D;n(\frac{1}{2} + … + \frac{1}{n})，取极限有\lim_{t-&gt;+\infty}n(\frac{1}{2} + … + \frac{1}{n})≈nlnn≈nlogn<br>$$</p>
<p>$$<br>\lim_{t-&gt;+\infty}(1 + \frac{1}{2} + … + \frac{1}{n}) &#x3D; lnn + C，其中C为欧拉常数，lnn为log_en<br>$$</p>
<h5 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">实际上，上面的第二层循环将<span class="number">2</span>~x中所有数的倍数都枚举了一遍，但实际上，只需要将<span class="number">2</span>~x中的所有质数的倍数枚举删去它们即可，故可做优化</span><br><span class="line"><span class="comment">// 埃氏筛法 O(nloglogn)    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        	<span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) st[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>埃氏筛法时间复杂度分析</strong><br>$$<br>埃氏筛法时间复杂度分析：由于只用筛去质数的所有倍数，故有\lim_{t-&gt;+\infty}n({\frac{1}{2} + … + \frac{1}{n}}_{质数})≈nlnn&#x2F;lnn≈nlogn&#x2F;lnn≈n\<br>实际上真实的理论上的时间复杂度为O(nloglogn)<br>$$</p>
<p>$$<br>质数定理：1-n当中一共有\frac{n}{lnn}个质数<br>$$</p>
<h5 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性筛法</span></span><br><span class="line"><span class="comment">// 把每一个合数只会被它的最小质因子筛掉</span></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">			st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j]一定是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从小到大枚举的所有质数</span></span><br><span class="line">        <span class="comment">// 1. i % primes[j] == 0    primes[j]一定是i的最小质因子,primes[j]一定是primes[j]*i的最小质因子</span></span><br><span class="line">        <span class="comment">// 2. i % primes[j] != 0	primes[j]一定小于i的所有质因子,primes[j]一定是primes[j]*i的最小质因子</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 对于一个合数x，假设primes[j]是x的最小质因子，则当i枚举到x / primes[j]时，该合数x一定会被筛掉，而且仅用最小质因子来筛，又每个数只有一个最小质因子，所以每个合数只会被筛掉一次，所以是线性的</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><h4 id="试除法求一个数的所有约数"><a href="#试除法求一个数的所有约数" class="headerlink" title="试除法求一个数的所有约数"></a>试除法求一个数的所有约数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vertor&lt;<span class="type">int</span>&gt; <span class="title">get_divitors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h4><p>$$<br>算数基本定理\<br>任何一个数x可以进行质因数分解，分解为x &#x3D; {p_1}^{\alpha_1}{p_2}^{\alpha_2}…{p_k}^{\alpha_k}，其中p_1,p_2,…,p_k均为质数<br>$$</p>
<p><strong>约数个数为</strong><br>$$<br>(\alpha_1+1)(\alpha_2+1)…(\alpha_k+1)<br>$$</p>
<p>$$<br>由于一个数x可以进行质因数分解，分解为x &#x3D; {p_1}^{\alpha_1}{p_2}^{\alpha_2}…{p_k}^{\alpha_k}\<br>假设x的其中一个约数为d，则d也可以进行质因数分解，分解为d &#x3D; {p_1}^{\beta_1}{p_2}^{\beta_2}…{p_k}^{\beta_k}\<br>由于每个数的质因数分解形式都是一样的，且对于不同的指数的组合，对应不同的数，所以约数个数就是\beta_1,…,\beta_k的选法的个数\<br>又0 \leq \beta_i \leq \alpha_i，因此\beta_i共有\alpha_i + 1种取法\<br>所以由乘法原理有约数个数为(\alpha_1+1)(\alpha_2+1)…(\alpha_k+1)<br>$$</p>
<p>int范围内，拥有最多约数的数的约数个数仅为1536</p>
<h4 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h4><p>$$<br>(p_1^0+p_1^1+…+p_1^{\alpha_1})…(p_k^0+p_k^1+…+p_k^{\alpha_k})<br>$$</p>
<h3 id="欧几里得算法-x2F-辗转相除法"><a href="#欧几里得算法-x2F-辗转相除法" class="headerlink" title="欧几里得算法&#x2F;辗转相除法"></a>欧几里得算法&#x2F;辗转相除法</h3><p>$$<br>(a, b) &#x3D; (b, a % b)\<br>a % b &lt;&#x3D;&#x3D;&#x3D;&gt; a-\lfloor \frac{a}{b} \rfloor *b\<br>Proof:\<br>必要性：如果d&#x3D;(a, b),则d|a, d|b,即d为a，b的最大公约数；又有d|(ax+by),所以d|(a-\lfloor \frac{a}{b} \rfloor *b)&#x3D;d|(a%b),所以d&#x3D;(b, a % b)\<br>充分性：如果d&#x3D;(b, a % b),有d|b,d|(a%b)&#x3D;d|(a-\lfloor \frac{a}{b} \rfloor *b),所以d|(a-\lfloor \frac{a}{b} \rfloor *b + \lfloor \frac{a}{b} \rfloor *b)&#x3D;d|a,所以d&#x3D;(a,b)<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(g, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>$$<br>欧拉函数，记作\varphi(n)，表示1-n中与n互质的数的个数（互质就是指两个数的gcd&#x3D;1）<br>$$</p>
<p>$$<br>求欧拉函数的公式：\<br>设数N的质因数分解为N&#x3D;{p_1}^{\alpha_1}{p_2}^{\alpha_2}…{p_k}^{\alpha_k}，则\varphi(N)&#x3D;N(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})<br>$$</p>
<p>$$<br>欧拉函数公式证明（用到了容斥原理）\<br>要想求得1-N中和N互质的数的个数就要：①从1-N中减去p_1,p_2,…,p_k的所有倍数;②加上所有p_i<em>p_j的倍数;③减去所有p_i</em>p_j<em>p_k的倍数;④加上所有…\<br>就有个数为N-\frac{N}{p_1}-\frac{N}{p_2}-…-\frac{N}{p_k}+\frac{N}{p_1</em>p_2}+\frac{N}{p_1<em>p_3}-…+\frac{N}{p_{k-1}<em>p_k}-\frac{N}{p_1</em>p_2</em>p_3}-\frac{N}{p_1<em>p_2</em>p_4}-…-\frac{N}{p_{k-2}p_{k-1}*p_k}+…&#x3D;欧拉函数<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度主要取决于分解质因数</span></span><br><span class="line"><span class="comment">// O(logx)-O(sqrt(x))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   	<span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">求1-N中每一个数的欧拉函数，用上述做法，就要将每一个数进行质因数分解，则时间复杂度为O(Nsqrt(N))</span><br><span class="line"></span><br><span class="line">利用线性筛法来去欧拉函数，会使得时间复杂度降低到O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果i % primes[j] == 0，则primes[j]是i的最小质因数，即i的质因数分解和i * primes[j]的质因数分解得到的质数是相同的（有相同的质因数），因此phi[i * primes[j]]与phi[i]只差primes[j]倍</span></span><br><span class="line">                phi[i * primes[j]] = phi[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果i % primes[j] != 0，则primes[j]是i * primes[j]的最小质因数，就有phi[i * primes[j]] = phi[i] * phi[j]，而j是质因数，所以phi[j] = primes[j] - 1</span></span><br><span class="line">            phi[i * primes[j]] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>欧拉定理</strong><br>$$<br>若a与n互质，则a^{\varphi(n)}\equiv1(mod \ \ n)，其中\varphi(n)为欧拉函数<br>$$</p>
<p>$$<br>Proof:\<br>假设1-n中与n互质的数分别为a_1,a_2,…,a_{\varphi(n)}(因为欧拉函数为\varphi(n)),则又由于a与n互质，可知有aa_1,aa_2,…,aa_{\varphi(n)}也与n互质，\且互不相同（反证法）,而且aa_1,aa_2,…,aa_{\varphi(n)}在模n的情况下是与a_1,a_2,…,a_{\varphi(n)}为同一组数。因此有\a^{\varphi(n)}a_1a_2…a_{\varphi(n)}\equiv a_1a_2…a_{\varphi(n)}(mod \ n)—-&gt;a^{\varphi(n)}\equiv 1(mod \ n)<br>$$</p>
<p><strong>费马小定理</strong><br>$$<br>在欧拉定理中，当n为质数时，有a^{n-1}\equiv 1(mod \ n)\<br>因为\varphi(n)&#x3D;n-1<br>$$</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>$$<br>a^k\ mod\ \ p\<br>可以在O(logk)的时间复杂度下求得上面的结果，其中0\le a,k,p\le10^9<br>$$</p>
<p>快速幂的核心思路：反复平方法</p>
<p>预处理出来<br>$$<br>二进制思想\预处理出来\<br>a^{2^0}mod\ p\<br>a^{2^1}mod\ p\<br>…\<br>a^{2^{log_2k}}mod\ p\<br>则a^k可以有上面预处理出来的基来表示\<br>而且上面的基有关系为(a^{2^0})^2&#x3D;a^{2^1},(a^{2^1})^2&#x3D;a^{2^2}…<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (<span class="type">long</span> <span class="type">long</span>)res * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (<span class="type">long</span> <span class="type">long</span>)a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>利用快速幂求逆元</strong></p>
<p>$$<br>乘法逆元的定义：若整数b，m互质，并且对于任意的整数a，如果满足b|a，则存在一个整数x，使得\frac{a}{b}≡a×x(mod \ m)，则称x为b的模m乘法逆元，记为 b^{−1}(mod\ m)。\<br>b存在乘法逆元的充要条件是b与模数m互质。\<br>当模数m为质数时，b^{m−2}即为b的乘法逆元。（参见费马小定理）<br>$$</p>
<p>$$<br>当x为b的乘法逆元时，有x&#x3D;b^{-1}(mod \ m)。带入乘法逆元定义式，有\frac{a}{b}\equiv a×b^{-1}(mod\ m)，化简得bb^{-1}\equiv 1(mod\ m)\<br>由于m为质数，由费马小定理可知，b^{m-1}\equiv1(mod\ m)，联立有b^{-1}(mod\ m)&#x3D;b^{m-2}<br>$$</p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p><strong>裴蜀定理</strong><br>$$<br>对于任意的正整数a，b，一定存在非零整数x，y，使得ax+by&#x3D;gcd(a, b)<br>$$<br>利用扩展欧几里得算法可以求得一组x,y使得x,y满足ax+by&#x3D;gcd(a,b)</p>
<p><strong>线性同余方程</strong></p>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>$$<br>有m_1,m_2,…m_k两两互质，则对于如下的线性同余方程组\<br>\begin{cases}<br>x &#x3D; a_1(mod \ m_1) \<br>x &#x3D; a_2(mod \ m_2) \<br>…\<br>x &#x3D; a_k(mod \ m_k)<br>\end{cases}\<br>有解为x&#x3D;a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_kM_kM_k^{-1}\<br>其中M&#x3D;m_1m_2…m_k,M_i&#x3D;\frac{M}{m_{i}},M_i^{-1}表示M_i模m_i的逆<br>$$</p>
<h2 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h2><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h2 id="简单博弈论"><a href="#简单博弈论" class="headerlink" title="简单博弈论"></a>简单博弈论</h2><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><p>时间复杂度分析：状态数量*计算每个状态需要的计算量</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>N个物品和容量为V的背包，每个物品的体积v_i，价值w_i</p>
<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><p>每件物品最多只能用一次</p>
<p>状态—未知数</p>
<p>状态表示指的是整个问题需要用几维的状态来表示，背包问题一般为两维</p>
<p>状态计算指的是如何一步一步把每一个状态算出来</p>
<p>Dp问题的优化是对状态方程&#x2F;程序做一个等价变形</p>
<p>每一个状态表示的都是一个集合，集合里面是一堆选法，是所有选法的一个集合</p>
<p>状态计算就是考虑如何把当前的集合划分为若干个更小的子集，使得每一个子集都可以用更小的集合表示出来</p>
<p>集合划分的原则—不重不漏（求num），不漏（求max，min）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	Dp--&gt;状态表示f_ij--&gt;集合--&gt;所有选法的集合;</span><br><span class="line">	集合--&gt;条件--&gt;1.只从前i个物品中选;</span><br><span class="line">	条件--&gt;2.选出来物品的总体积小于等于j;</span><br><span class="line">	状态表示f_ij--&gt;属性--&gt;Max;</span><br><span class="line">	Dp--&gt;状态计算--&gt;集合的划分--&gt;按照第i个物品有没有选上来划分;</span><br></pre></td></tr></table></figure>











<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>每件物品可以用无限次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	Dp--&gt;状态表示f_ij--&gt;集合--&gt;所有从前i个物品中选且总体积不超过j的所有选法的集合;</span><br><span class="line">	状态表示f_ij--&gt;属性--&gt;Max;</span><br><span class="line">	Dp--&gt;状态计算--&gt;集合的划分--&gt;按照第i个物品选0,1,2...k个来划分;</span><br></pre></td></tr></table></figure>

<p>三维时的状态转移方程为 f[i, j] &#x3D; f[i - 1, j - k * v[i]] + k * w[i]</p>
<p>枚举k将状态转移方程展开</p>
<p>f[i, j] &#x3D; max(f[i - 1, j], f[i - 1, j - v] + w, f[i - 1, j - 2v] + 2w + …)</p>
<p>f[i, j - v] &#x3D;           max(f[i - 1, j - v], f[i - 1, j - 2v] + w, …)</p>
<p>因此状态转移方程优化为f[i, j] &#x3D; max(f[i - 1, j], f[i, j - v] + w)</p>
<h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><p>每件物品最多只能用s_i次</p>
<p>优化：二进制优化</p>
<p>每件物品最多可以用s_i次<br>通过二进制优化，可以将s_i拆解为logs_i个（1,2,4,8…），且拆解出来的每一项仅可用一次<br>因此，所有的物品总共会最多拆解出Nlogs_i个<br>而每件拆解出来的物品又只能用一次<br>因此变为了一个0-1背包问题<br>时间复杂度由NVs降为NVlogs</p>
<h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><p>物品有N组，每一组物品有若干种物品，每一组里最多只能选一种物品</p>
<h2 id="线性Dp"><a href="#线性Dp" class="headerlink" title="线性Dp"></a>线性Dp</h2><p>递推的顺序有一个明显的线性顺序</p>
<h4 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	Dp--&gt;状态表示f_ij--&gt;集合--&gt;从起点到点i,j的所有路径的集合;</span><br><span class="line">	状态表示f_ij--&gt;属性--&gt;Max;</span><br><span class="line">	Dp--&gt;状态计算--&gt;集合的划分--&gt;按照走到i,j这个点的路径是从左上角走来的还是右上角走来的进行划分;</span><br></pre></td></tr></table></figure>

<p>左上角走来的状态转移方程f[i - 1, j - 1] + a[i, j]</p>
<p>右上角走来的状态转移方程f[i - 1, j] + a[i, j]</p>
<h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p>动态规划时间复杂度分析：<br>状态数量*计算每一个状态需要的的时间</p>
<p>这个算法的时间复杂度为O(n^2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	Dp--&gt;状态表示f_i--&gt;集合--&gt;所有以第i个数结尾的上升子序列;</span><br><span class="line">	状态表示f_i--&gt;属性--&gt;Max;</span><br><span class="line">	Dp--&gt;状态计算--&gt;集合的划分--&gt;按第i个数前一位是原序列的第几位来分类;</span><br></pre></td></tr></table></figure>

<p>动态规划求方案就是把状态转移记录下来</p>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   graph TD;</span><br><span class="line">Dp--&gt;状态表示f_i--&gt;集合--&gt;所有在第一个序列的前i个字母中出现且在第二个序列的前j个字母中出现的子序列;</span><br><span class="line">状态表示f_i--&gt;属性--&gt;Max;</span><br><span class="line">Dp--&gt;状态计算--&gt;集合的划分--&gt;按子序列中是否包含第一个序列的第i个字母第二个序列第j个字母划分;</span><br></pre></td></tr></table></figure>


<h3 id="区间Dp"><a href="#区间Dp" class="headerlink" title="区间Dp"></a>区间Dp</h3><h4 id="石子划分"><a href="#石子划分" class="headerlink" title="石子划分"></a>石子划分</h4><p>以最后一次分界的位置来分类</p>
<p>区间Dp要保证算每个f_ij所依赖的状态都已经算好了<br>顺序：枚举区间长度，从小到大枚举</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   graph TD;</span><br><span class="line">Dp--&gt;状态表示f_ij--&gt;集合--&gt;所有将第i堆石子到第j堆石子合并成一堆石子的合并方式;</span><br><span class="line">状态表示f_ij--&gt;属性--&gt;Min;</span><br><span class="line">Dp--&gt;状态计算--&gt;集合的划分--&gt;以最后一次合并的分界线的位置来分类;</span><br></pre></td></tr></table></figure>
























<h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><p>数据规模在100万以上，采用scanf和printf，否则cin和cout与他俩效率差不多</p>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><ul>
<li><p><code>vector</code>（变长数组），倍增的思想，支持比较运算（按字典序）<br>定义：：<br>    <code>vector &lt;int&gt; a</code>; 定义：一个vector数组a<br>    <code>vector &lt;int&gt; a(10)</code>; 定义：一个长度为10的vector数组a<br>    <code>vector &lt;int&gt; a(10,3)</code>; 定义：一个长度为10的vector数组a，并且所有元素都为3<br><strong>常用函数</strong>：：<br>    size(); 返回元素个数  O(1)<br>    empty(); 返回是否是空  O(1)<br>    clear(); 清空<br>    front(); 返回vector的第一个数<br>    back(); 返回vector的最后一个数<br>    push_back(); 向vector的最后插入一个数<br>    pop_back(); 把vector的最后一个数删掉<br>    begin(); vector的第0个数<br>    end(); vector的最后一个的数的后面一个数<br><strong>倍增的思想</strong>：<br>​			操作系统为某一进程分配空间时所花费的时间与空间大小无关，而与申请的次数有关。</p>
<p>​			************************************</p>
<p>​    <strong>遍历方法</strong><br>​        假设有个vector <int> a;</p>
<p>​		a.begin() &#x3D; a[0],   a.end() &#x3D; a[s.size()]</p>
<p>​        第一种</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) </span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>​        第二种</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector &lt;<span class="type">int</span>&gt;::iterator i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++)</span><br><span class="line">    cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;  </span><br><span class="line"><span class="comment">//vector &lt;int&gt;::iterator可以写为auto</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++)</span><br><span class="line">    cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;  </span><br></pre></td></tr></table></figure>

<p>​        第三种       </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : a) </span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​		<strong>支持比较运算</strong></p>
<p>​					按字典序比较，从第一个值开始比较，如果当前值小于则小于，如果等于则比较下一位</p>
<ul>
<li><p><code>pair</code>，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）<br>定义：：<br>​        pair &lt;类型,类型&gt; 变量名; 存储一个二元组    两个类型可以不同<br>​    初始化方式：<br>​        假设有个pair &lt;int,string&gt; p;<br>​        第一种        </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">make_pair</span>(<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​        第二种         </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &#123;<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​		也可以用pair存两个以上的不同类型的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, string&gt;&gt; p;</span><br></pre></td></tr></table></figure>

<p>常用函数：：<br>    first(); 第一个元素<br>    second(); 第二个元素</p>
</li>
<li><p><code>string</code>（字符串）<br>常用函数：：<br>    substr(); 返回某一个子串<br>    c_str(); 返回string对应的字符数组的头指针<br>    size(); 返回字母个数<br>    length(); 返回字母个数<br>    empty(); 返回字符串是否为空<br>    clear(); 把字符串清空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string  a = <span class="string">&quot;sgl&quot;</span>;</span><br><span class="line"></span><br><span class="line">a += <span class="string">&#x27;def&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>( , ) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// printf无法直接输出string，依靠string头指针来进行输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>queue</code>（队列）队尾插入队头弹出<br>定义：：<br>    queue &lt;类型&gt; 变量名;<br>常用函数：：<br>    size(); 这个队列的长度<br>    empty(); 返回这个队列是否为空<br>    push(); 往队尾插入一个元素<br>    front(); 返回队头元素<br>    back(); 返回队尾元素<br>    pop(); 把队头弹出<br>    注意：队列没有clear函数！！！<br>清空queue：     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = queue &lt;int&gt; ();</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>priority_queue</code>（优先队列，是一个堆）<br>注意：默认是大根堆！！！<br>定义：：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大根堆：priority_queue &lt;类型&gt; 变量名;</span><br><span class="line">小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名</span><br></pre></td></tr></table></figure>

<p>​    常用函数：<br>​        size(); 这个堆的长度<br>​        empty(); 返回这个堆是否为空<br>​        push();往堆里插入一个元素<br>​        top(); 返回堆顶元素<br>​        pop(); 弹出堆顶元素<br>​        注意：堆没有clear函数！！！</p>
</li>
</ul>
<p><code>stack</code>（栈）<br>    常用函数：<br>        size(); 这个栈的长度<br>        empty(); 返回这个栈是否为空<br>        push(); 向栈顶插入一个元素<br>        top(); 返回栈顶元素<br>        pop(); 弹出栈顶元素</p>
<p><code>deque</code>（双端队列）队头队尾都可以插入删除，支持随机访问<br>    常用函数：<br>        size(); 这个双端队列的长度<br>        empty(); 返回这个双端队列是否为空<br>        clear(); 清空这个双端队列<br>        front(); 返回第一个元素<br>        back(); 返回最后一个元素<br>        push_back(); 向最后插入一个元素<br>        pop_back(); 弹出最后一个元素<br>        push_front(); 向队首插入一个元素<br>        pop_front(); 弹出第一个元素<br>        begin(); 双端队列的第0个数<br>        end(); 双端队列的最后一个的数的后面一个数</p>
<p>​		[] 类似数组</p>
<p><code>set</code>，<code>map</code>，<code>multiset</code>，<code>multimap</code> 基于平衡二叉树（红黑树：一种平衡二叉树），动态维护<strong>有序序列</strong><br>    <code>set/multiset</code><br>        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！<br>        常用函数：<br>            size(); 返回元素个数<br>            empty(); 返回set是否是空的<br>            clear(); 清空<br>            begin(); 第0个数，支持++或–，返回前驱和后继<br>            end(); 最后一个的数的后面一个数，支持++或–，返回前驱和后继<br>            insert(); 插入一个数<br>            find(); 查找一个数<br>            count(); 返回某一个数的个数<br>            erase();<br>                （1）输入是一个数x，删除所有x    O(k + log n)      k是x的个数<br>                （2）输入一个迭代器，删除这个迭代器<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器<br>    <code>map/multimap</code>  类似python字典<br>        常用函数：<br>            insert(); 插入一个数，插入的数是一个pair<br>            erase();<br>                （1）输入是pair<br>                （2）输入一个迭代器，删除这个迭代器<br>            find(); 查找一个数<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器</p>
<p>​			[] 数组类似，但是是O(logn) 增删改查都是O(logn)</p>
<p><code>unordered_set</code>，<code>unordered_map</code>，<code>unordered_muliset</code>, <code>unordered_multimap</code> 基于哈希表实现<br>    和上面类似，增删改查的时间复杂度是O(1)<br>    不支持lower_bound()和upper_bound()，迭代器++–；；；；；；凡是和排序有关的操作都不支持</p>
<p><code>bitset</code> 压位</p>
<p>​	可以将一字节的大小存储在1bit中，即可以把内存大小减少为原来的1&#x2F;8</p>
<p>​    定义：<br>​        bitset &lt;个数&gt; 变量名;<br>​    支持：<br>​        <del>，&amp;，|，^<br>​        &gt;&gt;，&lt;&lt;<br>​        &#x3D;&#x3D;，!&#x3D;<br>​        []<br>​    常用函数：<br>​        count(); 返回有多少个1<br>​        any(); 判断是否至少有一个1<br>​        none(); 判断是否全为0<br>​        set(); 把所有位置赋值为1<br>​        set(k,v); 将第k位变成v<br>​        reset(); 把所有位变成0<br>​        flip(); 把所有位取反，等价于</del><br>​        flip(k); 把第k位取反</p>
<h1 id="蓝桥杯"><a href="#蓝桥杯" class="headerlink" title="蓝桥杯"></a>蓝桥杯</h1><p><strong>题目描述</strong> —- &gt;&gt;  <strong>抽象出具体模型</strong></p>
<p>检查程序  ①正确性 ②时间复杂度 ③</p>
<p>C++ 评测机 1s内可以运行一亿次（10^8）</p>
<p>也就是说一个算法时间复杂度要不超过10^7为最佳，可以在1s内算出来</p>
<p>超时：时间复杂度超过10^8</p>
<p>根据数据量的范围来确定用什么算法</p>
<p>2^20 —— 10 ^ 6</p>
<p>2^15 ——- 32768</p>
<p>2^16 ——– 65536</p>
<p>递归</p>
<p>①手绘搜索树</p>
<h3 id="②将搜索树转化为代码（若是dfs，考虑dfs中传入的参数）"><a href="#②将搜索树转化为代码（若是dfs，考虑dfs中传入的参数）" class="headerlink" title="②将搜索树转化为代码（若是dfs，考虑dfs中传入的参数）"></a>②将搜索树转化为代码（若是dfs，考虑dfs中传入的参数）</h3><h1 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h1><h2 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h2><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h4 id="其他进制转十进制"><a href="#其他进制转十进制" class="headerlink" title="其他进制转十进制"></a>其他进制转十进制</h4><p>秦九韶算法<br>$$<br>((a_{k-1}k+a_{k-2})k+a_{k-3})k+a_{k-4}<br>$$</p>
<h4 id="十进制转其他进制"><a href="#十进制转其他进制" class="headerlink" title="十进制转其他进制"></a>十进制转其他进制</h4><p>短除法</p>
<h4 id="其他进制转其他进制"><a href="#其他进制转其他进制" class="headerlink" title="其他进制转其他进制"></a>其他进制转其他进制</h4><p>短除法</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/post/9ebdcc7b.html" rel="next" title="Remind">
      Remind <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO"><span class="nav-number">1.</span> <span class="nav-text">TODO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#command-line"><span class="nav-number">1.1.</span> <span class="nav-text">command line</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#doc"><span class="nav-number">1.2.</span> <span class="nav-text">doc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">基础算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">1.快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E5%9D%87%E4%B8%BAnlogn-%EF%BC%8C%E6%9C%80%E5%9D%8F%E4%B8%BAn-2"><span class="nav-number">2.</span> <span class="nav-text">平均为nlogn ，最坏为n^2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="nav-number">3.</span> <span class="nav-text">2.快速选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88o-n-%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">（o(n)）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">3.归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88nlogn%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">（nlogn）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BA%8C%E5%88%86"><span class="nav-number">7.</span> <span class="nav-text">4.二分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="nav-number">7.0.1.</span> <span class="nav-text">4.1整数二分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86"><span class="nav-number">7.0.2.</span> <span class="nav-text">4.2浮点数二分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="nav-number">8.</span> <span class="nav-text">5.高精度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%9B%B8%E5%8A%A0"><span class="nav-number">8.0.0.1.</span> <span class="nav-text">高精度相加</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%9B%B8%E5%87%8F"><span class="nav-number">8.0.0.2.</span> <span class="nav-text">高精度相减</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="nav-number">8.0.0.3.</span> <span class="nav-text">高精度乘法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="nav-number">8.0.0.4.</span> <span class="nav-text">高精度除法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0"><span class="nav-number">8.0.0.5.</span> <span class="nav-text">大整数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">9.</span> <span class="nav-text">6.前缀和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E1%E5%BC%80%E5%A7%8B"><span class="nav-number">10.</span> <span class="nav-text">从1开始</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">10.0.1.</span> <span class="nav-text">6.1一维前缀和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">10.0.2.</span> <span class="nav-text">6.2二维前缀和</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%B7%AE%E5%88%86-%E4%BB%8E1%E5%BC%80%E5%A7%8B"><span class="nav-number">11.</span> <span class="nav-text">7.差分 从1开始</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="nav-number">11.0.1.</span> <span class="nav-text">7.1一维差分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="nav-number">11.0.2.</span> <span class="nav-text">7.2二维差分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">8.双指针算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">13.</span> <span class="nav-text">9.位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%91%A0-n%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E7%AC%ACk%E4%BD%8D%E6%98%AF%E5%87%A0%EF%BC%88%E4%B8%AA%E4%BD%8D%E6%98%AF%E7%AC%AC0%E4%BD%8D%EF%BC%8C%E4%BE%9D%E6%AC%A1%EF%BC%89"><span class="nav-number">13.0.0.1.</span> <span class="nav-text">① n的二进制表示中第k位是几（个位是第0位，依次）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%91%A1lobit-x-return-x-amp-x-%EF%BC%88%E4%B8%8E%E8%BF%90%E7%AE%97%EF%BC%8C%E5%B0%86x%E5%8F%98%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%9B%E8%A1%8C%E4%B8%8E%E8%BF%90%E7%AE%97%EF%BC%89"><span class="nav-number">13.0.0.2.</span> <span class="nav-text">②lobit(x)   return x&amp;-x;（与运算，将x变为二进制进行与运算）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-number">14.</span> <span class="nav-text">10.离散化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="nav-number">15.</span> <span class="nav-text">11.区间合并</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number"></span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">1.链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1.单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">2.双链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%88"><span class="nav-number">2.</span> <span class="nav-text">2.栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E5%BA%94%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">单调栈应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">3.队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">3.1.</span> <span class="nav-text">单调队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-KMP"><span class="nav-number">4.</span> <span class="nav-text">4.KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Trie"><span class="nav-number">5.</span> <span class="nav-text">5.Trie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">6.</span> <span class="nav-text">6.并查集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%A0%86"><span class="nav-number">7.</span> <span class="nav-text">7.堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Hash"><span class="nav-number">8.</span> <span class="nav-text">8.Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">8.1.</span> <span class="nav-text">哈希表的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="nav-number">8.1.1.</span> <span class="nav-text">开放寻址法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95"><span class="nav-number">8.1.2.</span> <span class="nav-text">拉链法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%93%88%E5%B8%8C%E6%B3%95"><span class="nav-number">8.2.</span> <span class="nav-text">字符串前缀哈希法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%87%E5%AE%9A%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%86%B2%E7%AA%81"><span class="nav-number">8.3.</span> <span class="nav-text">假定不存在冲突</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA"><span class="nav-number"></span> <span class="nav-text">搜索与图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS"><span class="nav-number">1.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS"><span class="nav-number">2.</span> <span class="nav-text">BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">3.</span> <span class="nav-text">树和图的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">4.</span> <span class="nav-text">树和图的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">拓扑序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">6.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">朴素Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">堆优化版Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bellman-Ford%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">Bellman-Ford算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPFA"><span class="nav-number">6.4.</span> <span class="nav-text">SPFA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd"><span class="nav-number">6.5.</span> <span class="nav-text">Floyd</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0%E7%89%88Prim%E7%AE%97%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">朴素版Prim算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95"><span class="nav-number">8.1.</span> <span class="nav-text">染色法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-NTR%E7%AE%97%E6%B3%95bushi"><span class="nav-number">8.2.</span> <span class="nav-text">匈牙利算法[NTR算法bushi]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="nav-number"></span> <span class="nav-text">数学知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">数论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%A8%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">质数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%A8%E6%95%B0%E7%9A%84%E5%88%A4%E5%AE%9A%E2%80%94-%E8%AF%95%E9%99%A4%E6%B3%95"><span class="nav-number">1.1.1.</span> <span class="nav-text">质数的判定—-试除法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%E2%80%94-%E8%AF%95%E9%99%A4%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">分解质因数—-试除法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%9B%E8%B4%A8%E6%95%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text">筛质数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0%E7%AD%9B%E6%B3%95"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">朴素筛法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">埃氏筛法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">线性筛法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">约数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E6%89%80%E6%9C%89%E7%BA%A6%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">试除法求一个数的所有约数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">约数个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.2.3.</span> <span class="nav-text">约数之和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-x2F-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">欧几里得算法&#x2F;辗转相除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">欧拉函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">1.5.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">扩展欧几里得算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="nav-number">1.7.</span> <span class="nav-text">中国剩余定理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">组合计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="nav-number">3.</span> <span class="nav-text">高斯消元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="nav-number">4.</span> <span class="nav-text">简单博弈论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DP"><span class="nav-number"></span> <span class="nav-text">DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.1.</span> <span class="nav-text">0-1背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.2.</span> <span class="nav-text">完全背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.3.</span> <span class="nav-text">多重背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.4.</span> <span class="nav-text">分组背包问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7Dp"><span class="nav-number">2.</span> <span class="nav-text">线性Dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">2.0.1.</span> <span class="nav-text">数字三角形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">2.0.2.</span> <span class="nav-text">最长上升子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">2.0.3.</span> <span class="nav-text">最长公共子序列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4Dp"><span class="nav-number">2.1.</span> <span class="nav-text">区间Dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%B3%E5%AD%90%E5%88%92%E5%88%86"><span class="nav-number">2.1.1.</span> <span class="nav-text">石子划分</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NOTE"><span class="nav-number"></span> <span class="nav-text">NOTE</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL"><span class="nav-number"></span> <span class="nav-text">STL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%93%9D%E6%A1%A5%E6%9D%AF"><span class="nav-number"></span> <span class="nav-text">蓝桥杯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A1%E5%B0%86%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BB%A3%E7%A0%81%EF%BC%88%E8%8B%A5%E6%98%AFdfs%EF%BC%8C%E8%80%83%E8%99%91dfs%E4%B8%AD%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%89"><span class="nav-number">0.1.</span> <span class="nav-text">②将搜索树转化为代码（若是dfs，考虑dfs中传入的参数）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%BA%E8%AF%95"><span class="nav-number"></span> <span class="nav-text">机试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">成绩排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">进制转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="nav-number">2.0.1.</span> <span class="nav-text">其他进制转十进制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6"><span class="nav-number">2.0.2.</span> <span class="nav-text">十进制转其他进制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6"><span class="nav-number">2.0.3.</span> <span class="nav-text">其他进制转其他进制</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ooopSok"
      src="/images/image.jpg">
  <p class="site-author-name" itemprop="name">ooopSok</p>
  <div class="site-description" itemprop="description">iiiismmmmme</div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sun-GLiang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun-GLiang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-bolt"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ooopSok</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">23k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">21 mins.</span>
</div>

<!--
-->


<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/24/2023 12:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>
        








      </div>
    </footer>
  </div>

  
  
  <script color='255,51,51' opacity='0.5' zIndex='-1' count='160' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
<script src="/live2d-widget/autoload.js"></script>