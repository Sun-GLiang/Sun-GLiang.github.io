[{"title":"Remind","url":"/post/9ebdcc7b.html","content":"\n## 总纲\n\n之后继续完善网站的一些功能，如**阅读全文、字数统计、网站访问数量、网站动态/静态背景、404报错页面**\n","tags":["MEMO"]},{"title":"AlgorithmNote","url":"/post/d92ce365.html","content":"\n\n\n# 基础算法\n\n\n\n## 1.快速排序\n\n## 平均为nlogn ，最坏为n^2   \n\n  **分治思想**\n\n1.选择分界点x     x  =  q[l]  /  q[(l+r)/2]  /  q[r]  /  随机\n\n2.调整区间       **重难点**\n\n3.递归处理左右两段\n\n\n\n通过设置两个指针i，j分别指向初始序列的两端      i 和 j 相遇后只可能会出现  i == j   和   i = j + 1  两种情况\n\n**注意   j -  - **\n\n**注意  i = l - 1 ,   r = r + 1**\n\n```c++\n#include \"iostream\"\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n;\nint q[N];\n\nvoid quick_sort(int q[], int l, int r)\n{\n    if (l >= r) return;\n    \n    // x 取q的中间值万能\n    int x = q[(l + r) / 2], i = l - 1, j = r + 1;\n    \n    // 指针i 和 j 一旦相遇就结束\n    while(i < j)\n    {\n        do i++; while(q[i] < x);\n        do j--; while(q[j] > x);  // 注意是j--\n        if (i < j) swap(q[i], q[j]);\n    }\n    \n    /* \n    注意若取j j+1，则x=q[*]，*不能取右边界 \n    若取i-1 i，则x=q[*]，不能取左边界\n    */\n    quick_sort(q, l, j);\n    quick_sort(q, j + 1, r);\n    /*\n    quick_sort(q, l, i - 1);\n    quick_sort(q, i, r);\n    */\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &q[i]);\n    \n    quick_sort(q, 0, n-1);\n    \n    for (int i = 0; i < n; i++) printf(\"%d \", q[i]);\n\n    return 0;\n}\n```\n\n[百度](https://www.baidu.com)\n\n--------\n\n[百度](https://www.baidu.com)\n\n## 2.快速选择\n\n## （o(n)）\n\n\n\n与快速排序差不多，只是快速选择需要再输入一个 k 值，最后不用对左右两个区间递归，而只需要对左或右区间进行递归\n\n![](merge.png)\n\n\n```c++\n// C++里面的函数参数与全局变量重名，优先使用局部变量\n\n```\n\n\n\n\n\n## 3.归并排序\n\n## （nlogn）\n\n **分治思想**\n\n1.确定分界点  x = (l + r) / 2\n\n2.递归排序左右两端\n\n3.对左右两端排序好的序列归并（合二为一） **重难点**\n\n\n\n```c++\n#include \"iostream\"\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nint n;\nint q[N], tmp[N];\n// 因为q[N]已经是全局变量了， 所以函数参数有没有q无所谓 了\n\nvoid merge_sort(int q[], int l, int r)\n{\n    if (l >= r) return;\n    \n    int mid = l + r >> 1;\n    \n    merge_sort(q, l, mid); merge_sort(q, mid + 1, r);\n    \n    int k = 0, i = l, j = mid + 1;\n    while(i <= mid && j <= r)\n    \tif (q[i] <= q[j]) tmp[k++] = q[i++];\n    \telse tmp[k++] = q[j++];\n    while (i <= mid) tmp[k++] = q[i++];\n    while (j <= r) tmp[k++] = q[j++];\n    \n    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) scanf(\"%d\", &q[i]);\n    \n    merge_sort(q, 0, n-1);\n    \n    for (int i = 0; i < n; i++) printf(\"%d \", q[i]);\n    \n    return 0;\n}\n```\n\n\n\n## 4.二分\n\n\n\n**<u>用来查找</u>**\n\n\n\n#### 4.1整数二分\n\n二分的本质是找到一个性质，可以确定一个边界问题\n\n有单调性一定可以二分， 而可以二分的不一定有单调性\n\n\n\n求最值考虑一下二分\n\n\n\n```c++\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用\nint bsearch_1(int l, int r)\n{\n    while(l < r)\n    {\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用\nint bsearch_2(int l, int r)\n{\n    while(l < r)\n    {\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n```\n\nwhile里面的模板直接使用，具体check函数根据题目来分析\n\n二分一定是有解的      无解情况取决于题目\n\n每次二分之后保证答案在所选区间内部\n\n\n\n#### 4.2浮点数二分\n\n\n\n```c++\nint dou_bsearch_1(int l, int r)\n{\n    while(l - r > 1e-8)\n    {\n        double mid = l + r >> 1;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n\nint dou_bsearch(int l, int r)\n{\n    while(l - r > 1e-8)\n    {\n        double mid = l + r >> 1;\n        if (check(mid)) l = mid;\n        else r = mid;\n    }\n    return l;\n}\n```\n\n一般1e8这个地方看题目要求， 总是比题目要求保留小数位数多2\n\neg：保留4位小数，1e6\n\n\n\n## 5.高精度\n\n\n\n##### 高精度相加\n\nA + B      len(A), len(B) <= 1e6\n\n##### 高精度相减\n\nA - B       len(A), len(B) <= 1e6\n\n##### 高精度乘法\n\nA * a      len(A) <= 1e6      a <= 1e9\n\n##### 高精度除法\n\nA * a      len(A) <= 1e6      a <= 1e9\n\n\n\n##### 大整数\n\n大整数在c++里面用数组来表示（存储）\n\n把大整数的每一位存到数组里面，按照低位在前进行存储（即第零位存个位）\n\n原因：两个数进行运算会出现进位的可能，这时将高位数放到数组最后一位会使得数据处理起来更方便（否则便会从数组第一位依次后移，效率降低）（栈？？？）\n\n用库函数<vector>来表示一个大整数，一个size函数， 表示一个数组的长度，就不用再额外开一个内存来存储数组的长度了\n\n\n\n模拟人工加法\n\n\n\n\n\n\n\n## 6.前缀和 \n\n## 从1开始\n\n\n\n#### 6.1一维前缀和\n\n\n\n```c++\nS_i = a_1 + a_2 + ... + a_i\n```\n\n- [x] ***下标设置从1开始***\n\n意味着***S_0 = 0***，对应于后面，与后面S_r - S_l-1 保持一致\n\n\n\n如何求S_i            一维前缀和\n\n```c++\nfor (int i = 1; i < n; i++)\n    S_i = S_(i - 1) + a_i\n```\n\n\n\n作用：**能够快速地求出原数组中一段数的和**\n\n区间 [l, r] 这一段的和：***S_r - S_l-1***\n\n```c++\n// 前缀和\nS[i] = a[1] + a[2] + ... a[i]\n// 原数组中一段数的和\na[l] + ... + a[r] = S[r] - S[l - 1]\n```\n\n\n\n\n\n#### 6.2二维前缀和\n\n\n\n```c++\n// S[i, j] 表示 第 i 行 j 列格子左上部分所有元素的和\n\nS[i, j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j]\n\n// 以 ( x1 ,  y1 ) 为左上角， ( x2 ,  y2 ) 为右下角的子矩阵的和为：\n\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n```\n\n\n\n\n\n## 7.差分 从1开始\n\n前缀和的逆运算\n\n#### 7.1一维差分\n\n\n\n```c++\n// 给定a[1], a[2], ... , a[n]，构造差分数组b[N] ，使得 a[i] = b[1] + b[2] + ... + b[i]，即 a 数组是 b 数组的一个前缀和\n```\n\n```c++\n// 核心操作：将a[L, R]区间所有数字加上C， 等价于 b[L] += C, b[R + 1] -= C\n```\n\n \n\n构造b数组        即假设a数组全为0， 则b数组也全为0，但实际上，a数组不全为0。这里构造一个插入函数，\n\n\n\nbits/stdc++.h  -------     万能头文件\n\n\n\n#### 7.2二维差分\n\n\n\n```c++\n// 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\n// S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\n```\n\n\n\n\n\n## 8.双指针算法\n\n**单调--考虑二分或双指针**\n\n<u>**优化**</u>\n\n\n\n核心思想：将双重for循环的O(n^2)的暴力法优化到O(n)\n\n先写出暴力解法，再看枚举时i j 的单调关系\n\n```c++\nfor (int i = 0; i < n; i++)\n{\n    int j = i;\n    while (j < i && check()) j++;\n    \n    // check()寻找i j 之间的关系（比如单调性）\n    // 以上是基本模板格式，下面具体问题具体分析\n}\n```\n\n\n\n## 9.位运算\n\n\n\n##### ① n的二进制表示中第k位是几（个位是第0位，依次）\n\n​\t\t\t\t先把n的第k位移到第0位   n >> k\n\n​\t\t\t\t再看个位数是几   (n >> k) & 1\n\n​\t\t\t\t综述\t----------->\t(n >> k) & 1\n\n\n\n##### ②lobit(x)   return x&-x;（与运算，将x变为二进制进行与运算）  \n\n​\t\t\t\t返回x的二进制的最右边的一个1 \n\n\n\n## 10.离散化\n\n\n\n类似于在一个很大的给定区间范围上，但是可以用到的区域占比很小（类比稀疏矩阵）\n\n通过将所需要用到的数据点坐标映射为1， 2， 3， ... 这样的序列（二分实现），来达到离散化算法的功效。\n\n\n\n必须加入下面这两行代码（先排序，再去重）\n\n```c++\nsort(alls.begin(), alls.end())\nalls.erase(unique(alls.begin(), alls.end()), alls.end())\n```\n\n\n\n\n\n## 11.区间合并\n\n\n\n贪心思想\n\n\n\n\n\n\n\n# 数据结构\n\n\n\n* <u>~~都是用来做优化的~~</u>\n\n\n\n## 1.链表\n\n### \t1.单链表\n\n在算法中用的最多的是邻接表（n个链表）\n\n邻接表主要存储数和图\n\n用数组模拟链表（用于笔试）\n\n结构体指针构造链表会超时（用于面试）\n\n```c++\nconst int N = 100010;\n\n// head表示头结点的下标\n// e[i]表示结点i的值\n// ne[i]表示结点i的next指针是多少\n// idx表示当前所用的是第几个结点\nint head, e[N], ne[N], idx;\n\nvoid init()\n{\n    head = -1, idx = 0;\n}\n\n// 将x插入到头结点\nint add_to_head(int x)\n{\n    e[idx] = x, ne[idx] = head, head = idx++;\n}\n\n// 将x插入到下标是k的结点的后面\nint add(int k, int x)\n{\n    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;\n}\n\n// 将下标是k的点的后面的点删掉\nint remove(int k)\n{\n    ne[k] = ne[ne[k]];\n}\n```\n\n\n\n### \t2.双链表\n\n用来优化某些问题\n\n```c++\nconst int N = 100010;\n\nint e[Nl, l[N], r[N], idx;\n\n// 初始化\nvoid init()\n{\n    // 0表示左端点，1表示右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n\n// 在下标是k的点的右边，插入x\n// 在下标是k的点的左边插入x只要执行操作add(l[k], x);\nint add(int k, int x)\n{\n    e[idx] = x;\n    l[idx] = k;\n    r[idx] = r[k];\n    l[r[k]] = idx;\n    r[k] = idx;\n}\n\n// 删除第k个点\nint remove(int k)\n{\n    r[l[k]] = r[k];\n    l[r[k]] = l[k];\n}\n\n```\n\n\n\n## 2.栈\n\n```c++\nconst int N = 100010;\n\nint stk[N], tt = 0;\n\n// 插入\nstk[++tt] = x;\n\n// 弹出\ntt--;\n\n// 判断栈是否为空\nif (tt > 0) not empty;\nelse empty;\n\n// 取出栈顶元素\nstk[tt];\n\n```\n\n\n\n### 单调栈应用\n\n给定一个序列，求序列中每一个数左边离它最近的且比它小的数字，若不存在则返回-1\n\n与双指针思路类似，先暴力求解，再探究规律\n\n\n\n\n\n## 3.队列\n\n```c++\nconst int N = 100010;\n\n// 在队尾插入元素，在队头弹出元素\nint q[N], hh, tt = -1;\n\n// 插入\nq[++tt] = x;\n\n// 弹出\nhh++;\n\n// 判断队列是否为空\nif (hh <= tt) not empty\nelse empty\n\n// 取出队头元素\nq[hh]\n```\n\n\n\n### 单调队列\n\n典型应用：滑动窗口\n\n与双指针思路类似，先暴力求解，再探究规律，删去没有用的元素\n\n\n\n\n\n## 4.KMP\n\n\n\n可以用来求循环节，其他体型好像都不如字符串前缀哈希了\n\n\n\n\n\n## 5.Trie\n\n\n\n应用：AC自动机\n\n\n\n<u>**一般出现的字符串类型：全是小写字母、全是大写字母、只有数字、只有0/1**</u>\n\n\n\n<u>用来快速（高效）**存储和查找字符串集合**的数据结构</u>\n\n\n\n\n\n## 6.并查集\n\n\n\n**~~面试笔试    思维~~**\n\n\n\n应用之一：Kruskal\n\n\n\n* 用途：\n\n1. 将两个集合合并\n\n2. 询问两个元素是否在一个集合中\n\n近乎O(1)的时间复杂度，很快\n\n\n\n基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，即p[x]表示x的父节点。\n\n\n\n1. 判断树根： if（p[x] == x）\n2. 求x的集合编号：while（p[x] != x） x = p[x];    --------->        优化：路径压缩：一旦找到根节点，就将所有节点都指向根节点\n3. 合并两个集合：设p[x]是x的集合编号，p[y]是y的集合编号。则合并操作：p[x] = y或p[y] = x\n\n\n\n<u>核心操作</u>\n\n寻找x结点的祖宗节点 + 路径优化\n\n```c++\nint find(int x)\n{\n\tif (p[x] != x) p[x] = find(p[x]);\n\treturn p[x];\n}\n```\n\n\n\n\n\n## 7.堆\n\n<u>维护一个数据集合</u>\n\n\n\n* 基本操作\n* 插入与删除都只与树的高度有关，故是logn的\n\n1. 向集合中插入一个数\n2. 求集合当中的最小值\n3. 在集合中删除最小值\n4. 删除集合中任意一个元素\n5. 修改集合中任意一个元素\n\n\n\n这里规定高度/深度/层数都是从1开始的\n\n直接建堆是O(nlogn)的       -PS：因为插入是logn的\n\n可以使用O(n)来建堆\n\n```c++\nfor (int i = n / 2; i ; i--) down(i);\n```\n\n完全二叉树的第n/2个结点是最后一个非叶子节点\n\n\n\n代码\n\n```c++\n// 设堆是heap[], 堆的大小是size\n//1.\nheap[++size] = x; up(size);\n//2.\nheap[1];\n//3.  拿最后一个结点把第一个结点覆盖掉，再down      PS：因为是用一维数组存储的，所有删掉第一个元素是O(n)的，而删除最后一个元素是O(1)的\nheap[1] = heap[size]; size--; down(1);\n//4.\nheap[k] = heap[size]; size--; down(k) / up(k);\n//5.\nheap[k] = x; down(k) / up(k);\n```\n\n\n\n堆是一个完全二叉树           堆中某个节点的值总是不大于或不小于其父节点的值\n\n小根堆：每个节点的值都 ≤ 它的左右儿子的值\n\n\n\n* 堆的存储结构（堆状数据结构/完全二叉树）：一维数组         一维数组就可以存下一棵树\n\n***1号点是根节点   下标是x的结点的左儿子下标是2x，右儿子下标是2x+1***\n\n下面的一维数组即表示下面的小根堆\n\n| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n\n```mermaid\ngraph TD;\n\t1-->2;\n\t1-->3;\n\t2-->4;\n\t2-->5;\n\t3-->6;\n\t3-->7;\n\t4-->8;\n\t4-->9;\n\t5-->10;\n```\n\n\n\n***基本操作***\n\n1. down(x)（将结点往下调整）\n2. up(x)（将结点往上调整）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 8.Hash\n\n\n\n离散化是一种特殊的hash          离散化 = 排序 + hash\n\n离散化保证了映射后原数据的顺序保持不变，hash并没有保证；且离散化是nlogn（maybe），hash是O(1)的\n\n把一堆数据映射到0~N的小空间（N=10^5~10^6）\n\n将所有的数放在小空间中，解决冲突问题（**冲突问题是指利用hash函数映射后，可能会出现多个数映射到同一个数的情况**）\n\n利用hash函数进行映射，一般取对10^5取模这个操作作为hash函数 h(x) = x mod 10^5，其中10^5取质数，且取距离2的整次幂尽可能远（冲突的概率是最低的）\n\n\n\n根据处理冲突问题的不同的解决方案，分为开放寻址法和拉链法\n\n\n\n### 哈希表的存储结构\n\n\n\nhashmap是拉链法，threadlocal是开放寻址法？？？？\n\nhash在算法题中一般只有插入和查找这两个操作，没有删除\n\n\n\n#### 开放寻址法\n\n开了一个一维数组，数组大小为题目要求大小的2~3倍\n\n```c++\n// 核心函数\n// find函数  如果x在哈希表中已经存在，就返回x所在的位置；如果x在哈希表中不存在，则返回x应该存储的位置\nint find(int x)\n{\n    int k = (x % N + N) % N;\n    \n    // 茅厕寻址法：当当前坑位有人且当前坑位中的人不是你要找的人才进入循环\n    while (h[k] != null && h[k] != x)\n    {\n        k++;\n        if (k == N) k = 0;\n\t}\n    \n    return k;\n}\n```\n\n\n\n\n\n#### 拉链法\n\n开一个一维数组（数组大小为“利用hash函数进行映射，一般取对10^5取模这个操作作为hash函数 h(x) = x mod 10^5，其中10^5取质数，且取距离2的整次幂尽可能远（冲突的概率是最低的）“这样大小的）来存储所有的hash值，该一维数组每个结点都表示一个表头\n\n若经过hash映射后，出现了两个相同的映射值，则依次将这两个数插到对应一维数组头节点下面，形成邻接链表。\n\n```cpp\nvoid insert(int x)\n{\n    int k = (x % N + N) % N;\n    e[idx] = x, ne[idx] = h[k], h[k] = idx++;\n}\n\nbool find(int x)\n{\n    int k = (x % N + N) % N;\n    \n    for (int i = h[k]; i != -1; i = ne[i])\n        if (e[i] == x)\n            return true;\n    \n    return false;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n### 字符串前缀哈希法\n\n### 假定不存在冲突\n\n\n\n快速判断两个字符串是否相等\n\n\n\n---\n\n1. 先预处理出所有前缀的哈希值\n2. 求出所有的前缀字符串的哈希值\n3. 利用这些前缀字符串哈希值可以表示出字符串中任意子串\n\n---\n\n\n\n\n\n---\n\n**<u>将任意字符串转化为哈希值的方法：</u>**\n\n把字符串看作p进制数\n\n把p进制数转化为10进制数\n\n对该字符串哈希值mod Q\n\n则对于任意一个字符串，都可以将其表示为0~Q-1的一个数字（通常不将字符串映射成0）\n\n***取p = 131或13331，Q = 2^64***\n\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 搜索与图论\n\n\n\nDFS和BFS都可以对整个空间搜索，搜索结构都是树的形式。\n\n但是DFS尽可能往深了搜，一旦达到叶节点就会回溯\n\nBFS会将当前这一层搜索完了才会继续搜索下一层\n\n\n\n## DFS\n\n**思路比较奇怪就用DFS或对空间要求比较高**\n\n依靠stack\n\n空间复杂度为 O(h)   即与高度成正比\n\n不具有最短路性质\n\n\n\n时间复杂度为线性的\n\n\n\nDFS俗称“暴搜”\n\n要考虑好**顺序**\n\n\n\n从搜索树的角度考虑\n\n\n\n回溯\n\n\n\n\n\n剪枝\n\n\n\n\n\n\n\n\n\n## BFS\n\n**问最短距离，最小步数，最少操作几次** （前提是每个边的权重都是一样的）\n\n![](bfs.png)\n\n依靠queue\n\n空间复杂度为O(2^h)\n\n具有最短路性质\n\n\n\n## 树和图的存储\n\n\n\n树是无环连通图，是一种特殊的图\n\n\n\n可以把无向图变成两个方向的有向图，只用考虑有向图的存储即可实现无向图的存储\n\n\n\n存储方式分为**邻接矩阵**和**邻接表**两种\n\n\n\n**邻接矩阵** 用一个二维数组实现 g\\[a\\]\\[b\\] 存储边a到边b的信息（即权重）不能存储重边 适合存储稠密图  O(n^2)\n\n**邻接表** 就是n个单链表（其中n表示节点个数），每个单链表用来存储这个结点可以到达的结点 \n\n往邻接表中插入数据时，选择在链表头进行插入\n\n\n\n\n\n常用**邻接表**来存储\n\n\n\n## 树和图的遍历\n\n\n\n分为深度优先遍历和广度优先遍历，每个点只需遍历一次   时间复杂度是O(n + m)   n为节点数，m为边数\n\n\n\n只用考虑有向图的遍历即可（无向图是一种特殊的有向图，树是一种特殊的图）\n\n\n\n遍历只需要找到一条路即可，不必再像dfs中再恢复现场\n\n\n\n这两种搜索方式的思想就是dfs和bfs\n\n\n\n####深度优先遍历\n```cpp\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nvoid dfs(int u)\n{\n    st[u] = true;\n\n    for (int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j]) dfs(j);\n    }\n}\n```\n\ndfs会求得每一个子树的大小\n\n\n\n####广度优先遍历\n```cpp\n\n```\n\n\n## 拓扑序列\n\n针对有向图，无向图没有拓扑序列\n\n\n\n是广度优先算法的应用\n\n\n\n有向无环图一定存在一个拓扑序列    有向无环图也被称为拓扑图\n\n有向环图一定不存在拓扑序列\n\n\n\n所有入度为0的点都可以排在当前序列中最前面的位置\n\n\n\n\n\n## 最短路\n\n\n\nn表示结点数，m表示边数\n\n```mermaid\ngraph TD;\n\t最短路-->单源最短路;\n\t最短路-->多源汇最短路;\n\t单源最短路-->所有边权都是正数;\n\t单源最短路-->存在负权边;\n\t所有边权都是正数-->朴素Dijkstra算法;\n\t所有边权都是正数-->堆优化版的Dijkstra算法;\n\t朴素Dijkstra算法-->n2适合稠密图;\n\t堆优化版的Dijkstra算法-->mlongn适合稀疏图;\n\t存在负权边-->Bellman-Ford;\n\tBellman-Ford-->nm;\n\tBellman-Ford-->不超过k条边的最短路问题;\n\t存在负权边-->SPFA;\n\tSPFA-->一般是m,最坏是nm;\n\t多源汇最短路-->Floyd算法;\n\tFloyd算法-->n3;\n```\n\n\n\n最短路问题的核心是如何把题干抽象为一个图，如何定义点和边来确定最短路问题\n\n\n\n### 朴素Dijkstra算法\n\n```cpp\n// 1.初始化dist数组\ndist[1] = 0, dist[i] = 0x3f3f3f3f; // i = 2,3,...,n\n\n// 2.\nfor (int i = 0; i < n; i++)\n{\n    // （1）\n    先找出不在s中的最短距离的点t\n    \n    // （2）\n    将此最短距离的点t加入最短路数组s中\n        \n    // （3）\n    用此次的最短距离的点t来更新其他点的距离\n}\n```\n\n\n\n\n\n### 堆优化版Dijkstra算法\n\n```cpp\n// 初始化dist数组\ndist[1] = 0, dist[i] = 0x3f3f3f3f;\n\n利用priority_queue来存储，可以将朴素Dijkstra的（1）优化到O(1)\npriority_queue 更新操作是logn的，而低（3）步一共需要更新所有的边共m次，故时间复杂度为mlogn\n但是priority_queue 中不支持修改任意一个元素，只能接受冗余的存在，即每次修改都往堆里面插入一个新的数\n所以本来堆里面是有n个数（手写堆可以保证），但是此时用的STL，priority_queue里面会有m个数\n所以实际上的时间复杂度为mlogm\n// 2.\nfor (int i = 0; i < n; i++)\n{\n    // （1）\n    先找出不在s中的最短距离的点t // O(1)\n    \n    // （2）\n    将此最短距离的点t加入最短路数组s中 // O(1)\n        \n    // （3）\n    用此次的最短距离的点t来更新其他点的距离 // logn\n}\n```\n\n\n\n\n\n\n\n### Bellman-Ford算法\n\n如果图中存在负权回路，则最短路可能会不存在（为-∞）\n\n```cpp\nfor (int i = 0; i < n; i++)\n{\n    备份dist\n    for (循环所有边 a b w  由a->b，权重为w)\n        更新每一条边 dist[b] = min(dist[b], dist[a] + w); // 松弛操作\n}\n```\n\n\n\n​\t\n\n### SPFA\n\n只要图中没有负环，就可以用SPFA\n\n```cpp\n// 初始化队列\nq.push(1);\n\n// 队列中存储的是从起点到该节点距离变小的结点\n\n//\nwhile (q.size())\n{\n    取出队列的首元素t，弹出首元素\n    \n    更新t的所有出边，并把对应的出边的结点加到队列里面（因为t的所有出边由于t是变小的，所以它的所有出边也变小了，也要加入到队列中）（如果队列里面有了就不用了）\n}\n```\n\n\n\n\n\n### Floyd\n\n```cpp\n// 邻接矩阵存储所有的边\nfor (int k = 1; k <= n; k++)\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n```\n\n\n\n\n\n## 最小生成树\n\n\n\n最小生成树一般涉及到的图都是无向图\n\n\n\n稠密图，一般就用朴素版Prim算法\n\n稀疏图，一般用Kruskal算法\n\n堆优化版Prim算法不常用\n\n```mermaid\ngraph TD;\n\t最小生成树-->Prim算法;\n\t最小生成树-->Kruskal算法;\n\tPrim算法-->朴素版Prim算法;\n\tPrim算法-->堆优化版Prim算法;\n\t朴素版Prim算法-->适用于稠密图n2;\n\t堆优化版Prim算法-->适用于稀疏图mlogn;\n\tKruskal算法-->mlogm;\n```\n\n### 朴素版Prim算法\n\n```cpp\n初始化dist[N] <- 0x3f3f3f3f\n\nfor (int i = 0; i < n; i++) // 循环n次\n{\n    找到集合外距离最近的点t\n    \n    用t来更新其他点到集合的距离\n        \n    st[t] = true;\n}\n```\n\n\n\n### Kruskal算法\n\n```cpp\n将所有边按权重从小到大进行排序  //O(mlongm)\n    \n// 并查集思想   并查集是O(1) 总共就是O(m)\n枚举每条边a-b，权重为c\n    若a-b不连通，则将a-b这条边加入到集合中\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 二分图\n\n\n\n```mermaid\ngraph TD;\n\t二分图-->染色法...就是一个dfs,判断图是否为二分图-->m+n;\n\t二分图-->匈牙利算法-->最坏是mn,实际运行时间一般远小于mn;\n```\n\n### 染色法\n\n一个图是二分图当且仅当图中不含奇数环\n\n```cpp\nfor (int i = 1; i <= n; i++)\n    if (i未被染色)\n        dfs(i, color)\n```\n\n\n\n\n\n### 匈牙利算法[NTR算法bushi]\n\n存储用邻接表\n\n\n\n最坏时间复杂度是\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 数学知识\n\n\n\n## 数论\n\n\n\n### 质数\n\n在大于1的整数中，如果只包含1和其本身这两个约数，则该数就称为质数/素数\n\n\n\n#### 质数的判定----试除法\n\n```cpp\n// 从定义来\n// O(n)\nbool is_prime(int x)\n{\n\tif (x < 2) return false;\n    for (int i = 2; i < x; i++)\n        if (x % i == 0)\n            return false;\n   \treturn true;\n}\n\n// 优化后\n// O(sqrt(n))\nbool is_prime(int x)\n{\n    if (x < 2) return false;\n    for (int i = 2; i <= n / i; i++)\n        if (x % i == 0)\n            return false;\n   \treturn true;\n}\n// 原理见下方的数学块中内容\n```\n\n$$\n如果d|n，则\\frac{n}{d}|n。因此若要枚举n的所有大于1的约数，只需要有d \\lt \\frac{n}{d}，即枚举到\\frac{n}{d}即可\\\\\n$$\n\n\n\n\n\n#### 分解质因数----试除法\n\n$$\n分解质因数：一个数x可以分解为，x = {p_1}^{\\alpha_1}{p_2}^{\\alpha_2}...{p_k}^{\\alpha_k}，其中p_1,p_2,...,p_k均为质数\n$$\n\n\n\n\n$$\n一个数x中至多只包含一个大于\\sqrt{n}的质因数\n$$\n\n```cpp\n// 最坏是O(sqrt(x))，最好的O(logn)---比如x=2^k;\nvoid divide(int x)\n{\n    for (int i = 2; i <= x / i; i++)\n        if (x % i == 0)\n        {\n            int num = 0;\n\t\t\twhile (x % i == 0)\n            {\n                x /= i;\n                num++;\n            }\n            cout << i << ' ' << num << endl;\n        }\n    if (x > 1) cout << x << ' ' << 1 << endl;\n}\n```\n\n\n\n\n\n#### 筛质数\n\n将所有小于等于x的质数筛出来\n\n\n\n##### 朴素筛法\n\n```cpp\nint primes[N]; // 用来存储筛出来的质数\nbool st[N]; // 如果当前这个数被筛去了，则赋值为true\n\n// 朴素筛法 O(nlogn)\nvoid get_primes(int x)\n{\n    for (int i = 2; i <= n; i++)\n    {\n        if (!st[i]) primes[cnt++] = i;\n    \tfor (int j = i + i; j <= n; j += i) st[j] = true;\n    }\n}\n```\n\n**朴素筛法时间复杂度分析**\n$$\n朴素筛法时间复杂度分析：当i=2时，第二层循环循环\\frac{n}{2}；当i=3时，第二层循环循环\\frac{n}{3}...当i=n时，第三层循环循环1次。\\\\故第二层循环总的循环次数为\\frac{n}{2} + ... + \\frac{n}{n}=n(\\frac{1}{2} + ... + \\frac{1}{n})，取极限有\\lim_{t->+\\infty}n(\\frac{1}{2} + ... + \\frac{1}{n})≈nlnn≈nlogn\n$$\n\n$$\n\\lim_{t->+\\infty}(1 + \\frac{1}{2} + ... + \\frac{1}{n}) = lnn + C，其中C为欧拉常数，lnn为log_en\n$$\n\n\n\n\n\n##### 埃氏筛法\n\n```cpp\n实际上，上面的第二层循环将2~x中所有数的倍数都枚举了一遍，但实际上，只需要将2~x中的所有质数的倍数枚举删去它们即可，故可做优化\n// 埃氏筛法 O(nloglogn)    \nvoid get_primes(int x)\n{\n    for (int i = 2; i <= n; i++)\n        if (!st[i]) \n        {\n            primes[cnt++] = i;\n        \tfor (int j = i + i; j <= n; j += i) st[i] = true;\n        }\n}\n```\n\n**埃氏筛法时间复杂度分析**\n$$\n埃氏筛法时间复杂度分析：由于只用筛去质数的所有倍数，故有\\lim_{t->+\\infty}n({\\frac{1}{2} + ... + \\frac{1}{n}}_{质数})≈nlnn/lnn≈nlogn/lnn≈n\\\\\n实际上真实的理论上的时间复杂度为O(nloglogn)\n$$\n\n$$\n质数定理：1-n当中一共有\\frac{n}{lnn}个质数\n$$\n\n\n\n\n\n##### 线性筛法\n\n```cpp\n// 线性筛法\n// 把每一个合数只会被它的最小质因子筛掉\n// O(n)\nvoid get_primes(int x)\n{\n    for (int i = 2; i <= n; i++)\n    {\n        if (!st[i]) primes[cnt++] = i;\n        for (int j = 0; primes[j] <= n / i; j++)\n        {\n\t\t\tst[primes[j] * i] = true;\n            if (i % primes[j] == 0) break; // primes[j]一定是i的最小质因子\n        }\n        // 从小到大枚举的所有质数\n        // 1. i % primes[j] == 0    primes[j]一定是i的最小质因子,primes[j]一定是primes[j]*i的最小质因子\n        // 2. i % primes[j] != 0\tprimes[j]一定小于i的所有质因子,primes[j]一定是primes[j]*i的最小质因子\n        //\n        // 对于一个合数x，假设primes[j]是x的最小质因子，则当i枚举到x / primes[j]时，该合数x一定会被筛掉，而且仅用最小质因子来筛，又每个数只有一个最小质因子，所以每个合数只会被筛掉一次，所以是线性的\n        //\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n### 约数\n\n\n\n#### 试除法求一个数的所有约数\n\n```cpp\nvertor<int> get_divitors(int x)\n{\n    vector<int> res;\n    for (int i = 1; i <= x / i; i++)\n        if (x % i == 0)\n        {\n\t\t\tres.push_back(i);\n            if (i != x / i) res.push_back(n / i);\n        }\n    return res;\n}\n```\n\n\n\n\n\n#### 约数个数\n\n$$\n算数基本定理\\\\\n任何一个数x可以进行质因数分解，分解为x = {p_1}^{\\alpha_1}{p_2}^{\\alpha_2}...{p_k}^{\\alpha_k}，其中p_1,p_2,...,p_k均为质数\n$$\n\n\n\n**约数个数为**\n$$\n(\\alpha_1+1)(\\alpha_2+1)...(\\alpha_k+1)\n$$\n\n$$\n由于一个数x可以进行质因数分解，分解为x = {p_1}^{\\alpha_1}{p_2}^{\\alpha_2}...{p_k}^{\\alpha_k}\\\\\n假设x的其中一个约数为d，则d也可以进行质因数分解，分解为d = {p_1}^{\\beta_1}{p_2}^{\\beta_2}...{p_k}^{\\beta_k}\\\\\n由于每个数的质因数分解形式都是一样的，且对于不同的指数的组合，对应不同的数，所以约数个数就是\\beta_1,...,\\beta_k的选法的个数\\\\\n又0 \\leq \\beta_i \\leq \\alpha_i，因此\\beta_i共有\\alpha_i + 1种取法\\\\\n所以由乘法原理有约数个数为(\\alpha_1+1)(\\alpha_2+1)...(\\alpha_k+1)\n$$\n\nint范围内，拥有最多约数的数的约数个数仅为1536\n\n\n\n\n\n\n\n#### 约数之和\n\n$$\n(p_1^0+p_1^1+...+p_1^{\\alpha_1})...(p_k^0+p_k^1+...+p_k^{\\alpha_k})\n$$\n\n\n\n\n\n### 欧几里得算法/辗转相除法\n\n$$\n(a, b) = (b, a \\% b)\\\\\na \\% b <===> a-\\lfloor \\frac{a}{b} \\rfloor *b\\\\\nProof:\\\\\n必要性：如果d=(a, b),则d|a, d|b,即d为a，b的最大公约数；又有d|(ax+by),所以d|(a-\\lfloor \\frac{a}{b} \\rfloor *b)=d|(a\\%b),所以d=(b, a \\% b)\\\\\n充分性：如果d=(b, a \\% b),有d|b,d|(a\\%b)=d|(a-\\lfloor \\frac{a}{b} \\rfloor *b),所以d|(a-\\lfloor \\frac{a}{b} \\rfloor *b + \\lfloor \\frac{a}{b} \\rfloor *b)=d|a,所以d=(a,b)\n$$\n\n```cpp\nint gcd(int a, int b)\n{\n    return b ? gcd(g, a % b) : a;\n}\n```\n\n\n\n\n\n\n\n\n\n### 欧拉函数\n\n$$\n欧拉函数，记作\\varphi(n)，表示1-n中与n互质的数的个数（互质就是指两个数的gcd=1）\n$$\n\n$$\n求欧拉函数的公式：\\\\\n设数N的质因数分解为N={p_1}^{\\alpha_1}{p_2}^{\\alpha_2}...{p_k}^{\\alpha_k}，则\\varphi(N)=N(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})...(1-\\frac{1}{p_k})\n$$\n\n\n$$\n欧拉函数公式证明（用到了容斥原理）\\\\\n要想求得1-N中和N互质的数的个数就要：①从1-N中减去p_1,p_2,...,p_k的所有倍数;②加上所有p_i*p_j的倍数;③减去所有p_i*p_j*p_k的倍数;④加上所有...\\\\\n就有个数为N-\\frac{N}{p_1}-\\frac{N}{p_2}-...-\\frac{N}{p_k}+\\frac{N}{p_1*p_2}+\\frac{N}{p_1*p_3}-...+\\frac{N}{p_{k-1}*p_k}-\\frac{N}{p_1*p_2*p_3}-\\frac{N}{p_1*p_2*p_4}-...-\\frac{N}{p_{k-2}p_{k-1}*p_k}+...=欧拉函数\n$$\n\n\n```cpp\n// 时间复杂度主要取决于分解质因数\n// O(logx)-O(sqrt(x))\nint euler_func(int x)\n{\n    int res = x;\n    for (int i = 2; i <= x / i; i++)\n        if (x % i == 0)\n        {\n\t\t\twhile (x % i == 0) x /= i;\n            res = res / i * (i - 1);\n        }\n   \tif (x > 1) res = res / x * (x - 1);\n    return res;\n}\n```\n\n\n\n\n\n\n\n```markdown\n求1-N中每一个数的欧拉函数，用上述做法，就要将每一个数进行质因数分解，则时间复杂度为O(Nsqrt(N))\n\n利用线性筛法来去欧拉函数，会使得时间复杂度降低到O(N)\n```\n\n```cpp\nvoid get_eulers(int n)\n{\n    phi[1] = 1;\n    for (int i = 2; i <= n; i++)\n    {\n        if (!st[i]) \n        {\n            primes[cnt++] = i;\n            phi[i] = i - 1;\n        }\n        for (int j = 0; primes[j] <= n / i; j++)\n        {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) \n            {\n                // 如果i % primes[j] == 0，则primes[j]是i的最小质因数，即i的质因数分解和i * primes[j]的质因数分解得到的质数是相同的（有相同的质因数），因此phi[i * primes[j]]与phi[i]只差primes[j]倍\n                phi[i * primes[j]] = phi[i] * primes[j];\n                break;\n            }\n            // 如果i % primes[j] != 0，则primes[j]是i * primes[j]的最小质因数，就有phi[i * primes[j]] = phi[i] * phi[j]，而j是质因数，所以phi[j] = primes[j] - 1\n            phi[i * primes[j]] = phi[i] * (primes[j] - 1);\n        }\n    }\n}\n```\n\n\n\n\n\n**欧拉定理**\n$$\n若a与n互质，则a^{\\varphi(n)}\\equiv1(mod \\ \\ n)，其中\\varphi(n)为欧拉函数\n$$\n\n$$\nProof:\\\\\n假设1-n中与n互质的数分别为a_1,a_2,...,a_{\\varphi(n)}(因为欧拉函数为\\varphi(n)),则又由于a与n互质，可知有aa_1,aa_2,...,aa_{\\varphi(n)}也与n互质，\\\\且互不相同（反证法）,而且aa_1,aa_2,...,aa_{\\varphi(n)}在模n的情况下是与a_1,a_2,...,a_{\\varphi(n)}为同一组数。因此有\\\\a^{\\varphi(n)}a_1a_2...a_{\\varphi(n)}\\equiv a_1a_2...a_{\\varphi(n)}(mod \\ n)---->a^{\\varphi(n)}\\equiv 1(mod \\ n)\n$$\n\n\n\n**费马小定理**\n$$\n在欧拉定理中，当n为质数时，有a^{n-1}\\equiv 1(mod \\ n)\\\\\n因为\\varphi(n)=n-1\n$$\n\n\n\n\n### 快速幂\n\n$$\na^k\\ mod\\ \\ p\\\\\n可以在O(logk)的时间复杂度下求得上面的结果，其中0\\le a,k,p\\le10^9\n$$\n\n\n\n快速幂的核心思路：反复平方法\n\n\n\n预处理出来\n$$\n二进制思想\\\\预处理出来\\\\\na^{2^0}mod\\ p\\\\\na^{2^1}mod\\ p\\\\\n...\\\\\na^{2^{log_2k}}mod\\ p\\\\\n则a^k可以有上面预处理出来的基来表示\\\\\n而且上面的基有关系为(a^{2^0})^2=a^{2^1},(a^{2^1})^2=a^{2^2}...\n$$\n\n```cpp\nint qmi(int a, int k, int p)\n{\n    int res = 1;\n    while (k)\n    {\n    \tif (k & 1) res = (long long)res * a % p;\n        k >>= 1;\n        a = (long long)a * a % p;\n    }\n    return res;\n}\n```\n\n\n\n\n\n**利用快速幂求逆元**\n\n$$\n乘法逆元的定义：若整数b，m互质，并且对于任意的整数a，如果满足b|a，则存在一个整数x，使得\\frac{a}{b}≡a×x(mod \\ m)，则称x为b的模m乘法逆元，记为 b^{−1}(mod\\ m)。\\\\\nb存在乘法逆元的充要条件是b与模数m互质。\\\\\n当模数m为质数时，b^{m−2}即为b的乘法逆元。（参见费马小定理）\n$$\n\n$$\n当x为b的乘法逆元时，有x=b^{-1}(mod \\ m)。带入乘法逆元定义式，有\\frac{a}{b}\\equiv a×b^{-1}(mod\\ m)，化简得bb^{-1}\\equiv 1(mod\\ m)\\\\\n由于m为质数，由费马小定理可知，b^{m-1}\\equiv1(mod\\ m)，联立有b^{-1}(mod\\ m)=b^{m-2}\n$$\n\n\n\n\n\n\n\n\n\n### 扩展欧几里得算法\n\n\n\n**裴蜀定理**\n$$\n对于任意的正整数a，b，一定存在非零整数x，y，使得ax+by=gcd(a, b)\n$$\n利用扩展欧几里得算法可以求得一组x,y使得x,y满足ax+by=gcd(a,b)\n\n\n\n\n\n**线性同余方程**\n\n\n\n\n\n\n\n\n\n\n\n### 中国剩余定理\n\n$$\n有m_1,m_2,...m_k两两互质，则对于如下的线性同余方程组\\\\\n\\begin{cases}\nx = a_1(mod \\ m_1) \\\\\nx = a_2(mod \\ m_2) \\\\\n...\\\\\nx = a_k(mod \\ m_k)\n\\end{cases}\\\\\n有解为x=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+...+a_kM_kM_k^{-1}\\\\\n其中M=m_1m_2...m_k,M_i=\\frac{M}{m_{i}},M_i^{-1}表示M_i模m_i的逆\n$$\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 组合计数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 高斯消元\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 简单博弈论\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# DP\n\n\n\n时间复杂度分析：状态数量*计算每个状态需要的计算量\n\n\n\n\n\n## 背包问题\n\nN个物品和容量为V的背包，每个物品的体积v_i，价值w_i\n\n#### 0-1背包问题\n\n每件物品最多只能用一次\n\n\n\n状态---未知数\n\n状态表示指的是整个问题需要用几维的状态来表示，背包问题一般为两维\n\n状态计算指的是如何一步一步把每一个状态算出来\n\n\n\nDp问题的优化是对状态方程/程序做一个等价变形\n\n\n\n每一个状态表示的都是一个集合，集合里面是一堆选法，是所有选法的一个集合\n\n状态计算就是考虑如何把当前的集合划分为若干个更小的子集，使得每一个子集都可以用更小的集合表示出来\n\n集合划分的原则---不重不漏（求num），不漏（求max，min）\n\n```mermaid\ngraph TD;\n\tDp-->状态表示f_ij-->集合-->所有选法的集合;\n\t集合-->条件-->1.只从前i个物品中选;\n\t条件-->2.选出来物品的总体积小于等于j;\n\t状态表示f_ij-->属性-->Max;\n\tDp-->状态计算-->集合的划分-->按照第i个物品有没有选上来划分;\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 完全背包问题\n\n每件物品可以用无限次\n\n```mermaid\ngraph TD;\n\tDp-->状态表示f_ij-->集合-->所有从前i个物品中选且总体积不超过j的所有选法的集合;\n\t状态表示f_ij-->属性-->Max;\n\tDp-->状态计算-->集合的划分-->按照第i个物品选0,1,2...k个来划分;\n```\n\n三维时的状态转移方程为 f[i, j] = f[i - 1, j - k * v[i]] + k * w[i]\n\n枚举k将状态转移方程展开\n\nf[i, j] = max(f[i - 1, j], f[i - 1, j - v] + w, f[i - 1, j - 2v] + 2w + ...)\n\nf[i, j - v] =           max(f[i - 1, j - v], f[i - 1, j - 2v] + w, ...)\n\n因此状态转移方程优化为f[i, j] = max(f[i - 1, j], f[i, j - v] + w)\n\n\n\n\n\n\n\n#### 多重背包问题\n\n每件物品最多只能用s_i次\n\n\n\n优化：二进制优化\n\n每件物品最多可以用s_i次\n通过二进制优化，可以将s_i拆解为logs_i个（1,2,4,8...），且拆解出来的每一项仅可用一次\n因此，所有的物品总共会最多拆解出Nlogs_i个\n而每件拆解出来的物品又只能用一次\n因此变为了一个0-1背包问题\n时间复杂度由NVs降为NVlogs\n\n\n\n\n\n\n\n#### 分组背包问题\n\n物品有N组，每一组物品有若干种物品，每一组里最多只能选一种物品\n\n\n\n\n\n## 线性Dp\n\n递推的顺序有一个明显的线性顺序\n\n\n\n#### 数字三角形\n\n```mermaid\ngraph TD;\n\tDp-->状态表示f_ij-->集合-->从起点到点i,j的所有路径的集合;\n\t状态表示f_ij-->属性-->Max;\n\tDp-->状态计算-->集合的划分-->按照走到i,j这个点的路径是从左上角走来的还是右上角走来的进行划分;\n```\n\n左上角走来的状态转移方程f[i - 1, j - 1] + a[i, j]\n\n右上角走来的状态转移方程f[i - 1, j] + a[i, j]\n\n#### 最长上升子序列\n\n动态规划时间复杂度分析：\n状态数量*计算每一个状态需要的的时间\n \n\n这个算法的时间复杂度为O(n^2)\n\n```mermaid\ngraph TD;\n\tDp-->状态表示f_i-->集合-->所有以第i个数结尾的上升子序列;\n\t状态表示f_i-->属性-->Max;\n\tDp-->状态计算-->集合的划分-->按第i个数前一位是原序列的第几位来分类;\n```\n\n动态规划求方案就是把状态转移记录下来\n\n#### 最长公共子序列\n\n```mermaid\n    graph TD;\n\tDp-->状态表示f_i-->集合-->所有在第一个序列的前i个字母中出现且在第二个序列的前j个字母中出现的子序列;\n\t状态表示f_i-->属性-->Max;\n\tDp-->状态计算-->集合的划分-->按子序列中是否包含第一个序列的第i个字母第二个序列第j个字母划分;\n```\n\n\n### 区间Dp\n\n#### 石子划分\n\n以最后一次分界的位置来分类\n\n区间Dp要保证算每个f_ij所依赖的状态都已经算好了\n顺序：枚举区间长度，从小到大枚举\n\n```mermaid\n    graph TD;\n\tDp-->状态表示f_ij-->集合-->所有将第i堆石子到第j堆石子合并成一堆石子的合并方式;\n\t状态表示f_ij-->属性-->Min;\n\tDp-->状态计算-->集合的划分-->以最后一次合并的分界线的位置来分类;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# NOTE\n\n数据规模在100万以上，采用scanf和printf，否则cin和cout与他俩效率差不多\n\n\n\n\n\n\n\n\n\n# STL\n\n* `vector`（变长数组），倍增的思想，支持比较运算（按字典序）\n  \t定义：：\n          `vector <int> a`; 定义：一个vector数组a\n          `vector <int> a(10)`; 定义：一个长度为10的vector数组a\n          `vector <int> a(10,3)`; 定义：一个长度为10的vector数组a，并且所有元素都为3\n      **常用函数**：：\n          size(); 返回元素个数  O(1)\n          empty(); 返回是否是空  O(1)\n          clear(); 清空\n          front(); 返回vector的第一个数\n          back(); 返回vector的最后一个数\n          push_back(); 向vector的最后插入一个数\n          pop_back(); 把vector的最后一个数删掉\n          begin(); vector的第0个数\n          end(); vector的最后一个的数的后面一个数\n      **倍增的思想**：    \n\n  ​\t\t\t操作系统为某一进程分配空间时所花费的时间与空间大小无关，而与申请的次数有关。\n\n  ​\t\t\t************************************\n\n  ​    **遍历方法**\n  ​        假设有个vector <int> a;\n\n  ​\t\ta.begin() = a[0],   a.end() = a[s.size()]\n\n  ​        第一种\n\n  ```c++\n   for(int i = 0; i < a.size(); i++) \n       cout << a[i] << ' ';\n  ```\n\n  ​        第二种\n\n  ```c++\n  for(vector <int>::iterator i = a.begin(); i != a.end(); i++)\n      cout << *i << ' ';  \n  //vector <int>::iterator可以写为auto\n  for(auto i = a.begin(); i != a.end(); i++)\n      cout << *i << ' ';  \n  ```\n\n  ​        第三种       \n\n  ```c++\n  for(auto x : a) \n      cout << x << ' ';\n  ```\n\n​\t\t**支持比较运算**\n\n​\t\t\t\t\t按字典序比较，从第一个值开始比较，如果当前值小于则小于，如果等于则比较下一位\n\n\n\n* `pair`，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）\n      定义：：\n\n  ​        pair <类型,类型> 变量名; 存储一个二元组    两个类型可以不同\n  ​    初始化方式：\n  ​        假设有个pair <int,string> p;\n  ​        第一种        \n\n  ```c++\n  p = make_pair(10,\"abc\");\n  ```\n\n  ​        第二种         \n\n  ```c++\n  p = {10,\"abc\");\n  ```\n\n  ​\t\t也可以用pair存两个以上的不同类型的值\n\n  ```c++\n  pair<int, pair<int, string>> p;\n  ```\n\n  常用函数：：\n          first(); 第一个元素\n          second(); 第二个元素\n\n  \n\n* `string`（字符串）\n      常用函数：：\n          substr(); 返回某一个子串\n          c_str(); 返回string对应的字符数组的头指针\n          size(); 返回字母个数\n          length(); 返回字母个数\n          empty(); 返回字符串是否为空\n          clear(); 把字符串清空\n\n  ```c++\n  string  a = \"sgl\";\n  \n  a += 'def';\n  \n  cout << a.substr( , ) << endl;\n  \n  // printf无法直接输出string，依靠string头指针来进行输出\n  printf(\"%s\\n\", a.c_str());\n  ```\n\n  \n\n* `queue`（队列）队尾插入队头弹出\n      定义：：\n          queue <类型> 变量名;\n      常用函数：：\n          size(); 这个队列的长度\n          empty(); 返回这个队列是否为空\n          push(); 往队尾插入一个元素\n          front(); 返回队头元素\n          back(); 返回队尾元素\n          pop(); 把队头弹出\n          注意：队列没有clear函数！！！\n      清空queue：     \n\n  ``` \n  变量名 = queue <int> ();\n  ```\n\n  \n\n* `priority_queue`（优先队列，是一个堆）\n      注意：默认是大根堆！！！\n      定义：：\n\n  ```c++\n          大根堆：priority_queue <类型> 变量名;\n          小根堆：priority_queue <类型,vecotr <类型>,greater <类型>> 变量名\n  ```\n\n  ​    常用函数：\n  ​        size(); 这个堆的长度\n  ​        empty(); 返回这个堆是否为空\n  ​        push();往堆里插入一个元素\n  ​        top(); 返回堆顶元素\n  ​        pop(); 弹出堆顶元素\n  ​        注意：堆没有clear函数！！！\n\n`stack`（栈）\n    常用函数：\n        size(); 这个栈的长度\n        empty(); 返回这个栈是否为空\n        push(); 向栈顶插入一个元素\n        top(); 返回栈顶元素\n        pop(); 弹出栈顶元素\n\n`deque`（双端队列）队头队尾都可以插入删除，支持随机访问\n    常用函数：\n        size(); 这个双端队列的长度\n        empty(); 返回这个双端队列是否为空\n        clear(); 清空这个双端队列\n        front(); 返回第一个元素\n        back(); 返回最后一个元素\n        push_back(); 向最后插入一个元素\n        pop_back(); 弹出最后一个元素\n        push_front(); 向队首插入一个元素\n        pop_front(); 弹出第一个元素\n        begin(); 双端队列的第0个数\n        end(); 双端队列的最后一个的数的后面一个数\n\n​\t\t[] 类似数组\n\n`set`，`map`，`multiset`，`multimap` 基于平衡二叉树（红黑树：一种平衡二叉树），动态维护**有序序列**\n    `set/multiset`\n        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！\n        常用函数：\n            size(); 返回元素个数\n            empty(); 返回set是否是空的\n            clear(); 清空\n            begin(); 第0个数，支持++或--，返回前驱和后继\n            end(); 最后一个的数的后面一个数，支持++或--，返回前驱和后继\n            insert(); 插入一个数\n            find(); 查找一个数\n            count(); 返回某一个数的个数\n            erase();\n                （1）输入是一个数x，删除所有x    O(k + log n)      k是x的个数\n                （2）输入一个迭代器，删除这个迭代器\n            lower_bound(x); 返回大于等于x的最小的数的迭代器\n            upper_bound(x); 返回大于x的最小的数的迭代器\n    `map/multimap`  类似python字典\n        常用函数：\n            insert(); 插入一个数，插入的数是一个pair\n            erase(); \n                （1）输入是pair\n                （2）输入一个迭代器，删除这个迭代器\n            find(); 查找一个数\n            lower_bound(x); 返回大于等于x的最小的数的迭代器\n            upper_bound(x); 返回大于x的最小的数的迭代器\n\n​\t\t\t[] 数组类似，但是是O(logn) 增删改查都是O(logn)\n\n`unordered_set`，`unordered_map`，`unordered_muliset`, `unordered_multimap` 基于哈希表实现\n    和上面类似，增删改查的时间复杂度是O(1)\n    不支持lower_bound()和upper_bound()，迭代器++--；；；；；；凡是和排序有关的操作都不支持\n\n`bitset` 压位\n\n​\t可以将一字节的大小存储在1bit中，即可以把内存大小减少为原来的1/8\n\n​    定义：\n​        bitset <个数> 变量名;\n​    支持：\n​        ~，&，|，^\n​        >>，<<\n​        ==，!=\n​        []\n​    常用函数：\n​        count(); 返回有多少个1\n​        any(); 判断是否至少有一个1\n​        none(); 判断是否全为0\n​        set(); 把所有位置赋值为1\n​        set(k,v); 将第k位变成v\n​        reset(); 把所有位变成0\n​        flip(); 把所有位取反，等价于~\n​        flip(k); 把第k位取反\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 蓝桥杯\n\n\n\n**题目描述** ---- >>  **抽象出具体模型**\n\n\n\n检查程序  ①正确性 ②时间复杂度 ③\n\n\n\nC++ 评测机 1s内可以运行一亿次（10^8）\n\n也就是说一个算法时间复杂度要不超过10^7为最佳，可以在1s内算出来\n\n超时：时间复杂度超过10^8\n\n根据数据量的范围来确定用什么算法\n\n\n\n2^20 ------ 10 ^ 6\n\n2^15 ------- 32768\n\n2^16 -------- 65536\n\n\n\n\n\n递归\n\n①手绘搜索树\n\n### ②将搜索树转化为代码（若是dfs，考虑dfs中传入的参数）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 机试\n\n\n\n## 成绩排序\n\n\n\n\n\n\n\n\n\n## 进制转换\n\n#### 其他进制转十进制\n\n秦九韶算法\n$$\n((a_{k-1}k+a_{k-2})k+a_{k-3})k+a_{k-4}\n$$\n\n\n#### 十进制转其他进制\n\n短除法\n\n\n\n#### 其他进制转其他进制\n\n短除法\n\n\n\n\n\n","tags":["algorithm"],"categories":["algorithm"]}]