
<!DOCTYPE html>

<html class="no-js" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="Sun" name="author"/>
<link href="https://sun-gliang.github.io/CS-Skills/tools/Algorithm/" rel="canonical"/>
<link href="../Linux/" rel="prev"/>
<link href="../../../Project/" rel="next"/>
<link href="../../../_assets/brownCircle-removebg-preview.png" rel="icon"/>
<meta content="mkdocs-1.6.0, mkdocs-material-9.5.30" name="generator"/>
<title>算法总结 - Sun's NoteBook</title>
<link href="../../../assets/stylesheets/main.3cba04c6.min.css" rel="stylesheet"/>
<link href="../../../assets/stylesheets/palette.06af60db.min.css" rel="stylesheet"/>
<style>:root{--md-admonition-icon--info:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M320 96a32 32 0 1 1-64 0 32 32 0 1 1 64 0zm21.1 80C367 158.8 384 129.4 384 96c0-53-43-96-96-96s-96 43-96 96c0 33.4 17 62.8 42.9 80H224c-17.7 0-32 14.3-32 32s14.3 32 32 32h32v208h-48c-53 0-96-43-96-96v-6.1l7 7c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9L97 263c-9.4-9.4-24.6-9.4-33.9 0L7 319c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l7-7v6.1c0 88.4 71.6 160 160 160h160c88.4 0 160-71.6 160-160v-6.1l7 7c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-56-56c-9.4-9.4-24.6-9.4-33.9 0l-56 56c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l7-7v6.1c0 53-43 96-96 96h-48V240h32c17.7 0 32-14.3 32-32s-14.3-32-32-32h-10.9z"/></svg>');--md-admonition-icon--note:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="m368.4 18.3-55.7 55.8 125.2 125.2 55.7-55.7c21.9-21.9 21.9-57.3 0-79.2l-46-46.1c-21.9-21.9-57.3-21.9-79.2 0zM288 94.6l-9.2 2.8-144.1 43.2c-19.9 6-35.7 21.2-42.3 41L3.8 445.8c-3.8 11.3-1 23.9 7.3 32.4l153.6-153.5c-3-6.3-4.7-13.3-4.7-20.7 0-26.5 21.5-48 48-48s48 21.5 48 48-21.5 48-48 48c-7.4 0-14.4-1.7-20.7-4.7L33.7 500.9c8.6 8.3 21.1 11.2 32.4 7.3l264.3-88.6c19.7-6.6 35-22.4 41-42.3l43.2-144.1 2.7-9.2L288 94.6z"/></svg>');--md-admonition-icon--abstract:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M40 48c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24V72c0-13.3-10.7-24-24-24H40zm152 16c-17.7 0-32 14.3-32 32s14.3 32 32 32h288c17.7 0 32-14.3 32-32s-14.3-32-32-32H192zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32h288c17.7 0 32-14.3 32-32s-14.3-32-32-32H192zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32h288c17.7 0 32-14.3 32-32s-14.3-32-32-32H192zM16 232v48c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24v-48c0-13.3-10.7-24-24-24H40c-13.3 0-24 10.7-24 24zm24 136c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h48c13.3 0 24-10.7 24-24v-48c0-13.3-10.7-24-24-24H40z"/></svg>');--md-admonition-icon--tip:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M272 384c9.6-31.9 29.5-59.1 49.2-86.2 5.2-7.1 10.4-14.2 15.4-21.4 19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3 5 7.2 10.2 14.3 15.4 21.4 19.8 27.1 39.7 54.4 49.2 86.2h160zm-80 128c44.2 0 80-35.8 80-80v-16H112v16c0 44.2 35.8 80 80 80zm-80-336c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112 8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"/></svg>');--md-admonition-icon--success:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7l233.4-233.3c12.5-12.5 32.8-12.5 45.3 0z"/></svg>');--md-admonition-icon--question:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zm-86.2-346.7c7.9-22.3 29.1-37.3 52.8-37.3h58.3c34.9 0 63.1 28.3 63.1 63.1 0 22.6-12.1 43.5-31.7 54.8L280 264.4c-.2 13-10.9 23.6-24 23.6-13.3 0-24-10.7-24-24v-13.5c0-8.6 4.6-16.5 12.1-20.8l44.3-25.4c4.7-2.7 7.6-7.7 7.6-13.1 0-8.4-6.8-15.1-15.1-15.1h-58.3c-3.4 0-6.4 2.1-7.5 5.3l-.4 1.2c-4.4 12.5-18.2 19-30.6 14.6s-19-18.2-14.6-30.6l.4-1.2zM224 352a32 32 0 1 1 64 0 32 32 0 1 1-64 0z"/></svg>');--md-admonition-icon--warning:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7.2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8.2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24v112c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0-64 0 32 32 0 1 0 64 0z"/></svg>');--md-admonition-icon--failure:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3c4.97 0 9 3.58 9 8s-6 10-9 10-9-5.58-9-10 4.03-8 9-8m-1.69 7.93C9.29 9.29 7.47 8.58 6.25 9.34c-1.22.76-1.38 2.71-.36 4.35 1.03 1.64 2.85 2.35 4.07 1.59 1.22-.78 1.37-2.71.35-4.35m3.38 0c-1.02 1.64-.87 3.57.35 4.35 1.22.76 3.04.05 4.07-1.59 1.02-1.64.86-3.59-.36-4.35-1.22-.76-3.04-.05-4.06 1.59M12 17.75c-2 0-2.5-.75-2.5-.75 0 .03.5 2 2.5 2s2.5-2 2.5-2-.5.75-2.5.75Z"/></svg>');--md-admonition-icon--danger:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32v11.5c0 49.9-60.3 74.9-95.6 39.6l-8.2-8.1C107.7 62.5 87.5 62.5 75 75s-12.5 32.8 0 45.3l8.2 8.2c35.2 35.2 10.2 95.5-39.7 95.5H32c-17.7 0-32 14.3-32 32s14.3 32 32 32h11.5c49.9 0 74.9 60.3 39.6 95.6l-8.1 8.2c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l8.2-8.2c35.3-35.3 95.6-10.3 95.6 39.6V480c0 17.7 14.3 32 32 32s32-14.3 32-32v-11.5c0-49.9 60.3-74.9 95.6-39.6l8.2 8.2c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-8.2-8.2c-35.3-35.3-10.3-95.6 39.6-95.6h11.5c17.7 0 32-14.3 32-32s-14.3-32-32-32h-11.5c-49.9 0-74.9-60.3-39.6-95.6l8.2-8.2c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-8.2 8.2C348.3 118.4 288 93.4 288 43.5V32zM176 224a48 48 0 1 1 96 0 48 48 0 1 1-96 0zm128 56a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"/></svg>');--md-admonition-icon--bug:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M320 0c17.7 0 32 14.3 32 32v64h120c39.8 0 72 32.2 72 72v272c0 39.8-32.2 72-72 72H168c-39.8 0-72-32.2-72-72V168c0-39.8 32.2-72 72-72h120V32c0-17.7 14.3-32 32-32zM208 384c-8.8 0-16 7.2-16 16s7.2 16 16 16h32c8.8 0 16-7.2 16-16s-7.2-16-16-16h-32zm96 0c-8.8 0-16 7.2-16 16s7.2 16 16 16h32c8.8 0 16-7.2 16-16s-7.2-16-16-16h-32zm96 0c-8.8 0-16 7.2-16 16s7.2 16 16 16h32c8.8 0 16-7.2 16-16s-7.2-16-16-16h-32zM264 256a40 40 0 1 0-80 0 40 40 0 1 0 80 0zm152 40a40 40 0 1 0 0-80 40 40 0 1 0 0 80zM48 224h16v192H48c-26.5 0-48-21.5-48-48v-96c0-26.5 21.5-48 48-48zm544 0c26.5 0 48 21.5 48 48v96c0 26.5-21.5 48-48 48h-16V224h16z"/></svg>');--md-admonition-icon--example:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M288 0H128c-17.7 0-32 14.3-32 32s14.3 32 32 32v132.8c0 11.8-3.3 23.5-9.5 33.5L10.3 406.2C3.6 417.2 0 429.7 0 442.6 0 480.9 31.1 512 69.4 512h309.2c38.3 0 69.4-31.1 69.4-69.4 0-12.8-3.6-25.4-10.3-36.4L329.5 230.4c-6.2-10.1-9.5-21.7-9.5-33.5V64c17.7 0 32-14.3 32-32S337.7 0 320 0h-32zm-96 196.8V64h64v132.8c0 23.7 6.6 46.9 19 67.1l34.5 56.1h-171l34.5-56.1c12.4-20.2 19-43.4 19-67.1z"/></svg>');--md-admonition-icon--quote:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M579.8 267.7c56.5-56.5 56.5-148 0-204.5-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6 31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0l112.3-112.3zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5 50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5l112.2-112.3c31.5-31.5 82.5-31.5 114 0 27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z"/></svg>');}</style>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=LXGW+WenKai+Screen+GB+Screen:300,300i,400,400i,700,700i%7CJetBrains+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"LXGW WenKai Screen GB Screen";--md-code-font:"JetBrains Mono"}</style>
<link href="../../../_css/extra.css" rel="stylesheet"/>
<link href="../../../_css/flink.css" rel="stylesheet"/>
<link href="https://jsd.cdn.zzko.cn/npm/katex@0.16.4/dist/katex.min.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" rel="stylesheet"/>
<script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
<link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
            html.glightbox-open { overflow: initial; height: 100%; }
            .gslide-title { margin-top: 0px; user-select: text; }
            .gslide-desc { color: #666; user-select: text; }
            .gslide-image img { background: white; }
            
                .gscrollbar-fixer { padding-right: 15px; }
                .gdesc-inner { font-size: 0.75rem; }
                body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
                body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
                body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
                </style><script src="../../../assets/javascripts/glightbox.min.js"></script></head>
<body data-md-color-accent="deep-orange" data-md-color-primary="brown" data-md-color-scheme="default" dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#算法总结">
          跳转至
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="页眉" class="md-header__inner md-grid">
<a aria-label="Sun's NoteBook" class="md-header__button md-logo" data-md-component="logo" href="../../.." title="Sun's NoteBook">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M23.561 11.988C23.301-.304 6.954-4.89.656 6.634c.282.206.661.477.943.672a11.747 11.747 0 0 0-.976 3.067 11.885 11.885 0 0 0-.184 2.071C.439 18.818 5.621 24 12.005 24c6.385 0 11.556-5.17 11.556-11.556v-.455zm-20.27 2.06c-.152 1.246-.054 1.636-.054 1.788l-.282.098c-.108-.206-.37-.932-.488-1.908C2.163 10.308 4.7 6.96 8.57 6.33c3.544-.52 6.937 1.68 7.728 4.758l-.282.098c-.087-.087-.228-.336-.77-.878-4.281-4.281-11.002-2.32-11.956 3.74zm11.002 2.081a3.145 3.145 0 0 1-2.59 1.355 3.15 3.15 0 0 1-3.155-3.155 3.159 3.159 0 0 1 2.927-3.144c1.018-.043 1.972.51 2.416 1.398a2.58 2.58 0 0 1-.455 2.95c.293.205.575.4.856.595zm6.58.12c-1.669 3.782-5.106 5.766-8.77 5.712-7.034-.347-9.083-8.466-4.38-11.393l.207.206c-.076.108-.358.325-.791 1.182-.51 1.041-.672 2.081-.607 2.732.369 5.67 8.314 6.83 11.045 1.214C21.057 8.217 11.822.401 3.626 6.374l-.184-.184C5.599 2.808 9.816 1.3 13.837 2.309c6.147 1.55 9.453 7.956 7.035 13.94z"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            Sun's NoteBook
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              算法总结
            
          </span>
</div>
</div>
</div>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="搜索" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="搜索" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"></path></svg>
</label>
<nav aria-label="查找" class="md-search__options">
<a aria-label="分享" class="md-search__icon md-icon" data-clipboard="" data-clipboard-text="" data-md-component="search-share" href="javascript:void(0)" tabindex="-1" title="分享">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"></path></svg>
</a>
<button aria-label="清空当前内容" class="md-search__icon md-icon" tabindex="-1" title="清空当前内容" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="标签" class="md-tabs" data-md-component="tabs">
<div class="md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../..">
          
  
    
  
  🌐 主页

        </a>
</li>
<li class="md-tabs__item md-tabs__item--active">
<a class="md-tabs__link" href="../../">
          
  
    
  
  🎯 技术积累

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../Project/">
          
  
    
  
  🚩 项目进展

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../Reading/">
          
  
    
  
  📖 阅读记录

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../%E8%80%83%E7%A0%94%E4%B8%93%E9%A1%B9/">
          
  
    
  
  📜 考研专项

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../WebLink/">
          
  
    
  
  🚀 网站仓库

        </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="导航栏" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="Sun's NoteBook" class="md-nav__button md-logo" data-md-component="logo" href="../../.." title="Sun's NoteBook">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M23.561 11.988C23.301-.304 6.954-4.89.656 6.634c.282.206.661.477.943.672a11.747 11.747 0 0 0-.976 3.067 11.885 11.885 0 0 0-.184 2.071C.439 18.818 5.621 24 12.005 24c6.385 0 11.556-5.17 11.556-11.556v-.455zm-20.27 2.06c-.152 1.246-.054 1.636-.054 1.788l-.282.098c-.108-.206-.37-.932-.488-1.908C2.163 10.308 4.7 6.96 8.57 6.33c3.544-.52 6.937 1.68 7.728 4.758l-.282.098c-.087-.087-.228-.336-.77-.878-4.281-4.281-11.002-2.32-11.956 3.74zm11.002 2.081a3.145 3.145 0 0 1-2.59 1.355 3.15 3.15 0 0 1-3.155-3.155 3.159 3.159 0 0 1 2.927-3.144c1.018-.043 1.972.51 2.416 1.398a2.58 2.58 0 0 1-.455 2.95c.293.205.575.4.856.595zm6.58.12c-1.669 3.782-5.106 5.766-8.77 5.712-7.034-.347-9.083-8.466-4.38-11.393l.207.206c-.076.108-.358.325-.791 1.182-.51 1.041-.672 2.081-.607 2.732.369 5.67 8.314 6.83 11.045 1.214C21.057 8.217 11.822.401 3.626 6.374l-.184-.184C5.599 2.808 9.816 1.3 13.837 2.309c6.147 1.55 9.453 7.956 7.035 13.94z"></path></svg>
</a>
    Sun's NoteBook
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_1" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../..">
<span class="md-ellipsis">
    🌐 主页
  </span>
</a>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_1_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_1">
<span class="md-nav__icon md-icon"></span>
            🌐 主页
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_2" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../">
<span class="md-ellipsis">
    🎯 技术积累
  </span>
</a>
<label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="true" aria-labelledby="__nav_2_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
            🎯 技术积累
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2_2" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../LeetCodeRecord/">
<span class="md-ellipsis">
    LeetCode刷题
  </span>
</a>
<label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_2_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_2">
<span class="md-nav__icon md-icon"></span>
            LeetCode刷题
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2_2_2" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../LeetCodeRecord/%E4%BA%8C%E5%88%86/">
<span class="md-ellipsis">
    二分
  </span>
</a>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_2_2_2_label" class="md-nav" data-md-level="3">
<label class="md-nav__title" for="__nav_2_2_2">
<span class="md-nav__icon md-icon"></span>
            二分
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../Linux/">
<span class="md-ellipsis">
    Linux命令总结
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
<span class="md-ellipsis">
    算法总结
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
<span class="md-ellipsis">
    算法总结
  </span>
</a>
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      目录
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#基础算法">
<span class="md-ellipsis">
      基础算法
    </span>
</a>
<nav aria-label="基础算法" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-快速排序">
<span class="md-ellipsis">
      1. 快速排序
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-快速选择">
<span class="md-ellipsis">
      2. 快速选择
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-归并排序">
<span class="md-ellipsis">
      3. 归并排序
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-二分">
<span class="md-ellipsis">
      4. 二分
    </span>
</a>
<nav aria-label="4. 二分" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#41-整数二分">
<span class="md-ellipsis">
      4.1 整数二分
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#42-浮点数二分">
<span class="md-ellipsis">
      4.2 浮点数二分
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#5-高精度">
<span class="md-ellipsis">
      5. 高精度
    </span>
</a>
<nav aria-label="5. 高精度" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#51-高精度相加">
<span class="md-ellipsis">
      5.1 高精度相加
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#52-高精度相减">
<span class="md-ellipsis">
      5.2 高精度相减
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#53-高精度乘法">
<span class="md-ellipsis">
      5.3 高精度乘法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#54-高精度除法">
<span class="md-ellipsis">
      5.4 高精度除法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#55-大整数">
<span class="md-ellipsis">
      5.5 大整数
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#6-前缀和">
<span class="md-ellipsis">
      6. 前缀和
    </span>
</a>
<nav aria-label="6. 前缀和" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#61-一维前缀和">
<span class="md-ellipsis">
      6.1 一维前缀和
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#62-二维前缀和">
<span class="md-ellipsis">
      6.2 二维前缀和
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#7-差分">
<span class="md-ellipsis">
      7. 差分
    </span>
</a>
<nav aria-label="7. 差分" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#71-一维差分">
<span class="md-ellipsis">
      7.1 一维差分
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#72-二维差分">
<span class="md-ellipsis">
      7.2 二维差分
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#8-双指针算法">
<span class="md-ellipsis">
      8. 双指针算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#9位运算">
<span class="md-ellipsis">
      9.位运算
    </span>
</a>
<nav aria-label="9.位运算" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#91-n的二进制表示中第k位是几个位是第0位依次">
<span class="md-ellipsis">
      9.1 n的二进制表示中第k位是几（个位是第0位，依次）
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#92-lobitx">
<span class="md-ellipsis">
      9.2 lobit(x)
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#10-离散化">
<span class="md-ellipsis">
      10. 离散化
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#11区间合并">
<span class="md-ellipsis">
      11.区间合并
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#数据结构">
<span class="md-ellipsis">
      数据结构
    </span>
</a>
<nav aria-label="数据结构" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-链表">
<span class="md-ellipsis">
      1. 链表
    </span>
</a>
<nav aria-label="1. 链表" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#11-单链表">
<span class="md-ellipsis">
      1.1 单链表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#12-双链表">
<span class="md-ellipsis">
      1.2 双链表
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-栈">
<span class="md-ellipsis">
      2. 栈
    </span>
</a>
<nav aria-label="2. 栈" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#单调栈应用">
<span class="md-ellipsis">
      单调栈应用
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-队列">
<span class="md-ellipsis">
      3. 队列
    </span>
</a>
<nav aria-label="3. 队列" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#单调队列">
<span class="md-ellipsis">
      单调队列
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-kmp">
<span class="md-ellipsis">
      4. KMP
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#5-trie">
<span class="md-ellipsis">
      5. Trie
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#6-并查集">
<span class="md-ellipsis">
      6. 并查集
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#7-堆">
<span class="md-ellipsis">
      7. 堆
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#8-hash">
<span class="md-ellipsis">
      8. Hash
    </span>
</a>
<nav aria-label="8. Hash" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#81-哈希表的存储结构">
<span class="md-ellipsis">
      8.1 哈希表的存储结构
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#82-开放寻址法">
<span class="md-ellipsis">
      8.2 开放寻址法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#83-拉链法">
<span class="md-ellipsis">
      8.3 拉链法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#84-字符串前缀哈希法">
<span class="md-ellipsis">
      8.4 字符串前缀哈希法
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#搜索与图论">
<span class="md-ellipsis">
      搜索与图论
    </span>
</a>
<nav aria-label="搜索与图论" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-dfs">
<span class="md-ellipsis">
      1. DFS
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-bfs">
<span class="md-ellipsis">
      2. BFS
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-树和图的存储">
<span class="md-ellipsis">
      3. 树和图的存储
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-树和图的遍历">
<span class="md-ellipsis">
      4. 树和图的遍历
    </span>
</a>
<nav aria-label="4. 树和图的遍历" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#深度优先遍历">
<span class="md-ellipsis">
      深度优先遍历
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#广度优先遍历">
<span class="md-ellipsis">
      广度优先遍历
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#5-拓扑序列">
<span class="md-ellipsis">
      5. 拓扑序列
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#6-最短路">
<span class="md-ellipsis">
      6. 最短路
    </span>
</a>
<nav aria-label="6. 最短路" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#61-朴素dijkstra算法">
<span class="md-ellipsis">
      6.1 朴素Dijkstra算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#62-堆优化版dijkstra算法">
<span class="md-ellipsis">
      6.2 堆优化版Dijkstra算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#63-bellman-ford算法">
<span class="md-ellipsis">
      6.3 Bellman-Ford算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#64-spfa">
<span class="md-ellipsis">
      6.4 SPFA
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#65-floyd">
<span class="md-ellipsis">
      6.5 Floyd
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#7-最小生成树">
<span class="md-ellipsis">
      7. 最小生成树
    </span>
</a>
<nav aria-label="7. 最小生成树" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#71-朴素版prim算法">
<span class="md-ellipsis">
      7.1 朴素版Prim算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#72-kruskal算法">
<span class="md-ellipsis">
      7.2 Kruskal算法
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#8-二分图">
<span class="md-ellipsis">
      8. 二分图
    </span>
</a>
<nav aria-label="8. 二分图" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#81-染色法">
<span class="md-ellipsis">
      8.1 染色法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#82-匈牙利算法ntr算法bushi">
<span class="md-ellipsis">
      8.2 匈牙利算法[NTR算法bushi]
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#数学知识">
<span class="md-ellipsis">
      数学知识
    </span>
</a>
<nav aria-label="数学知识" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-数论">
<span class="md-ellipsis">
      1. 数论
    </span>
</a>
<nav aria-label="1. 数论" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#11-质数">
<span class="md-ellipsis">
      1.1 质数
    </span>
</a>
<nav aria-label="1.1 质数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#111-质数的判定----试除法">
<span class="md-ellipsis">
      1.1.1 质数的判定----试除法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#112-分解质因数----试除法">
<span class="md-ellipsis">
      1.1.2 分解质因数----试除法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#113-筛质数">
<span class="md-ellipsis">
      1.1.3 筛质数
    </span>
</a>
<nav aria-label="1.1.3 筛质数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1131-朴素筛法">
<span class="md-ellipsis">
      1.1.3.1 朴素筛法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#1132-埃氏筛法">
<span class="md-ellipsis">
      1.1.3.2 埃氏筛法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#1133-线性筛法">
<span class="md-ellipsis">
      1.1.3.3 线性筛法
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#12-约数">
<span class="md-ellipsis">
      1.2. 约数
    </span>
</a>
<nav aria-label="1.2. 约数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#121-试除法求一个数的所有约数">
<span class="md-ellipsis">
      1.2.1 试除法求一个数的所有约数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#122-约数个数">
<span class="md-ellipsis">
      1.2.2 约数个数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#123-约数之和">
<span class="md-ellipsis">
      1.2.3 约数之和
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#13-欧几里得算法辗转相除法">
<span class="md-ellipsis">
      1.3. 欧几里得算法/辗转相除法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#14-欧拉函数">
<span class="md-ellipsis">
      1.4. 欧拉函数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#15-快速幂">
<span class="md-ellipsis">
      1.5. 快速幂
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#16-扩展欧几里得算法">
<span class="md-ellipsis">
      1.6. 扩展欧几里得算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#17-中国剩余定理">
<span class="md-ellipsis">
      1.7. 中国剩余定理
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-组合计数">
<span class="md-ellipsis">
      2. 组合计数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-高斯消元">
<span class="md-ellipsis">
      3. 高斯消元
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-简单博弈论">
<span class="md-ellipsis">
      4. 简单博弈论
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#dp">
<span class="md-ellipsis">
      DP
    </span>
</a>
<nav aria-label="DP" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-背包问题">
<span class="md-ellipsis">
      1. 背包问题
    </span>
</a>
<nav aria-label="1. 背包问题" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#11-0-1背包问题">
<span class="md-ellipsis">
      1.1 0-1背包问题
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#12-完全背包问题">
<span class="md-ellipsis">
      1.2 完全背包问题
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#13-多重背包问题">
<span class="md-ellipsis">
      1.3 多重背包问题
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#14-分组背包问题">
<span class="md-ellipsis">
      1.4 分组背包问题
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-线性dp">
<span class="md-ellipsis">
      2. 线性Dp
    </span>
</a>
<nav aria-label="2. 线性Dp" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#21-数字三角形">
<span class="md-ellipsis">
      2.1 数字三角形
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#22-最长上升子序列">
<span class="md-ellipsis">
      2.2 最长上升子序列
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#23-最长公共子序列">
<span class="md-ellipsis">
      2.3 最长公共子序列
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#24-区间dp">
<span class="md-ellipsis">
      2.4 区间Dp
    </span>
</a>
<nav aria-label="2.4 区间Dp" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#241-石子划分">
<span class="md-ellipsis">
      2.4.1 石子划分
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#note">
<span class="md-ellipsis">
      NOTE
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#stl">
<span class="md-ellipsis">
      STL
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../../Project/">
<span class="md-ellipsis">
    🚩 项目进展
  </span>
</a>
<label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
            🚩 项目进展
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3_2" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../../Project/%E7%B1%BBUnix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
<span class="md-ellipsis">
    类Unix操作系统
  </span>
</a>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_2">
<span class="md-nav__icon md-icon"></span>
            类Unix操作系统
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3_3" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../../Project/AI%E8%B4%AA%E5%90%83%E8%9B%87/">
<span class="md-ellipsis">
    AI贪吃蛇对战平台
  </span>
</a>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_3_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_3">
<span class="md-nav__icon md-icon"></span>
            AI贪吃蛇对战平台
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_4" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../../Reading/">
<span class="md-ellipsis">
    📖 阅读记录
  </span>
</a>
<label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_4_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
            📖 阅读记录
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_4_2" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../../Reading/%E6%96%87%E5%AD%A6%E8%91%97%E4%BD%9C/">
<span class="md-ellipsis">
    文学著作
  </span>
</a>
<label class="md-nav__link" for="__nav_4_2" id="__nav_4_2_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_4_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_2">
<span class="md-nav__icon md-icon"></span>
            文学著作
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Reading/%E6%96%87%E5%AD%A6%E8%91%97%E4%BD%9C/%E4%BA%BA%E7%94%9F%E6%B5%B7%E6%B5%B7/">
<span class="md-ellipsis">
    人生海海
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_4_3" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../../Reading/%E4%BA%BA%E6%96%87%E7%A4%BE%E7%A7%91/">
<span class="md-ellipsis">
    人文社科
  </span>
</a>
<label class="md-nav__link" for="__nav_4_3" id="__nav_4_3_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_4_3_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_3">
<span class="md-nav__icon md-icon"></span>
            人文社科
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Reading/%E4%BA%BA%E6%96%87%E7%A4%BE%E7%A7%91/%E7%A6%8F%E6%A0%BC%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%9E%8B/">
<span class="md-ellipsis">
    福格行为模型
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Reading/%E4%BA%BA%E6%96%87%E7%A4%BE%E7%A7%91/%E6%B4%9E%E5%AF%9F%E4%BA%BA%E6%80%A7/">
<span class="md-ellipsis">
    洞察人性
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../Reading/%E7%BB%8F%E9%AA%8C%E8%B7%AF%E7%BA%BF/">
<span class="md-ellipsis">
    经验路线
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_5" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../../%E8%80%83%E7%A0%94%E4%B8%93%E9%A1%B9/">
<span class="md-ellipsis">
    📜 考研专项
  </span>
</a>
<label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_5_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
            📜 考研专项
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_5_2" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../../%E8%80%83%E7%A0%94%E4%B8%93%E9%A1%B9/408/">
<span class="md-ellipsis">
    408
  </span>
</a>
<label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_5_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_5_2">
<span class="md-nav__icon md-icon"></span>
            408
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../%E8%80%83%E7%A0%94%E4%B8%93%E9%A1%B9/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">
<span class="md-ellipsis">
    计算机组成原理
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../%E8%80%83%E7%A0%94%E4%B8%93%E9%A1%B9/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
<span class="md-ellipsis">
    Index
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../%E8%80%83%E7%A0%94%E4%B8%93%E9%A1%B9/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
<span class="md-ellipsis">
    计算机网络
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../%E8%80%83%E7%A0%94%E4%B8%93%E9%A1%B9/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
<span class="md-ellipsis">
    数据结构
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_6" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../../WebLink/">
<span class="md-ellipsis">
    🚀 网站仓库
  </span>
</a>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_6_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
            🚀 网站仓库
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      目录
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#基础算法">
<span class="md-ellipsis">
      基础算法
    </span>
</a>
<nav aria-label="基础算法" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-快速排序">
<span class="md-ellipsis">
      1. 快速排序
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-快速选择">
<span class="md-ellipsis">
      2. 快速选择
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-归并排序">
<span class="md-ellipsis">
      3. 归并排序
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-二分">
<span class="md-ellipsis">
      4. 二分
    </span>
</a>
<nav aria-label="4. 二分" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#41-整数二分">
<span class="md-ellipsis">
      4.1 整数二分
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#42-浮点数二分">
<span class="md-ellipsis">
      4.2 浮点数二分
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#5-高精度">
<span class="md-ellipsis">
      5. 高精度
    </span>
</a>
<nav aria-label="5. 高精度" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#51-高精度相加">
<span class="md-ellipsis">
      5.1 高精度相加
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#52-高精度相减">
<span class="md-ellipsis">
      5.2 高精度相减
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#53-高精度乘法">
<span class="md-ellipsis">
      5.3 高精度乘法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#54-高精度除法">
<span class="md-ellipsis">
      5.4 高精度除法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#55-大整数">
<span class="md-ellipsis">
      5.5 大整数
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#6-前缀和">
<span class="md-ellipsis">
      6. 前缀和
    </span>
</a>
<nav aria-label="6. 前缀和" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#61-一维前缀和">
<span class="md-ellipsis">
      6.1 一维前缀和
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#62-二维前缀和">
<span class="md-ellipsis">
      6.2 二维前缀和
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#7-差分">
<span class="md-ellipsis">
      7. 差分
    </span>
</a>
<nav aria-label="7. 差分" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#71-一维差分">
<span class="md-ellipsis">
      7.1 一维差分
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#72-二维差分">
<span class="md-ellipsis">
      7.2 二维差分
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#8-双指针算法">
<span class="md-ellipsis">
      8. 双指针算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#9位运算">
<span class="md-ellipsis">
      9.位运算
    </span>
</a>
<nav aria-label="9.位运算" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#91-n的二进制表示中第k位是几个位是第0位依次">
<span class="md-ellipsis">
      9.1 n的二进制表示中第k位是几（个位是第0位，依次）
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#92-lobitx">
<span class="md-ellipsis">
      9.2 lobit(x)
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#10-离散化">
<span class="md-ellipsis">
      10. 离散化
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#11区间合并">
<span class="md-ellipsis">
      11.区间合并
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#数据结构">
<span class="md-ellipsis">
      数据结构
    </span>
</a>
<nav aria-label="数据结构" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-链表">
<span class="md-ellipsis">
      1. 链表
    </span>
</a>
<nav aria-label="1. 链表" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#11-单链表">
<span class="md-ellipsis">
      1.1 单链表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#12-双链表">
<span class="md-ellipsis">
      1.2 双链表
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-栈">
<span class="md-ellipsis">
      2. 栈
    </span>
</a>
<nav aria-label="2. 栈" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#单调栈应用">
<span class="md-ellipsis">
      单调栈应用
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-队列">
<span class="md-ellipsis">
      3. 队列
    </span>
</a>
<nav aria-label="3. 队列" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#单调队列">
<span class="md-ellipsis">
      单调队列
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-kmp">
<span class="md-ellipsis">
      4. KMP
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#5-trie">
<span class="md-ellipsis">
      5. Trie
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#6-并查集">
<span class="md-ellipsis">
      6. 并查集
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#7-堆">
<span class="md-ellipsis">
      7. 堆
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#8-hash">
<span class="md-ellipsis">
      8. Hash
    </span>
</a>
<nav aria-label="8. Hash" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#81-哈希表的存储结构">
<span class="md-ellipsis">
      8.1 哈希表的存储结构
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#82-开放寻址法">
<span class="md-ellipsis">
      8.2 开放寻址法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#83-拉链法">
<span class="md-ellipsis">
      8.3 拉链法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#84-字符串前缀哈希法">
<span class="md-ellipsis">
      8.4 字符串前缀哈希法
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#搜索与图论">
<span class="md-ellipsis">
      搜索与图论
    </span>
</a>
<nav aria-label="搜索与图论" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-dfs">
<span class="md-ellipsis">
      1. DFS
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-bfs">
<span class="md-ellipsis">
      2. BFS
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-树和图的存储">
<span class="md-ellipsis">
      3. 树和图的存储
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-树和图的遍历">
<span class="md-ellipsis">
      4. 树和图的遍历
    </span>
</a>
<nav aria-label="4. 树和图的遍历" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#深度优先遍历">
<span class="md-ellipsis">
      深度优先遍历
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#广度优先遍历">
<span class="md-ellipsis">
      广度优先遍历
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#5-拓扑序列">
<span class="md-ellipsis">
      5. 拓扑序列
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#6-最短路">
<span class="md-ellipsis">
      6. 最短路
    </span>
</a>
<nav aria-label="6. 最短路" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#61-朴素dijkstra算法">
<span class="md-ellipsis">
      6.1 朴素Dijkstra算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#62-堆优化版dijkstra算法">
<span class="md-ellipsis">
      6.2 堆优化版Dijkstra算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#63-bellman-ford算法">
<span class="md-ellipsis">
      6.3 Bellman-Ford算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#64-spfa">
<span class="md-ellipsis">
      6.4 SPFA
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#65-floyd">
<span class="md-ellipsis">
      6.5 Floyd
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#7-最小生成树">
<span class="md-ellipsis">
      7. 最小生成树
    </span>
</a>
<nav aria-label="7. 最小生成树" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#71-朴素版prim算法">
<span class="md-ellipsis">
      7.1 朴素版Prim算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#72-kruskal算法">
<span class="md-ellipsis">
      7.2 Kruskal算法
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#8-二分图">
<span class="md-ellipsis">
      8. 二分图
    </span>
</a>
<nav aria-label="8. 二分图" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#81-染色法">
<span class="md-ellipsis">
      8.1 染色法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#82-匈牙利算法ntr算法bushi">
<span class="md-ellipsis">
      8.2 匈牙利算法[NTR算法bushi]
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#数学知识">
<span class="md-ellipsis">
      数学知识
    </span>
</a>
<nav aria-label="数学知识" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-数论">
<span class="md-ellipsis">
      1. 数论
    </span>
</a>
<nav aria-label="1. 数论" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#11-质数">
<span class="md-ellipsis">
      1.1 质数
    </span>
</a>
<nav aria-label="1.1 质数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#111-质数的判定----试除法">
<span class="md-ellipsis">
      1.1.1 质数的判定----试除法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#112-分解质因数----试除法">
<span class="md-ellipsis">
      1.1.2 分解质因数----试除法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#113-筛质数">
<span class="md-ellipsis">
      1.1.3 筛质数
    </span>
</a>
<nav aria-label="1.1.3 筛质数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1131-朴素筛法">
<span class="md-ellipsis">
      1.1.3.1 朴素筛法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#1132-埃氏筛法">
<span class="md-ellipsis">
      1.1.3.2 埃氏筛法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#1133-线性筛法">
<span class="md-ellipsis">
      1.1.3.3 线性筛法
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#12-约数">
<span class="md-ellipsis">
      1.2. 约数
    </span>
</a>
<nav aria-label="1.2. 约数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#121-试除法求一个数的所有约数">
<span class="md-ellipsis">
      1.2.1 试除法求一个数的所有约数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#122-约数个数">
<span class="md-ellipsis">
      1.2.2 约数个数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#123-约数之和">
<span class="md-ellipsis">
      1.2.3 约数之和
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#13-欧几里得算法辗转相除法">
<span class="md-ellipsis">
      1.3. 欧几里得算法/辗转相除法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#14-欧拉函数">
<span class="md-ellipsis">
      1.4. 欧拉函数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#15-快速幂">
<span class="md-ellipsis">
      1.5. 快速幂
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#16-扩展欧几里得算法">
<span class="md-ellipsis">
      1.6. 扩展欧几里得算法
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#17-中国剩余定理">
<span class="md-ellipsis">
      1.7. 中国剩余定理
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-组合计数">
<span class="md-ellipsis">
      2. 组合计数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#3-高斯消元">
<span class="md-ellipsis">
      3. 高斯消元
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#4-简单博弈论">
<span class="md-ellipsis">
      4. 简单博弈论
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#dp">
<span class="md-ellipsis">
      DP
    </span>
</a>
<nav aria-label="DP" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1-背包问题">
<span class="md-ellipsis">
      1. 背包问题
    </span>
</a>
<nav aria-label="1. 背包问题" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#11-0-1背包问题">
<span class="md-ellipsis">
      1.1 0-1背包问题
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#12-完全背包问题">
<span class="md-ellipsis">
      1.2 完全背包问题
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#13-多重背包问题">
<span class="md-ellipsis">
      1.3 多重背包问题
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#14-分组背包问题">
<span class="md-ellipsis">
      1.4 分组背包问题
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#2-线性dp">
<span class="md-ellipsis">
      2. 线性Dp
    </span>
</a>
<nav aria-label="2. 线性Dp" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#21-数字三角形">
<span class="md-ellipsis">
      2.1 数字三角形
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#22-最长上升子序列">
<span class="md-ellipsis">
      2.2 最长上升子序列
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#23-最长公共子序列">
<span class="md-ellipsis">
      2.3 最长公共子序列
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#24-区间dp">
<span class="md-ellipsis">
      2.4 区间Dp
    </span>
</a>
<nav aria-label="2.4 区间Dp" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#241-石子划分">
<span class="md-ellipsis">
      2.4.1 石子划分
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#note">
<span class="md-ellipsis">
      NOTE
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#stl">
<span class="md-ellipsis">
      STL
    </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1 id="算法总结">算法总结<a class="headerlink" href="#算法总结" title="Permanent link">¶</a></h1>
<div style="margin-top: -30px; font-size: 0.75em; opacity: 0.7;">
<p><span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8V2m6.78 1a.69.69 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38-2.5-2.5Z"></path></svg></span> 约 7735 个字 <span class="twemoji"><svg viewbox="0 0 640 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3l89.3 89.4-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z"></path></svg></span> 706 行代码 <span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3L12.5 13Z"></path></svg></span> 预计阅读时间 48 分钟</p>
</div>
<h2 id="基础算法">基础算法<a class="headerlink" href="#基础算法" title="Permanent link">¶</a></h2>
<h3 id="1-快速排序">1. 快速排序<a class="headerlink" href="#1-快速排序" title="Permanent link">¶</a></h3>
<p><font color="#dd0000"><strong>平均为<span class="arithmatex">\(nlog_2 n\)</span> ，最坏为<span class="arithmatex">\(n^2\)</span>，分治思想</strong></font></p>
<ol>
<li>选择分界点<code>x</code> <br/>
<span class="arithmatex">\(x=q[l] 或 q[(l+r)/2] 或 q[r]\)</span> </li>
<li>调整区间       <strong>重难点</strong></li>
<li>递归处理左右两段</li>
</ol>
<p><strong>思想</strong>：通过设置两个指针i，j分别指向初始序列的两端
 i 和 j 相遇后只可能会出现  <code>i == j</code>   和   <code>i = j + 1</code>  两种情况</p>
<p><strong>注意  i = l - 1 ,   r = r + 1</strong></p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">"iostream"</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">quick_sort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// x 取q的中间值万能</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[(</span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 指针i 和 j 一旦相遇就结束</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w">  </span><span class="c1">// 注意是j--</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* </span>
<span class="cm">    注意若取j j+1，则x=q[*]，*不能取右边界 </span>
<span class="cm">    若取i-1 i，则x=q[*]，不能取左边界</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="n">quick_sort</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">    </span><span class="n">quick_sort</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    quick_sort(q, l, i - 1);</span>
<span class="cm">    quick_sort(q, i, r);</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">    </span><span class="n">quick_sort</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="2-快速选择">2. 快速选择<a class="headerlink" href="#2-快速选择" title="Permanent link">¶</a></h3>
<p><font color="#dd0000"><strong>O(n)</strong></font></p>
<p>与快速排序差不多，只是快速选择需要再输入一个 k 值，最后不用对左右两个区间递归，而只需要对左或右区间进行递归</p>
<p><a class="glightbox" data-desc-position="bottom" data-height="auto" data-width="100%" href="../images/image-20211213234826044.png"><img alt="" src="../images/image-20211213234826044.png"/></a>
<div class="highlight"><pre><span></span><code><span class="c1">// C++里面的函数参数与全局变量重名，优先使用局部变量</span>
</code></pre></div></p>
<h3 id="3-归并排序">3. 归并排序<a class="headerlink" href="#3-归并排序" title="Permanent link">¶</a></h3>
<p><font color="#dd0000"><strong>O(nlogn)，分治思想</strong></font></p>
<ol>
<li>确定分界点  x = (l + r) / 2</li>
<li>递归排序左右两端</li>
<li>对左右两端排序好的序列归并（合二为一） <strong>重难点</strong></li>
</ol>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">"iostream"</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e6</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="c1">// 因为q[N]已经是全局变量了， 所以函数参数有没有q无所谓 了</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">merge_sort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="n">merge_sort</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">);</span><span class="w"> </span><span class="n">merge_sort</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mid</span><span class="p">)</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">    </span><span class="n">merge_sort</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="4-二分">4. 二分<a class="headerlink" href="#4-二分" title="Permanent link">¶</a></h3>
<p><font color="#dd0000"><strong><u>用来查找</u></strong></font></p>
<h4 id="41-整数二分">4.1 整数二分<a class="headerlink" href="#41-整数二分" title="Permanent link">¶</a></h4>
<ul>
<li>二分的本质是找到一个<strong>性质</strong>，可以确定一个边界问题</li>
<li>有单调性一定可以二分， 而可以二分的不一定有单调性</li>
<li>求最值考虑一下二分</li>
</ul>
<p><font color="#FF00"><strong>板子</strong></font></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">bsearch_1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">bsearch_2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>while里面的模板直接使用，具体<code>check函数</code>根据题目来分析</li>
<li>二分一定是有解的；无解情况取决于题目性质</li>
<li>每次二分之后保证答案在所选区间内部</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// 找到第一个大于等于 x 的位置</span>
<span class="c1">// 可以这么思考：数轴上有若干个连续分布着的 x ，且mid左右两边都有x存在，则q[mid] &gt;= x的判定条件即可将区间划分为[l, mid]，逐次进行即可找到第一个x；反之，q[mid] &lt;= x的判定条件即可将区间划分为[mid, r]</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="42-浮点数二分">4.2 浮点数二分<a class="headerlink" href="#42-浮点数二分" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">dou_bsearch_1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1e-8</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">dou_bsearch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1e-8</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>一般1e8这个地方看题目要求， 总是比题目要求保留小数位数多2
<code>eg</code>：保留4位小数，1e6</li>
</ul>
<h3 id="5-高精度">5. 高精度<a class="headerlink" href="#5-高精度" title="Permanent link">¶</a></h3>
<h4 id="51-高精度相加">5.1 高精度相加<a class="headerlink" href="#51-高精度相加" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code>A + B      len(A), len(B) &lt;= 1e6
</code></pre></div>
<h4 id="52-高精度相减">5.2 高精度相减<a class="headerlink" href="#52-高精度相减" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code>A - B       len(A), len(B) &lt;= 1e6
</code></pre></div>
<h4 id="53-高精度乘法">5.3 高精度乘法<a class="headerlink" href="#53-高精度乘法" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code>A * a      len(A) &lt;= 1e6      a &lt;= 1e9
</code></pre></div>
<h4 id="54-高精度除法">5.4 高精度除法<a class="headerlink" href="#54-高精度除法" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code>A * a      len(A) &lt;= 1e6      a &lt;= 1e9
</code></pre></div>
<h4 id="55-大整数">5.5 大整数<a class="headerlink" href="#55-大整数" title="Permanent link">¶</a></h4>
<ul>
<li>大整数在c++里面用数组来表示（存储）</li>
<li>把大整数的每一位存到数组里面，按照低位在前进行存储（即第零位存个位）
    &gt; <code>原因</code>：两个数进行运算会出现进位的可能，这时将高位数放到数组最后一位会使得数据处理起来更方便（否则便会从数组第一位依次后移，效率降低）（栈？？？）</li>
<li>用库函数<vector>来表示一个大整数，一个size函数， 表示一个数组的长度，就不用再额外开一个内存来存储数组的长度了</vector></li>
<li>模拟人工加法</li>
</ul>
<h3 id="6-前缀和">6. 前缀和<a class="headerlink" href="#6-前缀和" title="Permanent link">¶</a></h3>
<p><font color="#dd0000"><strong>数组下标从1开始</strong></font></p>
<h4 id="61-一维前缀和">6.1 一维前缀和<a class="headerlink" href="#61-一维前缀和" title="Permanent link">¶</a></h4>
<p><span class="arithmatex">\(S_i = a_1 + a_2 + ... + a_i\)</span></p>
<p>意味着<span class="arithmatex">\(S_0 = 0\)</span>，对应于后面，与后面<span class="arithmatex">\(S_r - S_{l-1}\)</span> 保持一致</p>
<p>如何求<span class="arithmatex">\(S_i\)</span> <br/>
<strong>一维前缀和</strong>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">S_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S_</span><span class="p">{</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a_i</span>
</code></pre></div></p>
<p>作用：<strong>能够快速地求出原数组中一段数的和</strong></p>
<p>区间<code>[l, r]</code>这一段的和：<span class="arithmatex">\(S_r - S_{l-1}\)</span></p>
<p>前缀和<span class="arithmatex">\(S[i] = a[1] + a[2] + ... a[i]\)</span></p>
<p>原数组中一段数的和<span class="arithmatex">\(a[l] + ... + a[r] = S[r] - S[l - 1]\)</span></p>
<h4 id="62-二维前缀和">6.2 二维前缀和<a class="headerlink" href="#62-二维前缀和" title="Permanent link">¶</a></h4>
<ul>
<li>
<p>S[i, j] 表示 第 i 行 j 列格子左上部分所有元素的和
    &gt; <span class="arithmatex">\(S[i, j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j]\)</span></p>
</li>
<li>
<p>以 ( x1 ,  y1 ) 为左上角， ( x2 ,  y2 ) 为右下角的子矩阵的和为：
    &gt; <span class="arithmatex">\(S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\)</span></p>
</li>
</ul>
<h3 id="7-差分">7. 差分<a class="headerlink" href="#7-差分" title="Permanent link">¶</a></h3>
<p><font color="#dd0000"><strong>数组下标从1开始</strong></font></p>
<p><strong>前缀和的逆运算</strong></p>
<h4 id="71-一维差分">7.1 一维差分<a class="headerlink" href="#71-一维差分" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">给定a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="err">，</span><span class="n">构造差分数组b</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="err">，</span><span class="n">使得</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="err">，</span><span class="n">即</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">数组是</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">数组的一个前缀和</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">核心操作</span><span class="err">：</span><span class="n">将a</span><span class="p">[</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">]</span><span class="n">区间所有数字加上C</span><span class="err">，</span><span class="w"> </span><span class="n">等价于</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">R</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">C</span>
</code></pre></div>
<p><strong>构造b数组</strong>---即假设a数组全为0， 则b数组也全为0，但实际上，a数组不全为0。这里需要构造一个插入函数，</p>
<h4 id="72-二维差分">7.2 二维差分<a class="headerlink" href="#72-二维差分" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">给以</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">)</span><span class="n">为左上角</span><span class="err">，</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="w"> </span><span class="n">y2</span><span class="p">)</span><span class="n">为右下角的子矩阵中的所有元素加上c</span><span class="err">：</span>
<span class="n">S</span><span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">[</span><span class="n">x2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">[</span><span class="n">x2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">c</span>
</code></pre></div>
<h3 id="8-双指针算法">8. 双指针算法<a class="headerlink" href="#8-双指针算法" title="Permanent link">¶</a></h3>
<p><font color="#dd0000"><strong>优化</strong></font></p>
<ul>
<li><strong>单调</strong> 考虑二分或双指针</li>
<li>先写出暴力解法，再看枚举时i j 的单调关系</li>
</ul>
<p><strong>核心思想</strong>：将双重for循环的O(n^2)的暴力法优化到O(n)</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">check</span><span class="p">())</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// check()寻找i j 之间的关系（比如单调性）</span>
<span class="w">    </span><span class="c1">// 以上是基本模板格式，下面具体问题具体分析</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="9位运算">9.位运算<a class="headerlink" href="#9位运算" title="Permanent link">¶</a></h3>
<h4 id="91-n的二进制表示中第k位是几个位是第0位依次">9.1 n的二进制表示中第k位是几（个位是第0位，依次）<a class="headerlink" href="#91-n的二进制表示中第k位是几个位是第0位依次" title="Permanent link">¶</a></h4>
<ol>
<li>先把n的第k位移到第0位   n &gt;&gt; k</li>
<li>再看个位数是几   (n &gt;&gt; k) &amp; 1</li>
<li>综述        (n &gt;&gt; k) &amp; 1</li>
</ol>
<h4 id="92-lobitx">9.2 lobit(x)<a class="headerlink" href="#92-lobitx" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">&amp;-</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// 与运算，将x变为二进制进行与运算  </span>
</code></pre></div>
<ul>
<li>返回x的二进制的最右边的一个1 
    &gt; 例如：lowbit(100100) =&gt; 100</li>
</ul>
<h3 id="10-离散化">10. 离散化<a class="headerlink" href="#10-离散化" title="Permanent link">¶</a></h3>
<p>类似于在一个很大的给定区间范围上，但是可以用到的区域占比很小（类比稀疏矩阵）</p>
<p>通过将所需要用到的数据点坐标映射为1， 2， 3， ... 这样的有序（因为提前将数据进行了排序去重）序列（二分实现），来达到离散化算法的功效。</p>
<p>在大数轴上有很多数据，但是仅仅只用到了很少的一部分，我们只需要将用到过的数据，比如将数据值<code>x</code>的坐标映射到1，2，3...这个小数轴上面的坐标值即可。如果需要计算大数轴上面<code>L~R</code>之间的数据和，只需要将<code>L</code>与<code>R</code>分别映射到小数轴上面的<code>l</code>与<code>r</code>，再在小数轴上面求前缀和即可。最终避免了开很大的数组造成的空间浪费。</p>
<ul>
<li>必须加入下面这两行代码（先排序，再去重）</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">sort</span><span class="p">(</span><span class="n">alls</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">alls</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="n">alls</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">alls</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">alls</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span><span class="w"> </span><span class="n">alls</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</code></pre></div>
<p><strong>Java/Python</strong>实现unique()函数
<div class="highlight"><pre><span></span><code><span class="c1">// 双指针算法</span>
<span class="c1">// 满足性质：第一个数 或者 当前这个数与前一个数不同 说明这个数是第一次出现</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span>
<span class="w">        </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="c1">// a[0]~a[j - 1]即为a[n]中所有不重复元素 </span>
</code></pre></div></p>
<h3 id="11区间合并">11.区间合并<a class="headerlink" href="#11区间合并" title="Permanent link">¶</a></h3>
<p><font color="#dd0000"><strong>贪心思想</strong></font></p>
<blockquote>
<p>跟区间有关的题目，大部分都是贪心；可以对区间左端点 || 右端点 || 左右端点双关键字排序 </p>
</blockquote>
<p>将有交集的区间合并为一个区间（取并集） </p>
<ol>
<li>按区间左端点进行排序</li>
<li>对于当前所维护的区间<code>I</code>而言，其下一个区间<code>J</code>与当前的区间<code>I</code>仅可能存在3种位置关系</li>
<li><code>J</code>完全包含于<code>I</code>区间中；此时答案为<code>I</code></li>
<li><code>J</code>与<code>I</code>有部分交集；此时两个区间取并集</li>
<li><code>J</code>与<code>I</code>没有交集；此时即可将<code>I</code>区间存放如答案中，以<code>J</code>区间作为下一个维护的区间进行讨论</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PII</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">segs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PII</span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>

<span class="w">    </span><span class="n">sort</span><span class="p">(</span><span class="n">segs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">segs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-2e9</span><span class="p">,</span><span class="w"> </span><span class="n">ed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-2e9</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">seg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">segs</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ed</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">-2e9</span><span class="p">)</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">ed</span><span class="p">});</span>
<span class="w">            </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">ed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">ed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">ed</span><span class="p">,</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">st</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">-2e9</span><span class="p">)</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">ed</span><span class="p">});</span>

<span class="w">    </span><span class="n">segs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="数据结构">数据结构<a class="headerlink" href="#数据结构" title="Permanent link">¶</a></h2>
<ul>
<li><u><del>都是用来做优化的</del></u></li>
</ul>
<h3 id="1-链表">1. 链表<a class="headerlink" href="#1-链表" title="Permanent link">¶</a></h3>
<h4 id="11-单链表">1.1 单链表<a class="headerlink" href="#11-单链表" title="Permanent link">¶</a></h4>
<p>在算法中用的最多的是邻接表（n个链表）</p>
<p>邻接表主要存储数和图</p>
<p>用数组模拟链表（用于笔试）</p>
<p>结构体指针构造链表会超时（用于面试）</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100010</span><span class="p">;</span>

<span class="c1">// head表示头结点的下标</span>
<span class="c1">// e[i]表示结点i的值</span>
<span class="c1">// ne[i]表示结点i的next指针是多少</span>
<span class="c1">// idx表示当前所用的是第几个结点</span>
<span class="kt">int</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 将x插入到头结点</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add_to_head</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 将x插入到下标是k的结点的后面</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 将下标是k的点的后面的点删掉</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ne</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">ne</span><span class="p">[</span><span class="n">k</span><span class="p">]];</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="12-双链表">1.2 双链表<a class="headerlink" href="#12-双链表" title="Permanent link">¶</a></h4>
<p>用来优化某些问题</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100010</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="p">[</span><span class="n">Nl</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>

<span class="c1">// 初始化</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 0表示左端点，1表示右端点</span>
<span class="w">    </span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 在下标是k的点的右边，插入x</span>
<span class="c1">// 在下标是k的点的左边插入x只要执行操作add(l[k], x);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">l</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">    </span><span class="n">r</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="w">    </span><span class="n">l</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>
<span class="w">    </span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 删除第k个点</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">r</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="w">    </span><span class="n">l</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="2-栈">2. 栈<a class="headerlink" href="#2-栈" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100010</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">stk</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// 插入</span>
<span class="n">stk</span><span class="p">[</span><span class="o">++</span><span class="n">tt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="c1">// 弹出</span>
<span class="n">tt</span><span class="o">--</span><span class="p">;</span>

<span class="c1">// 判断栈是否为空</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tt</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">empty</span><span class="p">;</span>
<span class="k">else</span><span class="w"> </span><span class="n">empty</span><span class="p">;</span>

<span class="c1">// 取出栈顶元素</span>
<span class="n">stk</span><span class="p">[</span><span class="n">tt</span><span class="p">];</span>
</code></pre></div>
<h4 id="单调栈应用">单调栈应用<a class="headerlink" href="#单调栈应用" title="Permanent link">¶</a></h4>
<p>给定一个序列，求序列中每一个数左边离它最近的且比它小的数字，若不存在则返回-1</p>
<p>与双指针思路类似，先暴力求解，再探究规律</p>
<h3 id="3-队列">3. 队列<a class="headerlink" href="#3-队列" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100010</span><span class="p">;</span>

<span class="c1">// 在队尾插入元素，在队头弹出元素</span>
<span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">hh</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="c1">// 插入</span>
<span class="n">q</span><span class="p">[</span><span class="o">++</span><span class="n">tt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="c1">// 弹出</span>
<span class="n">hh</span><span class="o">++</span><span class="p">;</span>

<span class="c1">// 判断队列是否为空</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hh</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tt</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">empty</span>
<span class="k">else</span><span class="w"> </span><span class="n">empty</span>

<span class="c1">// 取出队头元素</span>
<span class="n">q</span><span class="p">[</span><span class="n">hh</span><span class="p">]</span>
</code></pre></div>
<h4 id="单调队列">单调队列<a class="headerlink" href="#单调队列" title="Permanent link">¶</a></h4>
<p>典型应用：<strong>滑动窗口</strong> 求滑动窗口里面的最大值或最小值</p>
<p>与双指针思路类似，先暴力求解，再探究规律，删去没有用的元素，就得到单调性了，利用单调性求极值</p>
<ul>
<li>比如要<strong>寻找一个滑动块内的最小值</strong> 利用队列来维护滑动块内的信息<blockquote>
<p>假设有队列<code>q</code>（数组存储的是下标），队头<code>hh</code>，队尾<code>tt</code>，滑动块长度为<code>k</code>，队头处存储的永远是滑动块内的最小值的下标</p>
<p>假设滑动块移动到了某一区域，此时在滑动区间内有最小值<code>x</code>，坐标为<code>q[hh]</code>；随着滑动块的移动，只要这个<code>x</code>还未移出滑动块内（<code>i - k + 1 &lt;= q[hh]</code>），那么滑动块内的最小值就仍是<code>x</code>，保持不变；如果随着滑动块的移动，此时从队尾入队的元素<code>y</code>，有<code>y &lt;= 队头元素所存储的最小值，即x</code>，则<code>x</code>出队<code>y</code>入队，<code>y</code>的坐标就变为了<code>q[hh]</code>。循环往复...</p>
</blockquote>
</li>
</ul>
<p><strong>代码参考</strong>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">hh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hh</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">hh</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">hh</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">hh</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="n">tt</span><span class="p">]]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="n">tt</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="n">q</span><span class="p">[</span><span class="o">++</span><span class="n">tt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="n">hh</span><span class="p">]]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="4-kmp">4. KMP<a class="headerlink" href="#4-kmp" title="Permanent link">¶</a></h3>
<p><span class="arithmatex">\(O(n)\)</span></p>
<ul>
<li>
<p><strong><code>next</code>数组</strong>
<code>next[i] = j</code>的含义：模板串<code>P</code>中以<code>i</code>为终点的后缀子串和以<code>1</code>开始的前缀子串长度相等，均为<code>j</code>，且有子串的长度最长；即<code>P[1 ~ j] = P[i - j + 1 ~ i]</code></p>
</li>
<li>
<p><strong><code>KMP</code>匹配过程</strong>
在对目标串<code>S</code>进行匹配时，假设匹配到<code>S</code>串的第<code>i - 1</code>个位置与<code>P</code>串的第<code>j</code>个位置之前都是相等的；但是当匹配到<code>S</code>串的第<code>i</code>个位置与<code>P</code>串的第<code>j + 1</code>个位置时，有<code>S[i] != P[j + 1]</code>而且此时模板串的指针还没有回退到模板串的起始位置，则此时调用<code>next</code>数组，将模板串<code>P</code>向前移动<code>next[j]</code>再继续看<code>S</code>串的第<code>i</code>个位置与<code>P</code>串的第<code>next[j] + 1</code>个位置是否相等，若不等且此时模板串的指针还没有回退到模板串的起始位置则继续移动<code>next[next[j]]</code>，否则如果相等，则指针向前移动，直至结束匹配；匹配结束时，仍要令模板串向前移动<code>next[指针位置]</code>（因为匹配成功后，目标串可能还有剩余的元素未进行匹配，进行<code>next</code>操作以进行后续的下一次匹配</p>
</li>
</ul>
<p><strong>代码参考</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 求next数组</span>
<span class="c1">// 由于next[1] = 0，故从i = 2开始</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">ne</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// KMP匹配过程</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span>
<span class="w">        </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>可以用来求循环节，其他体型好像都不如字符串前缀哈希了</p>
<h3 id="5-trie">5. Trie<a class="headerlink" href="#5-trie" title="Permanent link">¶</a></h3>
<p>应用：AC自动机</p>
<p><u><strong>一般出现的字符串类型：全是小写字母、全是大写字母、只有数字、只有0/1</strong></u></p>
<p><u>用来快速（高效）<strong>存储</strong>和<strong>查找</strong>字符串集合的数据结构</u></p>
<p><strong>Trie树的存储</strong>
构造过程可以想想FP_tree的构造过程（<del>关联规则的一种方法，如果还可以想起来的话</del>；Trie树会在每个字符串的结尾处做一个标记，表示这个字符串的结束</p>
<p><strong>代码参考</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// son[N][26]表示存储的是`Trie`树中每个节点的所有儿子；cnt[N]表示以当前节点结尾的元素有多少个；idx表示当前用到了哪个下标（下标为0的点，既是根节点也是空结点） </span>
<span class="c1">// 插入节点，建立Trie树</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">'a'</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">t</span><span class="p">])</span><span class="w"> </span><span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">idx</span><span class="p">;</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">t</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">cnt</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 查询</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">'a'</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">t</span><span class="p">])</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">son</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">t</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cnt</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="6-并查集">6. 并查集<a class="headerlink" href="#6-并查集" title="Permanent link">¶</a></h3>
<p><strong><del>面试笔试    思维</del></strong></p>
<ul>
<li>应用之一：Kruskal</li>
</ul>
<p><strong>用途：</strong>
1. 将两个集合合并
2. 询问两个元素是否在一个集合中</p>
<p>近乎<span class="arithmatex">\(O(1)\)</span>的时间复杂度，快速地支持上面的两个操作</p>
<p><strong>基本原理</strong>：每个集合用一棵<strong>树</strong>来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，即p[x]表示x的父节点。</p>
<p><strong>问题</strong>
1. 判断树根： <code>if（p[x] == x）</code>
2. 求x的集合编号：<code>while（p[x] != x） x = p[x];</code>；此时该操作的复杂度还是很高，可以看出，与树高成正比
    &gt; <strong>优化</strong>：<strong>路径压缩</strong>：节点x沿着它的父亲节点一路找，一旦找到根节点，就将节点x寻找根节点路径上的所有节点都指向根节点
3. 合并两个集合：设p[x]是x的集合编号，p[y]是y的集合编号。则合并操作：<code>p[x] = y</code>或<code>p[y] = x</code></p>
<p><u><strong>核心操作</strong></u></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 寻找x结点的祖宗节点 + 路径优化</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<!-- **食物链**
不论两个动物之间是不是同一种生物、是不是被吃的关系，都将它们放到一个集合中，即一个树中

那么如何确定其中两个动物之间的关系呢？记录一下每个点与根节点之间的关系；只要我们知道了每个点与根节点的关系了，就可以知道每两个点之间的关系了

利用每个点与根节点之间的距离表示其与根节点之间的关系

- 距离 % 3 = 1 表示可以吃根节点
- 距离 % 3 = 2 表示可以被根节点吃
- 距离 % 3 = 0 表示与根节点同类

在这道题中，利用并查集维护每个点到根节点的距离   -->
<h3 id="7-堆">7. 堆<a class="headerlink" href="#7-堆" title="Permanent link">¶</a></h3>
<p><u>维护一个数据集合</u></p>
<ul>
<li>基本操作</li>
<li>
<p>插入与删除都只与树的高度有关，故是logn的</p>
</li>
<li>
<p>向集合中插入一个数</p>
</li>
<li>求集合当中的最小值</li>
<li>在集合中删除最小值</li>
<li>删除集合中任意一个元素</li>
<li>修改集合中任意一个元素</li>
</ul>
<p>这里规定高度/深度/层数都是从1开始的</p>
<p>直接建堆是O(nlogn)的       -PS：因为插入是logn的</p>
<p>可以使用O(n)来建堆</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="n">down</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</code></pre></div>
<p>完全二叉树的第n/2个结点是最后一个非叶子节点</p>
<p>代码</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 设堆是heap[], 堆的大小是size</span>
<span class="c1">//1.</span>
<span class="n">heap</span><span class="p">[</span><span class="o">++</span><span class="n">size</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">up</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="c1">//2.</span>
<span class="n">heap</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="c1">//3.  拿最后一个结点把第一个结点覆盖掉，再down      PS：因为是用一维数组存储的，所有删掉第一个元素是O(n)的，而删除最后一个元素是O(1)的</span>
<span class="n">heap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap</span><span class="p">[</span><span class="n">size</span><span class="p">];</span><span class="w"> </span><span class="n">size</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="n">down</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">//4.</span>
<span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heap</span><span class="p">[</span><span class="n">size</span><span class="p">];</span><span class="w"> </span><span class="n">size</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="n">down</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">up</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
<span class="c1">//5.</span>
<span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">down</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">up</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</code></pre></div>
<p>堆是一个完全二叉树           堆中某个节点的值总是不大于或不小于其父节点的值</p>
<p>小根堆：每个节点的值都 ≤ 它的左右儿子的值</p>
<ul>
<li>堆的存储结构（堆状数据结构/完全二叉树）：一维数组         一维数组就可以存下一棵树</li>
</ul>
<p><strong><em>1号点是根节点   下标是x的结点的左儿子下标是2x，右儿子下标是2x+1</em></strong></p>
<p>下面的一维数组即表示下面的小根堆</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre class="mermaid"><code>graph TD;
    1--&gt;2;
    1--&gt;3;
    2--&gt;4;
    2--&gt;5;
    3--&gt;6;
    3--&gt;7;
    4--&gt;8;
    4--&gt;9;
    5--&gt;10;</code></pre>
<p><strong><em>基本操作</em></strong></p>
<ol>
<li>down(x)（将结点往下调整）</li>
<li>up(x)（将结点往上调整）</li>
</ol>
<h3 id="8-hash">8. Hash<a class="headerlink" href="#8-hash" title="Permanent link">¶</a></h3>
<ul>
<li><strong>离散化</strong></li>
<li>离散化是一种特殊的hash   </li>
<li>离散化 = 排序 + hash</li>
<li>离散化保证了映射后原数据的顺序保持不变，hash并没有保证</li>
<li>离散化是nlogn（maybe），hash是O(1)的</li>
</ul>
<p>把一堆数据映射到<span class="arithmatex">\(0\)</span><sub><span class="arithmatex">\(N\)</span>的小空间（<span class="arithmatex">\(N\)</span>=<span class="arithmatex">\(10^5\)</span></sub><span class="arithmatex">\(10^6\)</span>）</p>
<!-- 将所有的数放在小空间中，解决冲突问题 -->
<p><strong>冲突问题是指利用hash函数映射后，可能会出现多个数映射到同一个数的情况</strong></p>
<p>利用hash函数进行映射，一般取对<span class="arithmatex">\(10^5\)</span>取模这个操作作为hash函数 <span class="arithmatex">\(h(x) = x\mod10^5\)</span>，<strong>其中<span class="arithmatex">\(10^5\)</span>取质数，且取距离2的整次幂尽可能远</strong>（冲突的概率是最低的）</p>
<p>根据处理冲突问题的不同的解决方案，分为<strong>开放寻址法</strong>和<strong>拉链法</strong></p>
<h4 id="81-哈希表的存储结构">8.1 哈希表的存储结构<a class="headerlink" href="#81-哈希表的存储结构" title="Permanent link">¶</a></h4>
<p>hashmap是拉链法，threadlocal是开放寻址法？？？？</p>
<p>hash在算法题中一般只有插入和查找这两个操作，没有删除</p>
<h4 id="82-开放寻址法">8.2 开放寻址法<a class="headerlink" href="#82-开放寻址法" title="Permanent link">¶</a></h4>
<p>开了一个一维数组，数组大小为题目要求大小的2~3倍</p>
<p><strong>插入过程</strong> 先找到<code>k=hash(x)</code>，然后从<code>k</code>开始往后找，直到找到第一个空的坑位为止，插进去</p>
<p><strong>查找过程</strong> 先找到<code>k=hash(x)</code>，从前往后找，先看一下当前位置有没有人，如果<strong>当前位置有人且这个人为x</strong>，那么就找到了<code>x</code>；如果当前位置有人但是这个人不是<code>x</code>，就继续看下一个位置；如果当前位置没有人，则<code>x</code>不存在</p>
<p><strong>删除过程</strong> 按照查找的方式找<code>x</code>，当找到<code>x</code>后，给他一个标记，代表删除了</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 核心函数</span>
<span class="c1">// find函数  如果x在哈希表中已经存在，就返回x所在的位置；如果x在哈希表中不存在，则返回x应该存储的位置</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 茅厕寻址法：当当前坑位有人且当前坑位中的人不是你要找的人才进入循环</span>
<span class="w">    </span><span class="c1">// null = 0x3f3f3f3f &gt; 1e9</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="83-拉链法">8.3 拉链法<a class="headerlink" href="#83-拉链法" title="Permanent link">¶</a></h4>
<p>利用邻接链表的结构存储hash的映射值</p>
<p>开一个一维数组来存储所有的hash值，该一维数组每个结点都表示一个表头</p>
<blockquote>
<p>其中数组大小为“利用hash函数进行映射，一般取对<span class="arithmatex">\(10^5\)</span>取模这个操作作为hash函数 <span class="arithmatex">\(h(x)\)</span>=<span class="arithmatex">\(x \mod 10^5\)</span>，其中<span class="arithmatex">\(10^5\)</span>取质数，且取距离<span class="arithmatex">\(2\)</span>的整次幂尽可能远（冲突的概率是最低的）“这样大小的）</p>
</blockquote>
<p><strong>插入过程</strong> 若经过hash映射后，出现了两个相同的映射值，则依次将这两个数插到对应一维数组头节点下面，形成邻接链表。</p>
<p><strong>查找过程</strong> 对于要查找的x的映射值，有hash(x)，找到对应的位置，再对该位置的链表进行遍历</p>
<p><strong>删除过程</strong> 开一个bool数组，把要进行删除的元素打一个标记</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">    </span><span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="84-字符串前缀哈希法">8.4 字符串前缀哈希法<a class="headerlink" href="#84-字符串前缀哈希法" title="Permanent link">¶</a></h4>
<p>假定不存在冲突</p>
<p>快速判断两个字符串是否相等</p>
<hr/>
<ol>
<li>先预处理出所有前缀的哈希值</li>
<li>求出所有的前缀字符串的哈希值</li>
<li>利用这些前缀字符串哈希值可以表示出字符串中任意子串</li>
</ol>
<hr/>
<hr/>
<p><strong><u>将任意字符串转化为哈希值的方法：</u></strong></p>
<p>把字符串看作p进制数</p>
<p>把p进制数转化为10进制数</p>
<p>对该字符串哈希值mod Q</p>
<p>则对于任意一个字符串，都可以将其表示为0~Q-1的一个数字（通常不将字符串映射成0）</p>
<p><strong><em>取p = 131或13331，Q = 2^64</em></strong></p>
<hr/>
<h2 id="搜索与图论">搜索与图论<a class="headerlink" href="#搜索与图论" title="Permanent link">¶</a></h2>
<p>DFS和BFS都可以对整个空间搜索，搜索结构都是树的形式。</p>
<p>但是DFS尽可能往深了搜，一旦达到叶节点就会回溯</p>
<p>BFS会将当前这一层搜索完了才会继续搜索下一层</p>
<h3 id="1-dfs">1. DFS<a class="headerlink" href="#1-dfs" title="Permanent link">¶</a></h3>
<p><strong>思路比较奇怪就用DFS或对空间要求比较高</strong></p>
<p>依靠stack</p>
<p>空间复杂度为 O(h)   即与高度成正比</p>
<p>不具有最短路性质</p>
<p>时间复杂度为线性的</p>
<p>DFS俗称“暴搜”</p>
<p>要考虑好<strong>顺序</strong></p>
<p>从搜索树的角度考虑</p>
<p>回溯</p>
<p>剪枝</p>
<h3 id="2-bfs">2. BFS<a class="headerlink" href="#2-bfs" title="Permanent link">¶</a></h3>
<p><strong>问最短距离，最小步数，最少操作几次</strong> （前提是每个边的权重都是一样的）</p>
<p><a class="glightbox" data-desc-position="bottom" data-height="auto" data-width="100%" href="bfs.png"><img alt="" src="bfs.png"/></a></p>
<p>依靠queue</p>
<p>空间复杂度为O(2^h)</p>
<p>具有最短路性质</p>
<h3 id="3-树和图的存储">3. 树和图的存储<a class="headerlink" href="#3-树和图的存储" title="Permanent link">¶</a></h3>
<p>树是无环连通图，是一种特殊的图</p>
<p>可以把无向图变成两个方向的有向图，只用考虑有向图的存储即可实现无向图的存储</p>
<p>存储方式分为<strong>邻接矩阵</strong>和<strong>邻接表</strong>两种</p>
<p><strong>邻接矩阵</strong> 用一个二维数组实现 g<script type="math/tex; mode=display">a</script>
<script type="math/tex; mode=display">b</script> 存储边a到边b的信息（即权重）不能存储重边 适合存储稠密图  O(n^2)</p>
<p><strong>邻接表</strong> 就是n个单链表（其中n表示节点个数），每个单链表用来存储这个结点可以到达的结点 </p>
<p>往邻接表中插入数据时，选择在链表头进行插入</p>
<p>常用<strong>邻接表</strong>来存储</p>
<h3 id="4-树和图的遍历">4. 树和图的遍历<a class="headerlink" href="#4-树和图的遍历" title="Permanent link">¶</a></h3>
<p>分为深度优先遍历和广度优先遍历，每个点只需遍历一次   时间复杂度是O(n + m)   n为节点数，m为边数</p>
<p>只用考虑有向图的遍历即可（无向图是一种特殊的有向图，树是一种特殊的图）</p>
<p>遍历只需要找到一条路即可，不必再像dfs中再恢复现场</p>
<p>这两种搜索方式的思想就是dfs和bfs</p>
<h4 id="深度优先遍历">深度优先遍历<a class="headerlink" href="#深度优先遍历" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ne</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>dfs会求得每一个子树的大小</p>
<h4 id="广度优先遍历">广度优先遍历<a class="headerlink" href="#广度优先遍历" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code>
</code></pre></div>
<h3 id="5-拓扑序列">5. 拓扑序列<a class="headerlink" href="#5-拓扑序列" title="Permanent link">¶</a></h3>
<p>针对有向图，无向图没有拓扑序列</p>
<p>是广度优先算法的应用</p>
<p>有向无环图一定存在一个拓扑序列    有向无环图也被称为拓扑图</p>
<p>有向环图一定不存在拓扑序列</p>
<p>所有入度为0的点都可以排在当前序列中最前面的位置</p>
<h3 id="6-最短路">6. 最短路<a class="headerlink" href="#6-最短路" title="Permanent link">¶</a></h3>
<p>n表示结点数，m表示边数</p>
<pre class="mermaid"><code>graph TD;
    最短路--&gt;单源最短路;
    最短路--&gt;多源汇最短路;
    单源最短路--&gt;所有边权都是正数;
    单源最短路--&gt;存在负权边;
    所有边权都是正数--&gt;朴素Dijkstra算法;
    所有边权都是正数--&gt;堆优化版的Dijkstra算法;
    朴素Dijkstra算法--&gt;n2适合稠密图;
    堆优化版的Dijkstra算法--&gt;mlongn适合稀疏图;
    存在负权边--&gt;Bellman-Ford;
    Bellman-Ford--&gt;nm;
    Bellman-Ford--&gt;不超过k条边的最短路问题;
    存在负权边--&gt;SPFA;
    SPFA--&gt;一般是m,最坏是nm;
    多源汇最短路--&gt;Floyd算法;
    Floyd算法--&gt;n3;</code></pre>
<p>最短路问题的核心是如何把题干抽象为一个图，如何定义点和边来确定最短路问题</p>
<h4 id="61-朴素dijkstra算法">6.1 朴素Dijkstra算法<a class="headerlink" href="#61-朴素dijkstra算法" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 1.初始化dist数组</span>
<span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3f3f3f3f</span><span class="p">;</span><span class="w"> </span><span class="c1">// i = 2,3,...,n</span>

<span class="c1">// 2.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// （1）</span>
<span class="w">    </span><span class="n">先找出不在s中的最短距离的点t</span>

<span class="w">    </span><span class="c1">// （2）</span>
<span class="w">    </span><span class="n">将此最短距离的点t加入最短路数组s中</span>

<span class="w">    </span><span class="c1">// （3）</span>
<span class="w">    </span><span class="n">用此次的最短距离的点t来更新其他点的距离</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="62-堆优化版dijkstra算法">6.2 堆优化版Dijkstra算法<a class="headerlink" href="#62-堆优化版dijkstra算法" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 初始化dist数组</span>
<span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x3f3f3f3f</span><span class="p">;</span>

<span class="n">利用priority_queue来存储</span><span class="err">，</span><span class="n">可以将朴素Dijkstra的</span><span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="n">优化到O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">priority_queue</span><span class="w"> </span><span class="n">更新操作是logn的</span><span class="err">，</span><span class="n">而低</span><span class="err">（</span><span class="mi">3</span><span class="err">）</span><span class="n">步一共需要更新所有的边共m次</span><span class="err">，</span><span class="n">故时间复杂度为mlogn</span>
<span class="n">但是priority_queue</span><span class="w"> </span><span class="n">中不支持修改任意一个元素</span><span class="err">，</span><span class="n">只能接受冗余的存在</span><span class="err">，</span><span class="n">即每次修改都往堆里面插入一个新的数</span>
<span class="n">所以本来堆里面是有n个数</span><span class="err">（</span><span class="n">手写堆可以保证</span><span class="err">），</span><span class="n">但是此时用的STL</span><span class="err">，</span><span class="n">priority_queue里面会有m个数</span>
<span class="n">所以实际上的时间复杂度为mlogm</span>
<span class="c1">// 2.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// （1）</span>
<span class="w">    </span><span class="n">先找出不在s中的最短距离的点t</span><span class="w"> </span><span class="c1">// O(1)</span>

<span class="w">    </span><span class="c1">// （2）</span>
<span class="w">    </span><span class="n">将此最短距离的点t加入最短路数组s中</span><span class="w"> </span><span class="c1">// O(1)</span>

<span class="w">    </span><span class="c1">// （3）</span>
<span class="w">    </span><span class="n">用此次的最短距离的点t来更新其他点的距离</span><span class="w"> </span><span class="c1">// logn</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="63-bellman-ford算法">6.3 Bellman-Ford算法<a class="headerlink" href="#63-bellman-ford算法" title="Permanent link">¶</a></h4>
<p>如果图中存在负权回路，则最短路可能会不存在（为-∞）</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">备份dist</span>
<span class="w">    </span><span class="nf">for</span><span class="w"> </span><span class="p">(</span><span class="n">循环所有边</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">w</span><span class="w">  </span><span class="n">由a</span><span class="o">-&gt;</span><span class="n">b</span><span class="err">，</span><span class="n">权重为w</span><span class="p">)</span>
<span class="w">        </span><span class="n">更新每一条边</span><span class="w"> </span><span class="n">dist</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">b</span><span class="p">],</span><span class="w"> </span><span class="n">dist</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="p">);</span><span class="w"> </span><span class="c1">// 松弛操作</span>
<span class="p">}</span>
</code></pre></div>
<p>​   </p>
<h4 id="64-spfa">6.4 SPFA<a class="headerlink" href="#64-spfa" title="Permanent link">¶</a></h4>
<p>只要图中没有负环，就可以用SPFA</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 初始化队列</span>
<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// 队列中存储的是从起点到该节点距离变小的结点</span>

<span class="c1">//</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">取出队列的首元素t</span><span class="err">，</span><span class="n">弹出首元素</span>

<span class="w">    </span><span class="n">更新t的所有出边</span><span class="err">，</span><span class="n">并把对应的出边的结点加到队列里面</span><span class="err">（</span><span class="n">因为t的所有出边由于t是变小的</span><span class="err">，</span><span class="n">所以它的所有出边也变小了</span><span class="err">，</span><span class="n">也要加入到队列中</span><span class="err">）（</span><span class="n">如果队列里面有了就不用了</span><span class="err">）</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="65-floyd">6.5 Floyd<a class="headerlink" href="#65-floyd" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 邻接矩阵存储所有的边</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</code></pre></div>
<h3 id="7-最小生成树">7. 最小生成树<a class="headerlink" href="#7-最小生成树" title="Permanent link">¶</a></h3>
<p>最小生成树一般涉及到的图都是无向图</p>
<p>稠密图，一般就用朴素版Prim算法</p>
<p>稀疏图，一般用Kruskal算法</p>
<p>堆优化版Prim算法不常用</p>
<pre class="mermaid"><code>graph TD;
    最小生成树--&gt;Prim算法;
    最小生成树--&gt;Kruskal算法;
    Prim算法--&gt;朴素版Prim算法;
    Prim算法--&gt;堆优化版Prim算法;
    朴素版Prim算法--&gt;适用于稠密图n2;
    堆优化版Prim算法--&gt;适用于稀疏图mlogn;
    Kruskal算法--&gt;mlogm;</code></pre>
<h4 id="71-朴素版prim算法">7.1 朴素版Prim算法<a class="headerlink" href="#71-朴素版prim算法" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">初始化dist</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mh">0x3f3f3f3f</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="c1">// 循环n次</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">找到集合外距离最近的点t</span>

<span class="w">    </span><span class="n">用t来更新其他点到集合的距离</span>

<span class="w">    </span><span class="n">st</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="72-kruskal算法">7.2 Kruskal算法<a class="headerlink" href="#72-kruskal算法" title="Permanent link">¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">将所有边按权重从小到大进行排序</span><span class="w">  </span><span class="c1">//O(mlongm)</span>

<span class="c1">// 并查集思想   并查集是O(1) 总共就是O(m)</span>
<span class="n">枚举每条边a</span><span class="o">-</span><span class="n">b</span><span class="err">，</span><span class="n">权重为c</span>
<span class="w">    </span><span class="n">若a</span><span class="o">-</span><span class="n">b不连通</span><span class="err">，</span><span class="n">则将a</span><span class="o">-</span><span class="n">b这条边加入到集合中</span>
</code></pre></div>
<h3 id="8-二分图">8. 二分图<a class="headerlink" href="#8-二分图" title="Permanent link">¶</a></h3>
<pre class="mermaid"><code>graph TD;
    二分图--&gt;染色法...就是一个dfs,判断图是否为二分图--&gt;m+n;
    二分图--&gt;匈牙利算法--&gt;最坏是mn,实际运行时间一般远小于mn;</code></pre>
<h4 id="81-染色法">8.1 染色法<a class="headerlink" href="#81-染色法" title="Permanent link">¶</a></h4>
<p>一个图是二分图当且仅当图中不含奇数环</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i未被染色</span><span class="p">)</span>
<span class="w">        </span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">)</span>
</code></pre></div>
<h4 id="82-匈牙利算法ntr算法bushi">8.2 匈牙利算法[NTR算法bushi]<a class="headerlink" href="#82-匈牙利算法ntr算法bushi" title="Permanent link">¶</a></h4>
<p>存储用邻接表</p>
<p>最坏时间复杂度是</p>
<h2 id="数学知识">数学知识<a class="headerlink" href="#数学知识" title="Permanent link">¶</a></h2>
<h3 id="1-数论">1. 数论<a class="headerlink" href="#1-数论" title="Permanent link">¶</a></h3>
<h4 id="11-质数">1.1 质数<a class="headerlink" href="#11-质数" title="Permanent link">¶</a></h4>
<p>在大于1的整数中，如果只包含1和其本身这两个约数，则该数就称为质数/素数</p>
<h5 id="111-质数的判定----试除法">1.1.1 质数的判定----试除法<a class="headerlink" href="#111-质数的判定----试除法" title="Permanent link">¶</a></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 从定义来</span>
<span class="c1">// O(n)</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">is_prime</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 优化后</span>
<span class="c1">// O(sqrt(n))</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">is_prime</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 原理见下方的数学块中内容</span>
</code></pre></div>
<div class="arithmatex">\[
如果d|n，则\frac{n}{d}|n。因此若要枚举n的所有大于1的约数，只需要有d \lt \frac{n}{d}，即枚举到\frac{n}{d}即可\\
\]</div>
<h5 id="112-分解质因数----试除法">1.1.2 分解质因数----试除法<a class="headerlink" href="#112-分解质因数----试除法" title="Permanent link">¶</a></h5>
<div class="arithmatex">\[
分解质因数：一个数x可以分解为，x = {p_1}^{\alpha_1}{p_2}^{\alpha_2}...{p_k}^{\alpha_k}，其中p_1,p_2,...,p_k均为质数
\]</div>
<div class="arithmatex">\[
一个数x中至多只包含一个大于\sqrt{n}的质因数
\]</div>
<div class="highlight"><pre><span></span><code><span class="c1">// 最坏是O(sqrt(x))，最好的O(logn)---比如x=2^k;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">divide</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">                </span><span class="n">num</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="113-筛质数">1.1.3 筛质数<a class="headerlink" href="#113-筛质数" title="Permanent link">¶</a></h5>
<p>将所有小于等于x的质数筛出来</p>
<h6 id="1131-朴素筛法">1.1.3.1 朴素筛法<a class="headerlink" href="#1131-朴素筛法" title="Permanent link">¶</a></h6>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"> </span><span class="c1">// 用来存储筛出来的质数</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"> </span><span class="c1">// 如果当前这个数被筛去了，则赋值为true</span>

<span class="c1">// 朴素筛法 O(nlogn)</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">get_primes</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>朴素筛法时间复杂度分析</strong>
<script type="math/tex; mode=display">
朴素筛法时间复杂度分析：当i=2时，第二层循环循环\frac{n}{2}；当i=3时，第二层循环循环\frac{n}{3}...当i=n时，第三层循环循环1次。\\故第二层循环总的循环次数为\frac{n}{2} + ... + \frac{n}{n}=n(\frac{1}{2} + ... + \frac{1}{n})，取极限有\lim_{t->+\infty}n(\frac{1}{2} + ... + \frac{1}{n})≈nlnn≈nlogn
</script>
</p>
<div class="arithmatex">\[
\lim_{t-&gt;+\infty}(1 + \frac{1}{2} + ... + \frac{1}{n}) = lnn + C，其中C为欧拉常数，lnn为log_en
\]</div>
<h6 id="1132-埃氏筛法">1.1.3.2 埃氏筛法<a class="headerlink" href="#1132-埃氏筛法" title="Permanent link">¶</a></h6>
<div class="highlight"><pre><span></span><code><span class="n">实际上</span><span class="err">，</span><span class="n">上面的第二层循环将2</span><span class="o">~</span><span class="n">x中所有数的倍数都枚举了一遍</span><span class="err">，</span><span class="n">但实际上</span><span class="err">，</span><span class="n">只需要将2</span><span class="o">~</span><span class="n">x中的所有质数的倍数枚举删去它们即可</span><span class="err">，</span><span class="n">故可做优化</span>
<span class="c1">// 埃氏筛法 O(nloglogn)    </span>
<span class="kt">void</span><span class="w"> </span><span class="n">get_primes</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">primes</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>埃氏筛法时间复杂度分析</strong>
<script type="math/tex; mode=display">
埃氏筛法时间复杂度分析：由于只用筛去质数的所有倍数，故有\lim_{t->+\infty}n({\frac{1}{2} + ... + \frac{1}{n}}_{质数})≈nlnn/lnn≈nlogn/lnn≈n\\
实际上真实的理论上的时间复杂度为O(nloglogn)
</script>
</p>
<div class="arithmatex">\[
质数定理：1-n当中一共有\frac{n}{lnn}个质数
\]</div>
<h6 id="1133-线性筛法">1.1.3.3 线性筛法<a class="headerlink" href="#1133-线性筛法" title="Permanent link">¶</a></h6>
<div class="highlight"><pre><span></span><code><span class="c1">// 线性筛法</span>
<span class="c1">// 把每一个合数只会被它的最小质因子筛掉</span>
<span class="c1">// O(n)</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">get_primes</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// primes[j]一定是i的最小质因子</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// 从小到大枚举的所有质数</span>
<span class="w">        </span><span class="c1">// 1. i % primes[j] == 0    primes[j]一定是i的最小质因子,primes[j]一定是primes[j]*i的最小质因子</span>
<span class="w">        </span><span class="c1">// 2. i % primes[j] != 0    primes[j]一定小于i的所有质因子,primes[j]一定是primes[j]*i的最小质因子</span>
<span class="w">        </span><span class="c1">//</span>
<span class="w">        </span><span class="c1">// 对于一个合数x，假设primes[j]是x的最小质因子，则当i枚举到x / primes[j]时，该合数x一定会被筛掉，而且仅用最小质因子来筛，又每个数只有一个最小质因子，所以每个合数只会被筛掉一次，所以是线性的</span>
<span class="w">        </span><span class="c1">//</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="12-约数">1.2. 约数<a class="headerlink" href="#12-约数" title="Permanent link">¶</a></h4>
<h5 id="121-试除法求一个数的所有约数">1.2.1 试除法求一个数的所有约数<a class="headerlink" href="#121-试除法求一个数的所有约数" title="Permanent link">¶</a></h5>
<div class="highlight"><pre><span></span><code><span class="n">vertor</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_divitors</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="122-约数个数">1.2.2 约数个数<a class="headerlink" href="#122-约数个数" title="Permanent link">¶</a></h5>
<div class="arithmatex">\[
算数基本定理\\
任何一个数x可以进行质因数分解，分解为x = {p_1}^{\alpha_1}{p_2}^{\alpha_2}...{p_k}^{\alpha_k}，其中p_1,p_2,...,p_k均为质数
\]</div>
<p><strong>约数个数为</strong>
<script type="math/tex; mode=display">
(\alpha_1+1)(\alpha_2+1)...(\alpha_k+1)
</script>
</p>
<div class="arithmatex">\[
由于一个数x可以进行质因数分解，分解为x = {p_1}^{\alpha_1}{p_2}^{\alpha_2}...{p_k}^{\alpha_k}\\
假设x的其中一个约数为d，则d也可以进行质因数分解，分解为d = {p_1}^{\beta_1}{p_2}^{\beta_2}...{p_k}^{\beta_k}\\
由于每个数的质因数分解形式都是一样的，且对于不同的指数的组合，对应不同的数，所以约数个数就是\beta_1,...,\beta_k的选法的个数\\
又0 \leq \beta_i \leq \alpha_i，因此\beta_i共有\alpha_i + 1种取法\\
所以由乘法原理有约数个数为(\alpha_1+1)(\alpha_2+1)...(\alpha_k+1)
\]</div>
<p>int范围内，拥有最多约数的数的约数个数仅为1536</p>
<h5 id="123-约数之和">1.2.3 约数之和<a class="headerlink" href="#123-约数之和" title="Permanent link">¶</a></h5>
<div class="arithmatex">\[
(p_1^0+p_1^1+...+p_1^{\alpha_1})...(p_k^0+p_k^1+...+p_k^{\alpha_k})
\]</div>
<h4 id="13-欧几里得算法辗转相除法">1.3. 欧几里得算法/辗转相除法<a class="headerlink" href="#13-欧几里得算法辗转相除法" title="Permanent link">¶</a></h4>
<div class="arithmatex">\[
(a, b) = (b, a \% b)\\
a \% b &lt;===&gt; a-\lfloor \frac{a}{b} \rfloor *b\\
Proof:\\
必要性：如果d=(a, b),则d|a, d|b,即d为a，b的最大公约数；又有d|(ax+by),所以d|(a-\lfloor \frac{a}{b} \rfloor *b)=d|(a\%b),所以d=(b, a \% b)\\
充分性：如果d=(b, a \% b),有d|b,d|(a\%b)=d|(a-\lfloor \frac{a}{b} \rfloor *b),所以d|(a-\lfloor \frac{a}{b} \rfloor *b + \lfloor \frac{a}{b} \rfloor *b)=d|a,所以d=(a,b)
\]</div>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">gcd</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="14-欧拉函数">1.4. 欧拉函数<a class="headerlink" href="#14-欧拉函数" title="Permanent link">¶</a></h4>
<div class="arithmatex">\[
欧拉函数，记作\varphi(n)，表示1-n中与n互质的数的个数（互质就是指两个数的gcd=1）
\]</div>
<div class="arithmatex">\[
求欧拉函数的公式：\\
设数N的质因数分解为N={p_1}^{\alpha_1}{p_2}^{\alpha_2}...{p_k}^{\alpha_k}，则\varphi(N)=N(1-\frac{1}{p_1})(1-\frac{1}{p_2})...(1-\frac{1}{p_k})
\]</div>
<div class="arithmatex">\[
欧拉函数公式证明（用到了容斥原理）\\
要想求得1-N中和N互质的数的个数就要：①从1-N中减去p_1,p_2,...,p_k的所有倍数;②加上所有p_i*p_j的倍数;③减去所有p_i*p_j*p_k的倍数;④加上所有...\\
就有个数为N-\frac{N}{p_1}-\frac{N}{p_2}-...-\frac{N}{p_k}+\frac{N}{p_1*p_2}+\frac{N}{p_1*p_3}-...+\frac{N}{p_{k-1}*p_k}-\frac{N}{p_1*p_2*p_3}-\frac{N}{p_1*p_2*p_4}-...-\frac{N}{p_{k-2}p_{k-1}*p_k}+...=欧拉函数
\]</div>
<div class="highlight"><pre><span></span><code><span class="c1">// 时间复杂度主要取决于分解质因数</span>
<span class="c1">// O(logx)-O(sqrt(x))</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">euler_func</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>求1-N中每一个数的欧拉函数，用上述做法，就要将每一个数进行质因数分解，则时间复杂度为O(Nsqrt(N))

利用线性筛法来去欧拉函数，会使得时间复杂度降低到O(N)
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">get_eulers</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">primes</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">st</span><span class="p">[</span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 如果i % primes[j] == 0，则primes[j]是i的最小质因数，即i的质因数分解和i * primes[j]的质因数分解得到的质数是相同的（有相同的质因数），因此phi[i * primes[j]]与phi[i]只差primes[j]倍</span>
<span class="w">                </span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// 如果i % primes[j] != 0，则primes[j]是i * primes[j]的最小质因数，就有phi[i * primes[j]] = phi[i] * phi[j]，而j是质因数，所以phi[j] = primes[j] - 1</span>
<span class="w">            </span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>欧拉定理</strong>
<script type="math/tex; mode=display">
若a与n互质，则a^{\varphi(n)}\equiv1(mod \ \ n)，其中\varphi(n)为欧拉函数
</script>
</p>
<div class="arithmatex">\[
Proof:\\
假设1-n中与n互质的数分别为a_1,a_2,...,a_{\varphi(n)}(因为欧拉函数为\varphi(n)),则又由于a与n互质，可知有aa_1,aa_2,...,aa_{\varphi(n)}也与n互质，\\且互不相同（反证法）,而且aa_1,aa_2,...,aa_{\varphi(n)}在模n的情况下是与a_1,a_2,...,a_{\varphi(n)}为同一组数。因此有\\a^{\varphi(n)}a_1a_2...a_{\varphi(n)}\equiv a_1a_2...a_{\varphi(n)}(mod \ n)----&gt;a^{\varphi(n)}\equiv 1(mod \ n)
\]</div>
<p><strong>费马小定理</strong>
<script type="math/tex; mode=display">
在欧拉定理中，当n为质数时，有a^{n-1}\equiv 1(mod \ n)\\
因为\varphi(n)=n-1
</script>
</p>
<h4 id="15-快速幂">1.5. 快速幂<a class="headerlink" href="#15-快速幂" title="Permanent link">¶</a></h4>
<ul>
<li>快速幂的<strong>核心思路</strong>：反复平方法</li>
<li>能够快速地求出<span class="arithmatex">\(a^k\ mod\ p\)</span></li>
<li>可以在<span class="arithmatex">\(O(logk)\)</span>的时间复杂度下求得上面的结果，其中<span class="arithmatex">\(0\le a,\ k,\ p\le10^9\)</span></li>
</ul>
<p><strong>二进制思想</strong>
预处理出来<span class="arithmatex">\(logk\)</span>个基值 <span class="arithmatex">\(a^{2^0}mod\ p，a^{2^1}mod\ p，...，a^{2^{log{k}}}mod\ p\)</span></p>
<p><span class="arithmatex">\(a^k\)</span>可以由上面预处理出来的基来表示（即将<code>k</code>转换为二进制表示），而且上面的基有关系为<span class="arithmatex">\((a^{2^0})^2=a^{2^1},(a^{2^1})^2=a^{2^2}...\)</span>，即当前的数=上一个数的平方再模<code>p</code></p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">qmi</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>利用快速幂求逆元</strong></p>
<p><strong>乘法逆元</strong>的定义：若整数<span class="arithmatex">\(b\)</span>，<span class="arithmatex">\(m\)</span>互质，并且对于任意的整数<span class="arithmatex">\(a\)</span>，如果满足<span class="arithmatex">\(b|a\)</span>，则存在一个整数<span class="arithmatex">\(x\)</span>，使得<span class="arithmatex">\(\frac{a}{b}≡a×x(mod \ m)\)</span>，则称<span class="arithmatex">\(x\)</span>为<span class="arithmatex">\(b\)</span>的模<span class="arithmatex">\(m\)</span>乘法逆元，记为<span class="arithmatex">\(b^{−1}(mod\ m)\)</span>。</p>
<p>b存在乘法逆元的充要条件是<span class="arithmatex">\(b\)</span>与模数<span class="arithmatex">\(m\)</span>互质。</p>
<p>当模数<span class="arithmatex">\(m\)</span>为质数时，<span class="arithmatex">\(b^{m−2}\)</span>即为<span class="arithmatex">\(b\)</span>的乘法逆元。（参见费马小定理）</p>
<p>当<span class="arithmatex">\(x\)</span>为<span class="arithmatex">\(b\)</span>的乘法逆元时，有<span class="arithmatex">\(x=b^{-1}(mod \ m)\)</span>。带入乘法逆元定义式，有<span class="arithmatex">\(\frac{a}{b}\equiv a×b^{-1}(mod\ m)\)</span>，化简得<span class="arithmatex">\(bb^{-1}\equiv 1(mod\ m)\)</span>
由于<span class="arithmatex">\(m\)</span>为质数，由费马小定理可知，<span class="arithmatex">\(b^{m-1}\equiv1(mod\ m)\)</span>，联立有<span class="arithmatex">\(b^{-1}(mod\ m)=b^{m-2}\)</span></p>
<h4 id="16-扩展欧几里得算法">1.6. 扩展欧几里得算法<a class="headerlink" href="#16-扩展欧几里得算法" title="Permanent link">¶</a></h4>
<p><strong>裴蜀定理</strong>
<script type="math/tex; mode=display">
对于任意的正整数a，b，一定存在非零整数x，y，使得ax+by=gcd(a, b)
</script>
利用扩展欧几里得算法可以求得一组x,y使得x,y满足ax+by=gcd(a,b)</p>
<p><strong>线性同余方程</strong></p>
<h4 id="17-中国剩余定理">1.7. 中国剩余定理<a class="headerlink" href="#17-中国剩余定理" title="Permanent link">¶</a></h4>
<div class="arithmatex">\[
有m_1,m_2,...m_k两两互质，则对于如下的线性同余方程组\\
\begin{cases}
x = a_1(mod \ m_1) \\
x = a_2(mod \ m_2) \\
...\\
x = a_k(mod \ m_k)
\end{cases}\\
有解为x=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+...+a_kM_kM_k^{-1}\\
其中M=m_1m_2...m_k,M_i=\frac{M}{m_{i}},M_i^{-1}表示M_i模m_i的逆
\]</div>
<h3 id="2-组合计数">2. 组合计数<a class="headerlink" href="#2-组合计数" title="Permanent link">¶</a></h3>
<h3 id="3-高斯消元">3. 高斯消元<a class="headerlink" href="#3-高斯消元" title="Permanent link">¶</a></h3>
<h3 id="4-简单博弈论">4. 简单博弈论<a class="headerlink" href="#4-简单博弈论" title="Permanent link">¶</a></h3>
<h2 id="dp">DP<a class="headerlink" href="#dp" title="Permanent link">¶</a></h2>
<p>时间复杂度分析：状态数量*计算每个状态需要的计算量</p>
<h3 id="1-背包问题">1. 背包问题<a class="headerlink" href="#1-背包问题" title="Permanent link">¶</a></h3>
<p>N个物品和容量为V的背包，每个物品的体积v_i，价值w_i</p>
<h4 id="11-0-1背包问题">1.1 0-1背包问题<a class="headerlink" href="#11-0-1背包问题" title="Permanent link">¶</a></h4>
<p>每件物品最多只能用一次</p>
<p>状态---未知数</p>
<p>状态表示指的是整个问题需要用几维的状态来表示，背包问题一般为两维</p>
<p>状态计算指的是如何一步一步把每一个状态算出来</p>
<p>Dp问题的优化是对状态方程/程序做一个等价变形</p>
<p>每一个状态表示的都是一个集合，集合里面是一堆选法，是所有选法的一个集合</p>
<p>状态计算就是考虑如何把当前的集合划分为若干个更小的子集，使得每一个子集都可以用更小的集合表示出来</p>
<p>集合划分的原则---不重不漏（求num），不漏（求max，min）</p>
<pre class="mermaid"><code>graph TD;
    Dp--&gt;状态表示f_ij--&gt;集合--&gt;所有选法的集合;
    集合--&gt;条件--&gt;1.只从前i个物品中选;
    条件--&gt;2.选出来物品的总体积小于等于j;
    状态表示f_ij--&gt;属性--&gt;Max;
    Dp--&gt;状态计算--&gt;集合的划分--&gt;按照第i个物品有没有选上来划分;</code></pre>
<h4 id="12-完全背包问题">1.2 完全背包问题<a class="headerlink" href="#12-完全背包问题" title="Permanent link">¶</a></h4>
<p>每件物品可以用无限次</p>
<pre class="mermaid"><code>graph TD;
    Dp--&gt;状态表示f_ij--&gt;集合--&gt;所有从前i个物品中选且总体积不超过j的所有选法的集合;
    状态表示f_ij--&gt;属性--&gt;Max;
    Dp--&gt;状态计算--&gt;集合的划分--&gt;按照第i个物品选0,1,2...k个来划分;</code></pre>
<p>三维时的状态转移方程为 f[i, j] = f[i - 1, j - k * v[i]] + k * w[i]</p>
<p>枚举k将状态转移方程展开</p>
<p>f[i, j] = max(f[i - 1, j], f[i - 1, j - v] + w, f[i - 1, j - 2v] + 2w + ...)</p>
<p>f[i, j - v] =           max(f[i - 1, j - v], f[i - 1, j - 2v] + w, ...)</p>
<p>因此状态转移方程优化为f[i, j] = max(f[i - 1, j], f[i, j - v] + w)</p>
<h4 id="13-多重背包问题">1.3 多重背包问题<a class="headerlink" href="#13-多重背包问题" title="Permanent link">¶</a></h4>
<p>每件物品最多只能用s_i次</p>
<p>优化：二进制优化</p>
<p>每件物品最多可以用s_i次
通过二进制优化，可以将s_i拆解为logs_i个（1,2,4,8...），且拆解出来的每一项仅可用一次
因此，所有的物品总共会最多拆解出Nlogs_i个
而每件拆解出来的物品又只能用一次
因此变为了一个0-1背包问题
时间复杂度由NVs降为NVlogs</p>
<h4 id="14-分组背包问题">1.4 分组背包问题<a class="headerlink" href="#14-分组背包问题" title="Permanent link">¶</a></h4>
<p>物品有N组，每一组物品有若干种物品，每一组里最多只能选一种物品</p>
<h3 id="2-线性dp">2. 线性Dp<a class="headerlink" href="#2-线性dp" title="Permanent link">¶</a></h3>
<p>递推的顺序有一个明显的线性顺序</p>
<h4 id="21-数字三角形">2.1 数字三角形<a class="headerlink" href="#21-数字三角形" title="Permanent link">¶</a></h4>
<pre class="mermaid"><code>graph TD;
    Dp--&gt;状态表示f_ij--&gt;集合--&gt;从起点到点i,j的所有路径的集合;
    状态表示f_ij--&gt;属性--&gt;Max;
    Dp--&gt;状态计算--&gt;集合的划分--&gt;按照走到i,j这个点的路径是从左上角走来的还是右上角走来的进行划分;</code></pre>
<p>左上角走来的状态转移方程f[i - 1, j - 1] + a[i, j]</p>
<p>右上角走来的状态转移方程f[i - 1, j] + a[i, j]</p>
<h4 id="22-最长上升子序列">2.2 最长上升子序列<a class="headerlink" href="#22-最长上升子序列" title="Permanent link">¶</a></h4>
<p>动态规划时间复杂度分析：
状态数量*计算每一个状态需要的的时间</p>
<p>这个算法的时间复杂度为O(n^2)</p>
<pre class="mermaid"><code>graph TD;
    Dp--&gt;状态表示f_i--&gt;集合--&gt;所有以第i个数结尾的上升子序列;
    状态表示f_i--&gt;属性--&gt;Max;
    Dp--&gt;状态计算--&gt;集合的划分--&gt;按第i个数前一位是原序列的第几位来分类;</code></pre>
<p>动态规划求方案就是把状态转移记录下来</p>
<h4 id="23-最长公共子序列">2.3 最长公共子序列<a class="headerlink" href="#23-最长公共子序列" title="Permanent link">¶</a></h4>
<pre class="mermaid"><code>    graph TD;
    Dp--&gt;状态表示f_i--&gt;集合--&gt;所有在第一个序列的前i个字母中出现且在第二个序列的前j个字母中出现的子序列;
    状态表示f_i--&gt;属性--&gt;Max;
    Dp--&gt;状态计算--&gt;集合的划分--&gt;按子序列中是否包含第一个序列的第i个字母第二个序列第j个字母划分;</code></pre>
<h4 id="24-区间dp">2.4 区间Dp<a class="headerlink" href="#24-区间dp" title="Permanent link">¶</a></h4>
<h5 id="241-石子划分">2.4.1 石子划分<a class="headerlink" href="#241-石子划分" title="Permanent link">¶</a></h5>
<p>以最后一次分界的位置来分类</p>
<p>区间Dp要保证算每个f_ij所依赖的状态都已经算好了
顺序：枚举区间长度，从小到大枚举</p>
<pre class="mermaid"><code>    graph TD;
    Dp--&gt;状态表示f_ij--&gt;集合--&gt;所有将第i堆石子到第j堆石子合并成一堆石子的合并方式;
    状态表示f_ij--&gt;属性--&gt;Min;
    Dp--&gt;状态计算--&gt;集合的划分--&gt;以最后一次合并的分界线的位置来分类;</code></pre>
<h2 id="note">NOTE<a class="headerlink" href="#note" title="Permanent link">¶</a></h2>
<ul>
<li>数据规模在100万以上，采用scanf和printf，否则cin和cout与他俩效率差不多</li>
<li>bits/stdc++.h  -------     万能头文件</li>
</ul>
<div class="arithmatex">\[
S_i
\]</div>
<h2 id="stl">STL<a class="headerlink" href="#stl" title="Permanent link">¶</a></h2>
<ul>
<li><code>vector</code>（变长数组），倍增的思想，支持比较运算（按字典序）
    定义：：
          <code>vector &lt;int&gt; a</code>; 定义：一个vector数组a
          <code>vector &lt;int&gt; a(10)</code>; 定义：一个长度为10的vector数组a
          <code>vector &lt;int&gt; a(10,3)</code>; 定义：一个长度为10的vector数组a，并且所有元素都为3
      <strong>常用函数</strong>：：
          size(); 返回元素个数  O(1)
          empty(); 返回是否是空  O(1)
          clear(); 清空
          front(); 返回vector的第一个数
          back(); 返回vector的最后一个数
          push_back(); 向vector的最后插入一个数
          pop_back(); 把vector的最后一个数删掉
          begin(); vector的第0个数
          end(); vector的最后一个的数的后面一个数
      <strong>倍增的思想</strong>：    </li>
</ul>
<p>​         操作系统为某一进程分配空间时所花费的时间与空间大小无关，而与申请的次数有关。</p>
<p>​         ************************************</p>
<p>​    <strong>遍历方法</strong>
  ​        假设有个vector <int> a;</int></p>
<p>​     a.begin() = a[0],   a.end() = a[s.size()]</p>
<p>​        第一种</p>
<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">     </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span>
</code></pre></div>
<p>​        第二种</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span><span class="w">  </span>
<span class="c1">//vector &lt;int&gt;::iterator可以写为auto</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span><span class="w">  </span>
</code></pre></div>
<p>​        第三种       </p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span>
</code></pre></div>
<p>​       <strong>支持比较运算</strong></p>
<p>​                   按字典序比较，从第一个值开始比较，如果当前值小于则小于，如果等于则比较下一位</p>
<ul>
<li><code>pair</code>，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）
      定义：：</li>
</ul>
<p>​        pair &lt;类型,类型&gt; 变量名; 存储一个二元组    两个类型可以不同
  ​    初始化方式：
  ​        假设有个pair <int,string> p;
  ​        第一种        </int,string></p>
<div class="highlight"><pre><span></span><code><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_pair</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="s">"abc"</span><span class="p">);</span>
</code></pre></div>
<p>​        第二种         </p>
<div class="highlight"><pre><span></span><code><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="s">"abc"</span><span class="p">);</span>
</code></pre></div>
<p>​     也可以用pair存两个以上的不同类型的值</p>
<div class="highlight"><pre><span></span><code><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
</code></pre></div>
<p>常用函数：：
          first(); 第一个元素
          second(); 第二个元素</p>
<ul>
<li><code>string</code>（字符串）
      常用函数：：
          substr(); 返回某一个子串
          c_str(); 返回string对应的字符数组的头指针
          size(); 返回字母个数
          length(); 返回字母个数
          empty(); 返回字符串是否为空
          clear(); 把字符串清空</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">string</span><span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"sgl"</span><span class="p">;</span>

<span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="err">'</span><span class="n">def</span><span class="err">'</span><span class="p">;</span>

<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>

<span class="c1">// printf无法直接输出string，依靠string头指针来进行输出</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</code></pre></div>
<ul>
<li><code>queue</code>（队列）队尾插入队头弹出
      定义：：
          queue &lt;类型&gt; 变量名;
      常用函数：：
          size(); 这个队列的长度
          empty(); 返回这个队列是否为空
          push(); 往队尾插入一个元素
          front(); 返回队头元素
          back(); 返回队尾元素
          pop(); 把队头弹出
          注意：队列没有clear函数！！！
      清空queue：     </li>
</ul>
<div class="highlight"><pre><span></span><code>变量名 = queue &lt;int&gt; ();
</code></pre></div>
<ul>
<li><code>priority_queue</code>（优先队列，是一个堆）
      注意：默认是大根堆！！！
      定义：：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">        </span><span class="n">大根堆</span><span class="err">：</span><span class="n">priority_queue</span><span class="w"> </span><span class="o">&lt;</span><span class="n">类型</span><span class="o">&gt;</span><span class="w"> </span><span class="n">变量名</span><span class="p">;</span>
<span class="w">        </span><span class="n">小根堆</span><span class="err">：</span><span class="n">priority_queue</span><span class="w"> </span><span class="o">&lt;</span><span class="n">类型</span><span class="p">,</span><span class="n">vecotr</span><span class="w"> </span><span class="o">&lt;</span><span class="n">类型</span><span class="o">&gt;</span><span class="p">,</span><span class="n">greater</span><span class="w"> </span><span class="o">&lt;</span><span class="n">类型</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">变量名</span>
</code></pre></div>
<p>​    常用函数：
  ​        size(); 这个堆的长度
  ​        empty(); 返回这个堆是否为空
  ​        push();往堆里插入一个元素
  ​        top(); 返回堆顶元素
  ​        pop(); 弹出堆顶元素
  ​        注意：堆没有clear函数！！！</p>
<p><code>stack</code>（栈）
    常用函数：
        size(); 这个栈的长度
        empty(); 返回这个栈是否为空
        push(); 向栈顶插入一个元素
        top(); 返回栈顶元素
        pop(); 弹出栈顶元素</p>
<p><code>deque</code>（双端队列）队头队尾都可以插入删除，支持随机访问
    常用函数：
        size(); 这个双端队列的长度
        empty(); 返回这个双端队列是否为空
        clear(); 清空这个双端队列
        front(); 返回第一个元素
        back(); 返回最后一个元素
        push_back(); 向最后插入一个元素
        pop_back(); 弹出最后一个元素
        push_front(); 向队首插入一个元素
        pop_front(); 弹出第一个元素
        begin(); 双端队列的第0个数
        end(); 双端队列的最后一个的数的后面一个数</p>
<p>​       [] 类似数组</p>
<p><code>set</code>，<code>map</code>，<code>multiset</code>，<code>multimap</code> 基于平衡二叉树（红黑树：一种平衡二叉树），动态维护<strong>有序序列</strong>
<code>set/multiset</code>
        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！
        常用函数：
            size(); 返回元素个数
            empty(); 返回set是否是空的
            clear(); 清空
            begin(); 第0个数，支持++或--，返回前驱和后继
            end(); 最后一个的数的后面一个数，支持++或--，返回前驱和后继
            insert(); 插入一个数
            find(); 查找一个数
            count(); 返回某一个数的个数
            erase();
                （1）输入是一个数x，删除所有x    O(k + log n)      k是x的个数
                （2）输入一个迭代器，删除这个迭代器
            lower_bound(x); 返回大于等于x的最小的数的迭代器
            upper_bound(x); 返回大于x的最小的数的迭代器
    <code>map/multimap</code>  类似python字典
        常用函数：
            insert(); 插入一个数，插入的数是一个pair
            erase(); 
                （1）输入是pair
                （2）输入一个迭代器，删除这个迭代器
            find(); 查找一个数
            lower_bound(x); 返回大于等于x的最小的数的迭代器
            upper_bound(x); 返回大于x的最小的数的迭代器</p>
<p>​           [] 数组类似，但是是O(logn) 增删改查都是O(logn)</p>
<p><code>unordered_set</code>，<code>unordered_map</code>，<code>unordered_muliset</code>, <code>unordered_multimap</code> 基于哈希表实现
    和上面类似，增删改查的时间复杂度是O(1)
    不支持lower_bound()和upper_bound()，迭代器++--；；；；；；凡是和排序有关的操作都不支持</p>
<p><code>bitset</code> 压位</p>
<p>​   可以将一字节的大小存储在1bit中，即可以把内存大小减少为原来的1/8</p>
<p>​    定义：
​        bitset &lt;个数&gt; 变量名;
​    支持：
​        ~，&amp;，|，^
​        &gt;&gt;，&lt;&lt;
​        ==，!=
​        []
​    常用函数：
​        count(); 返回有多少个1
​        any(); 判断是否至少有一个1
​        none(); 判断是否全为0
​        set(); 把所有位置赋值为1
​        set(k,v); 将第k位变成v
​        reset(); 把所有位变成0
​        flip(); 把所有位取反，等价于~
​        flip(k); 把第k位取反</p>
<aside class="md-source-file">
<span class="md-source-file__fact">
<span class="md-icon" title="最后更新">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime">2024年7月31日 19:03:10</span>
</span>
<span class="md-source-file__fact">
<span class="md-icon" title="创建日期">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime">2024年7月28日 15:10:46</span>
</span>
</aside>
<h2 id="__comments">评论</h2>
<!-- Insert generated snippet here -->
<script async="" crossorigin="anonymous" data-category="Announcements" data-category-id="DIC_kwDOIVXFKs4CSVPj" data-emit-metadata="0" data-input-position="top" data-lang="zh-CN" data-mapping="pathname" data-reactions-enabled="1" data-repo="IsshikiHugh/notebook" data-repo-id="R_kgDOIVXFKg" data-strict="0" data-theme="light" src="https://giscus.app/client.js">
</script>
<!-- Synchronize Giscus theme with palette -->
<script>
    var giscus = document.querySelector("script[src*=giscus]")

    /* Set palette on initial load */
    var palette = __md_get("__palette")
    if (palette && typeof palette.color === "object") {
      var theme = "light"
      giscus.setAttribute("data-theme", theme) 
    }

    /* Register event handlers after documented loaded */
    document.addEventListener("DOMContentLoaded", function() {
      var ref = document.querySelector("[data-md-component=palette]")
      ref.addEventListener("change", function() {
        var palette = __md_get("__palette")
        if (palette && typeof palette.color === "object") {
          var theme = "light"

          /* Instruct Giscus to change theme */
          var frame = document.querySelector(".giscus-frame")
          frame.contentWindow.postMessage(
            { giscus: { setConfig: { theme } } },
            "https://giscus.app"
          )
        }
      })
    })
  </script>
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
<button class="md-top md-icon" data-md-component="top" hidden="" type="button">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"></path></svg>
  回到页面顶部
</button>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.annotate", "content.code.copy", "navigation.tracking", "navigation.tabs", "navigation.indexes", "navigation.top", "search.highlight", "search.share"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
<script src="../../../assets/javascripts/bundle.fe8b6f2b.min.js"></script>
<script src="../../../_js/extra.js"></script>
<script src="../../../_js/katex.js"></script>
<script src="https://jsd.cdn.zzko.cn/npm/katex@0.16.4/dist/katex.min.js"></script>
<script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>