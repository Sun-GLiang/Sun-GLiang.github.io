# 数据结构

## 第5章 树🌳

### 二叉树

**二叉树和度为2的树**

- 度为2的树至少有3个结点，而二叉树可以为空

- 度为2的有序树的孩子的左右次序是相对于另一个孩子而言，若只有一个孩子，则无需区分左右；而二叉树，无论有一个还是两个孩子，都需要区分左右


**性质**

- 非空二叉树叶结点数等于度为2的结点数加1，即n_0=n_2+1

- 对于完全二叉树，结点i所在的深度为\lfloor log_2^i \rfloor + 1

- 具有n个结点的完全二叉树的高度为\lceil log_2^{n+1} \rceil 或 \lfloor log_2^n \rfloor + 1

- 在含有n个结点的二叉链表中，含有n+1个空链域（与线索链表有关）





### 二叉树的遍历

- 中序遍历 + 其他三种遍历中任何一个 ->  可以唯一确定一颗二叉树

- 而其他三种遍历任意组合，却无法唯一确定一颗二叉树


**后序遍历**

后序遍历访问一个结点P时，从栈底到栈顶，再加上P结点，刚好构成了从根节点到P结点的一条**路径**
> 可以用来求根到结点的路径、两个结点的最近公共祖先


**线索二叉树**

- 后序线索二叉树中，找结点x的后继时，需要知道结点双亲，即需要采用带标志域的三叉链表作为存储结构
    - 若结点x是二叉树的根，则后继为空
    - 若x是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继为双亲
    - 若结点x是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点


### 森林

**存储结构**

- 双亲表示法：连续存储空间来存储每一个结点，在每个结点中设置一个伪指针，指向其双亲结点的数组下标
    > 可以很快得到结点的双亲，但是求孩子得遍历整个结构

- 孩子表示法：连续存储空间来存储每一个结点，在每个结点中设置一个伪指针，指向每个结点的孩子结点构成的链表
    > 找孩子方便，找双亲不方便

- 孩子兄弟表示法（二叉树表示法）：n+1个空链域


**森林的遍历**

| 树       | 森林     | 二叉树   |
| -------- | -------- | -------- |
| 先根遍历 | 先序遍历 | 先序遍历 |
| 后根遍历 | 中序遍历 | 中序遍历 |


### 哈夫曼树

- 哈夫曼树也叫最优二叉树

- n个权值构成的哈夫曼树共有2n-1个结点

- 哈夫曼树中不存在度为1的结点

- 哈夫曼树构造哈夫曼编码（编码不唯一，但带权路径长度唯一），可以设计出总长度最短的二进制前缀编码：频率越高的字符，编码越短


### 并查集

- 采用双亲表示法存储，每个数组元素表明该元素双亲结点的信息，若该数组元素为祖宗节点，则显示其孩子及自身的所有数量

- <font color="red">对于状态压缩、时间复杂度具体看书上的笔记</font>







## 第6章 图

- 线性表、树都可以为空，但是图中，结点必须不能为空，边可以为空

### 图的存储

1. 邻接矩阵
    - 适合存储稠密图
    - 用一维数组存储顶点信息，二维数组存储每对顶点之间的边
    - 无向图的邻接矩阵是对称矩阵，实际存储时，只需要存储上（或下）三角矩阵
    - 遍历对应行、列的时间复杂度为O(V)
    - 删除边很方便，删除点不方便

2. 邻接表
    - 适合存储稀疏图
    - 找有向图的入度必须遍历整个邻接表

3. 十字链表
    - 有向图的链式存储
    - 表示不唯一
    - 既容易找到V_i为尾的弧，也容易找到V_i为头的弧，因而容易求得顶点的入度和出度

4. 临界多重表
    - 无向图的链式存储


### 图的遍历

- 图的遍历算法可以用来判断图的连通性

**广度优先搜索BFS**

- Dijkstra单源最短路径算法和Prim最小生成树算法与广度优先搜索算法的思想类似

- BFS算法可以求解非带权图的单源最短路径算法
    > 最短路径是指边数最少的路径

- 广度优先生成树既是唯一的（图的邻接矩阵是唯一的），又是不唯一的（图的邻接表不是唯一的）


**深度优先搜索DFS**

- 对同一个图，基于邻接矩阵的遍历得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历得到的DFS和BFS序列不唯一

- 只有对深度连通图调用DFS才会产生深度优先生成树，否则产生深度优先森林

- 深度优先生成树既是唯一的（图的邻接矩阵是唯一的），又是不唯一的（图的邻接表不是唯一的）


### 图的应用


**最小生成树**

- 只能保证权值之和最小

- 图的不同的生成树，其对应的权值和也不一定相同

- 图中存在权值相同的边，则其最小生成树可能不唯一，即最小生成树的树形不唯一；图中各个权值互不相等，则唯一

*Prim算法*

- 从顶点开始扩充

- 适用于求解边稠密的图的最小生成树

- 时间复杂度O(V^2)，不依赖于E

*Kruskal算法*

- 从边开始扩充，按权值递增顺序

- 利用堆来存放边的集合，每次选择最小权值的边需要O(log2E)的时间；总的时间复杂度为O(Elog2E)

- 适用于边稀疏而顶点较多的图


**最短路径**

*单源最短路径Dijkstra算法*

- 求某一顶点到其他各个顶点的最短路径

- 可追溯最短路径

- Dijkstra算法和Prim算法
    - 均是贪心
    - Prim算法只适用于带权无向图，Dijkstra算法用于带权有向图和带权无向图
    - 时间复杂度不同

- Dijkstra算法不适用于带有负权值的边


*多源最短路径Floyd*

- 图中每一个顶点到其他顶点的最短路径均可得到（所有顶点之间的最短路径，对任意两个结点，求它们之间的最短路径）

- A^(k)[i][j]表示从顶点v_i到顶点v_j的路径长度，k表示绕行第k个顶点的运算步骤

- 每一轮选择一个中间结点作为中转点；第一轮以v_0为中转，第二轮以v_1为中转，...

- Flody算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路；适用于带权无向图


*BFS、Dijkstra、Flody算法求解最短路径比较*

|                | BFS            | Dijkstra       | Flody          |
| -------------- | -------------- | -------------- | -------------- |
| 用途           | 求单源最短路径 | 求单源最短路径 | 求单源最短路径 |
| 无权图         | 适用           | 适用           | 适用           |
| 带权图         | 不适用         | 适用           | 适用           |
| 带负权值的边   | 不适用         | 不适用         | 适用           |
| 带负权回路的边 | 不适用         | 不适用         | 不适用         |



**有向无环图**

- 有向图中不存在环，称为有向无环图，DAG图

- 描述含有公共子式的工具



**拓扑排序**

- 针对有向无环图而言

- 每个顶点只出现一次；若顶点A在排序中出现在B前面，则不存在从B到A的路径

- AOV网中存在*一个或多个*拓扑排序；AOV网中，边没有权值，仅表示相邻节点的先后顺序

- 求解拓扑排序时，若图中不存在无前驱的结点，则表示有向图中必然存在环

- 利用深度优先遍历也可以实现拓扑排序

- 对于一般的图，若其邻接矩阵是三角矩阵，则存在拓扑排序；否则，不一定


**关键路径**

<font color="red" size=20>实现算法还没有看</font>


- 只有加快那些包含在所有关键路径上的关键活动才能达到缩短工期的目的



## 第7章 查找

### 顺序查找

- 适用于顺序表或链表

- 可以按元素被查找到的概率从大到小进行排序，可以提高查找效率

- 查找成功ASL=(n+1)/2；查找失败ASL=(n+1)

- 对于有序线性表的顺序查找
    - 构造顺序查找判定树；若有n个结点，则有n+1个查找失败结点
    - 查找成功ASL=(n+1)/2 
    - 查找失败ASL=(1+2+...+n+n)/(n+1)=n/2+n/(n+1)
        > 失败结点是虚拟的，实际不存在，因此到达失败结点的查找长度为失败结点所在层的上一层
    
### 折半查找

- **仅适用于有序的顺序表**

- 取mid时，在同一个题中，向上取整和向下取整只能选一个进行

- 折半判定树，若有n个结点，则有n+1个失败结点
    - 判定树是一个平衡二叉树
    - 查找成功的查找长度为根节点到目的节点路径上的结点数
        > 查找成功ASL=查找长度求和/n
    - 查找失败的查找长度为根节点到对应失败结点的父节点的路径上的结点数
        > 查找失败ASL=查找长度求和/(n+1)

- 折半查找的比较次数最多不会超过树的高度
    > 树高为\lceil log_2 (n+1) \rceil

- 折半查找的时间复杂度为O(log2n)


### 分块查找（索引顺序查找）

- 若有n个记录，则将其分为sqrt(n)个块，每块都有sqrt(n)个记录，平均查找长度为sqrt(n)+1


### 二叉排序树（BST）

- 目的：提高查找、插入和删除关键字的速度

- 左子树的值均小于根节点，根节点均小于右子树的值；中序遍历的结果是一个递增序列

- 查找成功的查找长度为根节点到目的节点路径上的结点数（同折半查找法）
    > 查找成功ASL=查找长度求和/n

- 二分查找的判定树唯一，但是二叉排序树不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树

- 就维护表的有序性而言
    - 二叉排序树无需移动结点，只需要修改指针即可完成插入删除，平均执行时间为O(log2n)
    - 二分查找的对象是有序顺序表，若有插入和删除的操作，代价是O(n)

- 静态查找表，采用顺序表作为存储结构，使用二分查找实现操作
- 动态查找表，采用二叉排序树作为其逻辑结构

**二叉排序树的插入和*删除***



### 平衡二叉树（AVL树）

- 左右子树高度差为平衡因子，取值为-1，0，1

- AVL树可以为空树

**平衡二叉树的插入**

调整最小不平衡子树（以最小不平衡子树为基准进行调整）


**平衡二叉树的删除**

从被删除的结点开始向上回溯，找到第一个不平衡的结点，以这个结点为根，对这个树进行调整

**平衡二叉树的查找**

以n_h表示深度为h的平衡二叉树中含有的最少结点数。有n_0=0，n_1=1，n_2=2，且有递推关系n_h = n_{h-2} + n_{h-1} + 1

- 可用于求解给定结点数的平衡二叉树的查找所需的最多比较次数

- 含有n个结点的平衡二叉树的最大深度为O(log2n)，因此查找效率为O(log2n)























## 各种算法的时空间复杂度


| 应用                       | 时间复杂度                               | 空间复杂度                   |
| -------------------------- | ---------------------------------------- | ---------------------------- |
| **树**                     |
| 遍历二叉树（前、中、后序） | O(n)                                     | O(n)                         |
| **图存储**                 |
| 邻接矩阵                   |                                          | O(V^2)                       |
| 邻接表                     |                                          | 无向图O(V+E)，有向图O(V+2E)  |
| 十字链表或临界多重表       |                                          | O(V+E)                       |
| **图遍历**                 |
| BFS                        | 邻接表O(V+E)，邻接矩阵O(V^2)             | 最坏情况结点都需要入队列O(V) |
| DFS                        | 邻接表O(V+E)，邻接矩阵O(V^2)             | 递归工作栈O(V)               |
| **图的应用**               |
| Prim算法                   | 邻接矩阵O(V^2)                           |                              |
| Kruskal算法                | 邻接表O(Elog2E)                          |                              |
| Dijkstra算法               | 邻接矩阵O(V^2)                           |                              |
| Floyd算法                  | 邻接矩阵O(V^3)                           |                              |
| 拓扑排序                   | 邻接表O(V+E)，邻接矩阵O(V^2)             |                              |
| 关键路径                   | 邻接表O(V+E)，邻接矩阵O(V^2)             |                              |
| **查找**                   |
| 折半查找                   | O(log2n)                                 |                              |
| 二叉排序树                 | 若为平衡二叉树O(log2n)，若为单分支树O(n) |                              |