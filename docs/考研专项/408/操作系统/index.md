# 操作系统


## 第2章 进程、线程


### CPU调度

**调度**

1. 高级调度（作业调度）：从外存换到内存
2. 中级调度（内存调度）：从内存换到外存
    - 目的：提高内存利用率
    - 是存储系统中的*对换功能*：将暂时不能运行的进程调到外存等待，此时称为挂起态
3. 低级调度（进程调度）
    >在对就绪队列进行调度时，会发生两对上下文的切换
    >> 第一次：当前进程的上下文保存到其PCB中，再加载操作系统内核中调度程序的上下文，执行内核中的调度程序，选择下一个要运行的进程
    >> 第二次：保存内核调度程序的上下文，加载被调度进程的上下文（将其CPU信息装入CPU的各个寄存器中）



**进程相关知识**

0. 任一进程中所拥有的资源包括
    - 受到分别保护的用户地址空间
    - 用于实现进程间和线程间同步和通信的机制
    - 已打开的文件和已申请到的I/O设备
    - 一张由核心进程维护的地址映射表，该表用于实现用户程序的逻辑地址到其内存物理地址的映射

1. PCB 可以被操作系统中的多个模块读或修改，如被调度程序、资源分配程序、中断处理程序以及监督和分析程序等读或修改。
    > 当进程由于某种原因而暂停执行时，又须将其断点的处理机环境(由处理及中的各种寄存器组成)保存在PCB中。
    >> 包括通用寄存器、PC、PSW、用户栈指针

2. 原子操作在管态下执行，常驻内存

3. 引起创建进程的事件
    - 系统内核创建
        - 用户登录
        - 作业调度
        - 提供服务：eg：用户进程请求对文件进行打印，则系统内核为其创建一个打印进程，使得打印进程和用户进程并发执行
    - 用户创建（应用请求）：由用户自己创建新进程

4. 阻塞：系统往往设置一些具有某特定功能的系统进程，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来。例如，系统中的发送进程，其主要工作是发送数据，若已有的数据已全部发送完成而又无新的发送请求，这时(发送)进程将使自己进入阻塞状态；仅当又有进程提出新的发送请求时，才将发送进程唤醒。

5. 进程通信
    - 共享存储区
    - 消息传递：也应用于微内核系统中，微内核与服务器之间的通信
    - 管道通信

6. 对于通常的进程，无论是系统进程还是用户进程，进程的创建、  撤消，以及要求由系统设备完成的I/O 操作，都是**利用系统调用**而进入内核，再由内核中的相应处理程序予以完成的。进程的切换同样是在内核的支持下实现的。因此我们说，不论什么进程，它们都是在操作系统内核的支持下运行的，是与内核紧密相关的



**线程相关知识**

1. 线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可以与同属一个进程的其他线程共享进程所拥有的全部资源，并共享进程的地址空间
2. **一个线程可以创建和撤销另一个线程**
3. 线程可以访问其隶属进程的系统资源（属于同一进程的所有线程都具有相同的地址空间）
4. *不同的线程可以执行相同的程序*
5. 各个线程都可以访问进程地址空间中的每个单元，所以一个线程可以读、写，甚至清除另一个线程的堆栈
6. **线程可以访问进程所拥有的已打开文件、定时器、信号量机构
等**
7. 线程完成自己的任务后，或线程在运行中出现异常而被强制终止时，由于终止线程调用相应的函数执行终止操作。但是系统线程一旦被建立，就一直运行而不会终止。线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。为此，调用者线程须调用一条被称为“等待线程终止”的连接命令，来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。
8. 对于系统级线程，在有的系统中为了减少创建和撤消一个线程时的开销，在撤消一个线程时，并不立即回收该线程的资源和 TCB，当以后再要创建一个新线程时，便可直接利用已被撤消但仍保持有资源和TCB 的线程作为新线程







**父子进程**

- 子进程可以继承父进程所拥有的资源，例如，`继承父进程打开的文件，继承父进程所分配到的缓冲区等`。当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程。此外，在撤消父进程时，也必须同时撤消其所有的子进程。

- 由于父进程具有终止自己的任何子孙进程的权力，因而当父进程提出
请求时，系统将终止该进程



### 同步互斥PV操作  <font color="red" size=5> 频繁考点 </font>



**读者-写者问题** <font color="red"> 未看 </font>


**哲学家进餐** <font color="red"> 未看 </font>


**吸烟者问题** <font color="red"> 未看 </font>



**管程**

- 管程定义了系统中的共享数据结构资源与能对该数据结构进行操作的一组函数（P和V操作） 类似于私有类，其内部的资源访问只能通过函数来进行
    >组成
    >> 管程名称、共享数据结构、一组函数、对共享数据结构设置初值的语句

- 每次仅允许一个进程进入管程



### 死锁

- 多个进程因竞争资源（互相等待对方手里的资源）而造成的僵局，使各个进程都被阻塞

- 产生死锁的必要条件
    1. 互斥条件：如打印机这种资源
    2. 不可剥夺条件
    3. 请求与保持条件
    4. 循环等待条件
    > 死锁必然产生循环等待，而发生循环等待则不一定死锁（仅当同类资源数为1时，才是等价命题）



**死锁和饥饿的区别**

- 饥饿只涉及一个进程、死锁涉及多个进程（大于等于2个进程）

- >发生饥饿可能处于`就绪态`（长期得不到CPU，如SJF短作业调度算法），也可能发生在`阻塞态`（长期得不到I/O设备）
  
  > 但是死锁的进程必然处于阻塞态



**死锁处理策略**

- 死锁预防：破坏4个必要条件之一
    - 互斥条件
    - 不可剥夺条件
    - 请求与保持条件
        - 进程在运行前获得其所需的全部资源
        - 进程获得其初始运行需要的资源后，只有它释放完自己已占有的资源后，才可以申请新的资源
    - 循环等待条件：资源顺序分配法：进程只能按照资源序号递增的顺序申请资源

- 避免死锁：银行家算法
    - 安全状态一定不发生死锁；不安全状态可能发生死锁；死锁时一定处于不安全状态

- 死锁的检测及解除：资源分配图
    - 死锁定理：发生死锁当且仅当资源分配图是不可简化的




## 第3章 内存管理





## 第4章 文件系统




## 第5章 I/O管理





