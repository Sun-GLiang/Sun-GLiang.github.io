# 操作系统

## 第1章 计算机系统概述

- 操作系统向用户提供命令接口和系统调用（程序接口），此外还提供图形接口（调用了系统调用而实现的功能）
  > 按命令控制方式的不同，命令接口又分为联机用户接口和脱机用户接口

  > 库函数是是高级语言中提供的与系统调用对应的函数（也存在一些库函数，与系统调用无关），但是库函数属于用户程序而非系统调用
- 通用操作系统中，使用时间片轮转调度算法，
  > 执行用户程序不需要预定执行时间，但是需要确定其实地址，从起始地址开始执行
- 批处理OS的主要缺点是缺少交互性
- 外部中断 是由**CPU外部**的事件引起的，如：I/O设备的请求、时钟信号等；内部中断（异常）是由**CPU内部**的事件引起的（即与程序的执行过程有关），如：陷入指令、缺页异常等
- 中断
  - 用户进程的上下文被内核的中断程序保存起来（上下文保存到了自己的0特权级栈），开始执行一段内核中的代码
  - PC、PSW的值由硬件保存（中断隐指令）
  - 现场信息（通用寄存器值）和中断屏蔽字由操作系统保存
  - TLB、Cache值由硬件机构保存


**系统调用命令**

- 过程：
  1. 向正在运行的进程传递系统调用参数
  2. 执行trap指令，用户态->内核态，将返回地址压入堆栈
  3. CPU执行内核态服务程序
  4. 返回用户态
- **系统调用是面向硬件的**，运行在内核态；
- 系统调用是由用户发起，请求操作系统服务的；
- 用户在*用户态*下使用系统调用命令，该命令经过编译后，形成若干参数和*陷入命令*（系统调用需要出发陷入指令）；
  > 用户程序在用户态下使用特权指令会引起访管中断（陷入中断），即用户程序通过一条陷入指令，将运行在用户态的CPU切换到内核态（硬件CPU实现切换），以请求操作系统内核提供服务；
- 用户程序通过系统调用进行进程控制，用户程序创建一个新进程，需要使用操作系统提供的系统调用接口；
- 执行系统调用时，通过*中断*，由用户态到内核态；系统调用返回后，继续执行用户程序，CPU状态由内核态到用户态；
- 在中断发生时后，进入中断处理的程序是操作系统程序（被中断的程序可能是用户程序也可能是内核程序）；
- 不同的操作系统提供的系统调用接口是不一样的；
- 创建新进程（fork指令）通过系统调用实现
  > 而页面置换、进程调度都是完全由操作系统完成的；

**系统调用和一般过程调用**
- 系统调用需要保存PSW和PC；
- 一般过程调用只需要保存PC；（因为子程序调用不改变程序的状态，即标志位不变；正是因为标志位发生了变化，因此子程序才被顺利调用，在返回被调用程序后，该标志位也就没有用了）
- 系统调用的被调用过程是操作系统中的程序；
- 一般过程调用的被调用程序与调用程序运行在**同一个状态**，可能是内核态，也可能是用户态；


**内核态、用户态**

- 用户态和内核态是针对CPU来讲的，是指CPU运行在用户态（特权3级）还是内核态（特权0级）；

- read系统调用、中断（内外中断）、系统调用、除0、软中断（触发一个中断并跳转到相应的中断处理程序）、访存（可能出现的缺页），使得由用户态切换到内核态

- 在内核态执行（是否需要访问特权资源【如直接操作**硬件**、修改系统表、**内核数据结构**等】，是否需要管理硬件资源和进程状态）
  - 有关对I/O设备操作的指令、有关访问程序状态的指令
  - 输入输出指令（涉及中断）
  - I/O指令
  - 系统调用（发生在用户态，执行在内核态）
  - 关中断指令
  - 屏蔽中断指令
  - 设置时钟指令
  - 停机指令
  - 修改页表
  - 缺页处理程序（在用户态发生缺页中断，进入内核态执行中断处理程序）
  - 修改中断向量
  - 磁盘调度程序
  - 中断处理程序（外部中断发生在用户态，在内核态执行中断处理程序）
  - 进程调度程序
  - 系统调用命令
  - 时钟中断处理程序
  - 文件I/O
  - 进程切换
  - 关中断指令



- 在用户态执行（考虑是否可以由汇编语言实现）
  - 修改内存单元的值（进程只能访问自己的用户空间）
  - 读时钟指令
  - 内存取数指令、将数据装入内存
  - 寄存器清零
  - 命令解释程序
  - trap指令
  - 压栈指令
  - 跳转指令
  - 数据传送
  - 设置断点



**操作系统设计**

- 层次结构操作系统中，每个层次都可以访问**相邻的高层或低层**，但是不能跨越多个层次
- 层次结构设计困难
- 模块化操作系统各个功能模块都在内核中，模块之间相互调用、相互依赖，任何一个模块出错，都会导致整个系统崩溃
- 放在微内核中的操作
  - 进程通信机制
  - 低级I/O
  - 低级进程管理和调度
  - 中断和陷入处理
- 拥有外核的操作系统中，外核只负责硬件资源的分配、回收、保护等，进程管理的工作仍由内核负责
- **引导程序**
  1. 一种是位于ROM中的自举程序（BIOS的组成部分），用于**启动具体的设备**
  2. 一种是位于装有操作系统硬盘的活动分区的引导扇区中的引导程序，用于**引导操作系统**
- 计算机启动过程
  1. CPU加电，PC指向FFFF0H地址
  2. 执行JMP指令跳转到BIOS（存放在主板中ROM的一段程序）
  3. 登记BIOS中断程序的入口地址（BIOS程序在内存最开始的空间构建中断向量表和相应的服务程序，后续的POST（通电自检）需要用到中断调试等功能）
  4. 硬件自检
  5. BIOS开始读取Boot Sequence（通过CMOS里保存的启动顺序或与用户交互的方式），查找引导设备
  > 将控制权交给启动顺序排在第一位的存储设备，然后CPU将该存储设备引导扇区的内容加载到内存（若该存储设备为不可引导的，则检查下一个设备，直至找到引导盘）；
  6. 把引导盘的0号扇区调入到内存，即MBR（主引导记录：分为磁盘引导程序和硬盘分区表），由MBR检查分区表，查找活动分区
  7. MBR再将控制权转交给该活动分区的引导扇区（即，PBR：分区引导记录），PBR加载到内存
  8. PBR寻找并激活活动分区根目录下用于引导操作系统的程序（管理器），加载启动管理器
  9.  将操作系统的初始化程序加载到内存中执行（常驻内存的只是操作系统的内核，其他部分仅在需要时才调入）
- 






















## 第2章 进程、线程


### CPU调度

**调度**

1. 高级调度（作业调度）：从外存换到内存
2. 中级调度（内存调度）：从内存换到外存
    - 目的：提高内存利用率
    - 是存储系统中的*对换功能*：将暂时不能运行的进程调到外存等待，此时称为挂起态
3. 低级调度（进程调度）
    >在对就绪队列进行调度时，会发生两对上下文的切换
    >> 第一次：当前进程的上下文保存到其PCB中，再加载操作系统内核中调度程序的上下文，执行内核中的调度程序，选择下一个要运行的进程
    >> 第二次：保存内核调度程序的上下文，加载被调度进程的上下文（将其CPU信息装入CPU的各个寄存器中）



**进程相关知识**

0. 任一进程中所拥有的资源包括
    - 受到分别保护的用户地址空间
    - 用于实现进程间和线程间同步和通信的机制
    - 已打开的文件和已申请到的I/O设备
    - 一张由核心进程维护的地址映射表，该表用于实现用户程序的逻辑地址到其内存物理地址的映射

1. PCB 可以被操作系统中的多个模块读或修改，如被调度程序、资源分配程序、中断处理程序以及监督和分析程序等读或修改。
    > 当进程由于某种原因而暂停执行时，又须将其断点的处理机环境(由处理及中的各种寄存器组成)保存在PCB中。
    >> 包括通用寄存器、PC、PSW、用户栈指针

2. 原子操作在管态下执行，常驻内存

3. 引起创建进程的事件
    - 系统内核创建
        - 用户登录
        - 作业调度
        - 提供服务：eg：用户进程请求对文件进行打印，则系统内核为其创建一个打印进程，使得打印进程和用户进程并发执行
    - 用户创建（应用请求）：由用户自己创建新进程

4. 阻塞：系统往往设置一些具有某特定功能的系统进程，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来。例如，系统中的发送进程，其主要工作是发送数据，若已有的数据已全部发送完成而又无新的发送请求，这时(发送)进程将使自己进入阻塞状态；仅当又有进程提出新的发送请求时，才将发送进程唤醒。

5. 进程通信
    - 共享存储区
    - 消息传递：也应用于微内核系统中，微内核与服务器之间的通信
    - 管道通信

6. 对于通常的进程，无论是系统进程还是用户进程，进程的创建、  撤消，以及要求由系统设备完成的I/O 操作，都是**利用系统调用**而进入内核，再由内核中的相应处理程序予以完成的。进程的切换同样是在内核的支持下实现的。因此我们说，不论什么进程，它们都是在操作系统内核的支持下运行的，是与内核紧密相关的



**线程相关知识**

1. 线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可以与同属一个进程的其他线程共享进程所拥有的全部资源，并共享进程的地址空间
2. **一个线程可以创建和撤销另一个线程**
3. 线程可以访问其隶属进程的系统资源（属于同一进程的所有线程都具有相同的地址空间）
4. *不同的线程可以执行相同的程序*
5. 各个线程都可以访问进程地址空间中的每个单元，所以一个线程可以读、写，甚至清除另一个线程的堆栈
6. **线程可以访问进程所拥有的已打开文件、定时器、信号量机构
等**
7. 线程完成自己的任务后，或线程在运行中出现异常而被强制终止时，由于终止线程调用相应的函数执行终止操作。但是系统线程一旦被建立，就一直运行而不会终止。线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。为此，调用者线程须调用一条被称为“等待线程终止”的连接命令，来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。
8. 对于系统级线程，在有的系统中为了减少创建和撤消一个线程时的开销，在撤消一个线程时，并不立即回收该线程的资源和 TCB，当以后再要创建一个新线程时，便可直接利用已被撤消但仍保持有资源和TCB 的线程作为新线程







**父子进程**

- 子进程可以继承父进程所拥有的资源，例如，`继承父进程打开的文件，继承父进程所分配到的缓冲区等`。当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程。此外，在撤消父进程时，也必须同时撤消其所有的子进程。

- 由于父进程具有终止自己的任何子孙进程的权力，因而当父进程提出
请求时，系统将终止该进程



### 同步互斥PV操作  <font color="red" size=5> 频繁考点 </font>



**读者-写者问题** <font color="red"> 未看 </font>


**哲学家进餐** <font color="red"> 未看 </font>


**吸烟者问题** <font color="red"> 未看 </font>



**管程**

- 管程定义了系统中的共享数据结构资源与能对该数据结构进行操作的一组函数（P和V操作） 类似于私有类，其内部的资源访问只能通过函数来进行
    >组成
    >> 管程名称、共享数据结构、一组函数、对共享数据结构设置初值的语句

- 每次仅允许一个进程进入管程



### 死锁

- 多个进程因竞争资源（互相等待对方手里的资源）而造成的僵局，使各个进程都被阻塞

- 产生死锁的必要条件
    1. 互斥条件：如打印机这种资源
    2. 不可剥夺条件
    3. 请求与保持条件
    4. 循环等待条件
    > 死锁必然产生循环等待，而发生循环等待则不一定死锁（仅当同类资源数为1时，才是等价命题）



**死锁和饥饿的区别**

- 饥饿只涉及一个进程、死锁涉及多个进程（大于等于2个进程）

- >发生饥饿可能处于`就绪态`（长期得不到CPU，如SJF短作业调度算法），也可能发生在`阻塞态`（长期得不到I/O设备）
  
  > 但是死锁的进程必然处于阻塞态



**死锁处理策略**

- 死锁预防：破坏4个必要条件之一
    - 互斥条件
    - 不可剥夺条件
    - 请求与保持条件
        - 进程在运行前获得其所需的全部资源
        - 进程获得其初始运行需要的资源后，只有它释放完自己已占有的资源后，才可以申请新的资源
    - 循环等待条件：资源顺序分配法：进程只能按照资源序号递增的顺序申请资源

- 避免死锁：银行家算法
    - 安全状态一定不发生死锁；不安全状态可能发生死锁；死锁时一定处于不安全状态

- 死锁的检测及解除：资源分配图
    - 死锁定理：发生死锁当且仅当资源分配图是不可简化的




## 第3章 内存管理

- 在固定分区分配中，每个分区的大小*可以不同也可以不同但是要预先固定，一旦预定就不能改变*，每个分区的大小在系统启动时就确定了的，不会随着作业的长度而变化
- 对比
  1. 静态装入：在编程阶段就把物理地址计算好
  2. 可重定位（静态重定位）：在装入时把逻辑地址变为物理地址，但是装入后不能改变，分配其要求的全部内存空间
  3. 动态重定位：执行时再决定装入的地址并装入，装入后可能会换出，因此同一模块在内存中的物理地址可能改变。当执行到一条访存指令时，再通过地址变换机构进行地址变换
  4. 页式、段式、段页式都是动态重定位的
  > 动态重定位的过程依赖于：可重定位装入程序、重定位寄存器、地址变换机构
- 在段式存储管理中，共享段表是用来实现**多个进程共享同一段代码或数据**
  - 共享段表工作流程：
    1. 两个矩形，分别标记为"进程A的段表"和"进程B的段表"
    2. 在这两个矩形中，各有多个条目（用小方格表示），其中有一个条目特别标注，指向同一个地方
    3. 一个标记为"共享段表"的矩形，里面也有多个条目
    4. 从"进程A的段表"和"进程B的段表"中的特别标注的条目，画箭头指向"共享段表"中的同一个条目
    5. 从"共享段表"中的这个条目，再画一个箭头指向一个标记为"物理内存"的大矩形
    6. 在"物理内存"矩形中，标出一个区域作为共享段。
  - 有些段可被多个进程共享，则可用一个单独的共享段表来描述这些段，不需要在每个进程的段表中都保存一份；
  - 共享段表实现了多个进程共享同一段代码或数据；
  - 多个进程共享同一段物理内存空间并不需要用到共享段表，只需要在各自的段表中指向相同的物理地址即可；
  - 在段式存储中，不要求各个进程中相同功能的段必须有相同的段号
- 页表和段表也在内存空间中。系统提供给用户的物理地址空间=总空间-页表或段表长度
- 页式存储中，CPU将虚拟地址分为页号和偏移量，后通过硬件中的页表寄存器和内存管理单元（MMU），将页号->物理地址，再拼接偏移量，得到最终的物理地址
- 分段存储
  - 有利于程序的动态链接
  - 方便编程
  - 分段共享
  - 分段保护
  - 动态增长
  - 段是可变长的、分段方式对低级语言程序运和编译器不是透明的
- 逻辑地址也叫相对地址
- 对主存的**访问**，以**字节或字**为单位；对主存的**分配**，以**块/页**为单位
  > 例如，在页式存储中，不仅要知道块号，也需要知道页内偏移量来得到字节或字
- 段页式中，系统为每个进程分配一个段表，**每个段又有一张页表**
- 程序是否发生越界，**由硬件检查**，与所用的存储方式无关（分页、分段...<br/>
- | 一级页表（页目录号） | 二级页表（页号） | 页内偏移量 |
- 页表基址寄存器中存放的是当前进程的一级页表的起始物理地址





















## 第4章 文件系统




## 第5章 I/O管理





