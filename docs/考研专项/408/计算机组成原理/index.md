# 计算机组成原理

* 明确主存的编址方式：按字节、按半字、还是按字


## 第2章 机器数、浮点数

**计算机标志位**

- 无符号数A与B做差
    - ZF = 1时，说明A = B
    - ZF = 0 & CF=0，A > B
    - CF = 1时，A < B
    ![alt text](./imgs/0.png)

- 有符号数A与B做差
    - OF = SF & ZF = 0，说明A > B
    - OF ≠ SF & ZF = 0，说明A < B
    - ZF = OF = 0 & SF = 1，说明A < B
    ![alt text](./imgs/1.png)

**定点乘法运算**

- 乘积的符号位由两个乘数的符号位异或得到
- 乘积的数值位是两个乘数的绝对值之和（看作无符号数）
- 两个n位无符号数相乘需要n次加法和n次移位运算（类比小学乘法步骤）

**定点除法运算**

- 跟乘法一样，不懂



## 第3章 存储系统


- 主存由RAM和ROM构成，两者统一编制
- 计算机的操作系统保存在硬盘上，所以需要BIOS的引导程序将操作系统引导到主存（RAM）中，而引导程序则固化于ROM中
- **固件**：将程序固化在ROM中组成的部件称为固件，是具有软件特性的硬件，其执行速度快于软件，灵活性优于硬件（操作系统已经实现了部分固化，将软件永恒地存储在ROM中）
- Cache由SRAM组成
- U盘采用Flash存储技术，是ROM的一种，但是不是随机存取的
- 芯片扩展所需片数：子扩展倍数*位扩展倍数
  > 芯片扩展不可能出现位数变小的情况
- 片选信号低电平有效：所有信号经过取交集后，若为0，则信号有效；否则，信号无效


**磁盘**

- RAID是将多个物理盘组成像单个逻辑盘
- **磁盘驱动器**
    - 磁盘地址由柱面号（磁道号）、盘面号（磁头号）、扇区号组成
    - 控制磁头移动到指定的磁道，并发回“寻道结束”信号
    - 控制磁盘片转过指定的扇区，并发回“扇区符合”信号
    - 控制对指定盘面的指定扇区进行数据的读或写操作
- 最小读写单位是**扇区**
- 采用直接存储器存取DMA方式进行输入输出
- 按批处理方式进行一个数据块的读写
- 磁盘存储器和主存交换信息，不能直接和CPU通话
- SSD的读写以页为单位，擦除以块为单位





**DRAM**

- 一次完整的刷新过程需要占用一个存储周期

- 地址线复用：地址线每增加1根，则行地址和列地址各增加1位，容量就提高到原来的4倍

- 对于大小为8192 x 8192 x 8bit的DRAM芯片，其行缓冲为8192 x 8bit，即列数*位平面

- DRAM芯片的刷新，只看DRAM芯片，不看其构成的存储器！！！
    - 构成存储器的所有芯片同时按行刷新，因此只需要看一个DRAM芯片的行数即可
    - 对于异步刷新，其相邻两次刷新信号的时间间隔为`刷新周期 / DRAM芯片行数`
    - 对于集中刷新，其刷新过程中，存储器不能进行读写，且刷新一行用时一个存储周期。故存储器刷新一遍最少用时`存储周期 * DRAM芯片的行数`
    - 刷新也是一个读取的过程，根据读出的内容对相应单元进行重写（**DRAM芯片刷新的原理**）。因此也会与CPU的访存发生冲突，影响到CPU的正常访存（会存在访存死时间）。

- SDRAM（同步DRAM）
    - DRAM芯片与CPU采用异步方式交换数据
    - SDRAM芯片与CPU采用同步方式交换数据
    - DRAM芯片和SDRAM芯片都需要定期刷新
    - SDRAM的行缓冲器（用来缓存指定行中整行的数据）通常用SRAM实现


### 多模块存储器

多模块存储器中，各模块有独立的读/写电路，可以实现并行操作，因此多模块存储器可以进行高速的读/写操作

**低位交叉编址多模块存储器**

- 低位交叉编址多模块存储器中，各单元的地址不连续
- 保证某个模块启动时，其上次操作已经完成（即要求两次启动间隔的时间要>=一个存储周期）---> 模块数 >= 存储周期/总线周期
- 理想情况下，认为存储器在每个总线周期都能给CPU提供一个字，即流水线充分流动起来后，每隔总线周期后都能完成一个字的读/写
- 对于n体多模块低位交叉存储器，若单个存储体的准备一个数据的时间（访问时间、存取时间）为T，则理想情况下（流水线充分流动后），平均每个数据的准备时间为T/n




**单体多字存储器**

- 主要解决访存速度的问题，可以提高存储器的吞吐率

- 在单体多字存储器中，每个存储单元存储多个字，当指令和数据连续存放，且没有过多的跳转指令时，单体多字存储器能有效提高主存的读写速度


### Cache

- cache完全由硬件实现
- cache替换时的单位是块（cache与主存是以块为单位进行数据交换的）
- cache地址空间和主存地址空间相互独立，通过**地址映射**把主存地址空间映射到cache地址空间
- 指令cache比数据cache有更好的空间局部性（指令大部分情况下都是顺序存放、顺序执行的）
- cache不命中时，先访问cache，再访问内存
- cache写不命中时
    - 回写法的写主存操作次数少于全写法
    - 写分配法：加载低一层的块到cache中，更新cache块（搭配回写法）
      - 写操作比较密集，采用回写法速度快，更适合访问密集型的应用
    - 非写分配法：避开cache，直接把字写到主存中（搭配全写法）
      - 全写法能够随时保持主存数据的一致性，适合安全性要求高的应用
- 对于由高速缓存、主存、硬盘构成的三级存储结构，CPU直接根据**主存物理地址**进行访问
  > 只有在虚拟存储器中，CPU发出的才是虚拟地址；CPU不能直接访问磁盘
- `第2593号存储单元`表示存储地址（主存地址）是2593
- 主存块或大或小，都会使cache的命中率降低


### 虚存

- 程序局部性原理的基本含义是指，在程序的执行过程中，程序对主存的访问是不均匀的
- 虚拟内存需要通过**操作系统**实现地址映射，因此虚存对系统程序员不是透明的；而应用程序员写程序使用的就是虚拟地址（逻辑地址），因此对其是透明的
- 虚拟存储器中，程序正在执行时，由**操作系统**完成地址映射，但需要一些硬件支持（由CPU中的MMU进行逻辑地址到物理地址的转换。转换过程中，MMU需要查对应的页表项，根据页表项的装入位（有效位）是否为1，来确定是否发生缺页
- 页表不命中，表示该页面没有调入主存，而cache是页面的副本，因此cache也一定不命中
- cache缺失处理由硬件完成；TLB缺失处理既可以由硬件完成也可以由软件完成
- 虚拟存储器的实际容量<=主存和辅存的容量之和
- 页表只能由操作系统和硬件进行访问，虚拟存储管理机制对用户**进程**来说是透明的；即用户进程不能访问其页表
- 分段方式对低级语言程序员和编译器来说是不透明的（低级语言程序员需要使用段号来编程，编译器需要通过段号来链接）
- ![](./imgs/4.jpg)
- cache和TLB都由SRAM组成










## 第4章 指令系统

??? note "机器字长32位，容量为16MB的存储器，CPU按半字寻址，寻址单元数为"
    问寻址单元数，不看虚拟内存，看物理内存<br></br>
    16MB，按2B寻址，则有$2^{23}$个存储单元，每个存储单元中存放2B    

!!! note "指令构成"
    操作码OP + （寻址方式） + 地址码

- 主存地址非负
- 零地址指令：空操作指令、停机指令、堆栈指令
- ISA（指令集体系结构）：是低级语言程序员能够看到的，对其不透明
    - 规定了基本数据类型、指令集、寄存器（个数和位数）、寻址模式、存储体系、中断和异常处理、外部I/O
    - 规定了执行每条指令时所需要的操作码、操作数、寻址方式、指令的功能和效果、指令格式和类型
- 控制信号是由控制单元生成的
- 对于堆栈指令的访存次数
    - 若软堆栈（堆栈区由内存实现），对于双目运算符需要访问4次内存：取指令、取操作数1、取操作数2、存结果
    - 若硬堆栈（堆栈区由寄存器实现），则只需要在取指令时访问1次内存即可
    - 
- 操作数的有效地址既可能是物理地址，也可能是虚拟地址。若采用虚拟存储机制，则有效地址就是虚拟地址，否则，有效地址就是物理地址
![alt text](./imgs/2.png)

- 寄存器寻址可以缩短指令中某个地址段的位数
- 偏移寻址
    - 基址寻址：逻辑地址->物理地址
    - 变址寻址：数组循环
    - 相对寻址：程序浮动、相对转移
    > 相对寻址中，指令提供的相对地址实际上是**以下一条指令在内存中的首地址为基准位置的偏移量**

- 移位指令
> 通常用一个`桶型移位器`实现一次移动多位的功能
> 对于移位操作，比如算术左移，可以将高位移出的那一位移入进位标志位。这样，可以通过判断符号标志和CF位是否相等来判断是否发生了溢出。同理，其他的移位操作也可以采用该方法。    
> >> 由于左移，数值扩大，可能产生溢出，因此，有些机器的左移指令也会使用OF溢出标
> 
> 半字交换：寄存器的前半部分和后半部分内容进行交换

- 跳步指令：跳过下一条指令
- 对于逻辑运算指令，通常只有零标志ZF才有意义

<center>

| 寻址方式       | 有效地址  | 访存次数 |
| -------------- | --------- | -------- |
| 立即寻址       | A即操作数 | 0        |
| 直接寻址       | EA=A      | 1        |
| 间接寻址       | EA=(A)    | 2        |
| 寄存器寻址     | EA=R      | 0        |
| 寄存器间接寻址 | EA=(R)    | 1        |
| 相对寻址       | EA=(PC)+A | 1        |
| 基址寻址       | EA=(BR)+A | 1        |
| 变址寻址       | EA=(IX)+A | 1        |

</center>



- CISC
    - 微程序控制
    - 指令种类多，难以编译优化，但是便于汇编程序员编程
    - 寄存器数量少
    - 指令多
- RICS
    - 硬布线控制器（组合逻辑控制）
    - 优化的编译程序
    - 寄存器数量多
    - 只有LOAD/STORE可以访问存储器，其余指令的操作均在寄存器间进行
    - 指令种类少
    - 流水线技术
    - RISC不可能兼容CISC






**MIPS**

- MIPS是按字节编址，指令字长32位。因此其一条指令占用4个字节（即4个存储单元），说明每一条指令的指令地址均为4的倍数。而二进制中4的倍数的二进制表示中，32位中的**最后两位始终为0**。
    > 因此处理器在计算下一条指令的地址时，只需要将当前地址的非00位加1即可
        >> 若为转移指令时，则对偏移量进行符号扩展，再乘以指令长度（指令长度为4字节），即新地址=当前地址非00位+1+偏移量符号扩展（此时不需要乘4了，因为已经没有加入最后两位，相当于已经达到了左移乘4的效果了）
    
    > 顺序执行时，PC<31:2> <--- PC<31:2> + 1
      转移执行时，PC<31:2> <--- PC<31:2> + 1 + 偏移量符号扩展
      取指令时，PC<31:2> <--- PC<31:2> 拼上 "00"
      无条件转移时（含有26位的目标地址），PC<31:2> <--- PC<31:28> 拼上 目标地址<25:0> 拼上"00"
    
    > 指令地址中最后两位始终为0，无需在指令中显示给出，只要在实现指令功能的数据通路中具有添加00的电路即可（地址压缩，省略传输这两位）

    > 对齐检查：如果指令地址的最后两位不是00，说明这个地址是错误的，或指令未对齐

- 每条指令只能处理一件事情，比如：a = i * 4 + 3
    > 要分两条指令进行
        >> 首先进行乘法（或移位或若干次加法）指令计算i * 4；再执行加法指令a = i * 4 + 3，得到结果

- **对数组进行循环**时，要先得到对应数组元素的地址（①）；再对该地址访存，获得对应的数据元素值（②）
    > 对于获得数组元素地址，计算方法为`基址 + 偏移量`，其中偏移量还要乘以编址单位

    > 执行完循环体内最后一条指令后，要执行一条无条件转移指令，转移到循环开始。（跳出循环在该方法中设置在了循环开始，即进行条件判断时设置的）

- **过程调用**

    1. 过程调用指令：
        - 保存下一条指令地址（返回地址）到寄存器；
        - 跳转到指定地址处执行过程（函数）
    
    2. 返回指令是无条件转移指令，跳转到返回地址

    3. **过程调用过程**
        ![alt text](./imgs/3.png)
        - 被调用程序Q先将其结果返回，再将控制权转交给调用程序P
        - 调用过程Q：
            - 计算（调用过程先使用临时寄存器，用完了再考虑使用保存寄存器（需要在栈帧中保存调用程序的现场））。若不需要使用保存寄存器，即无需保存任何寄存器的值（若同时也不需要分配任何局部变量，则栈帧为空）
            - 设置栈帧指针fp（当前栈指针sp+栈帧大小）
                - 返回地址存储在栈帧指针fp的上面一个单元
            - 返回结果
            - 清理释放Q所使用的资源（局部变量，存储在栈中），同样也就把P的环境恢复了（将P用到的寄存器中的值都恢复了）
            - 释放栈帧（即将栈指针sp指向栈帧指针fp）
            - 执行跳转指令，跳转到返回地址，返回控制权到P
        - 若被调用程序需要使用调用程序P所使用的保存寄存器，则需要将保存寄存器中的值保存到被调用过程的栈中，才能使用，并且在返回P之前恢复保存寄存器的值；P在临时寄存器中的值由P自行保存，Q不需对其进行保存
        - 若栈帧为空（无需保存任何寄存器的值、不需要分配任何局部变量或者分配了存储在寄存器的局部变量，即局部变量未存储在栈中），同时也不再调用其他过程，则无需保存返回地址和帧指针
        - 若栈帧不空，则需要保存返回地址和栈帧指针



















## 第5章 CPU

- 单总线数据通路和多总线数据通路都不适合指令流水线
    > 单总线系统的串行特性与流水线的并行本质相矛盾。
    
    > 多总线系统虽然提供了一定的并行能力,但复杂度和成本的增加可能抵消了性能gains。

    > 对于指令流水线，可以考虑指令存储器和数据存储器分离，并且各自使用独立的总线


**数据通路的基本结构**

- 组合逻辑单元：加法器(Adder)、算数逻辑部件（ALU）、三态门、译码器（Decoder）、多路选择器（MUX）
    > 组合逻辑单元不受时钟信号控制

- 时序逻辑单元：通用寄存器组（也叫寄存器堆）、PC、状态/移位/暂存/锁存寄存器
    > 时序逻辑单元受时钟信号控制
    
    > 对于通用寄存器组（也叫寄存器堆），读操作是组合逻辑操作，不受时钟信号的控制；写操作是时序逻辑操作，受到时钟信号控制

**数据通路和控制部件**

- CPU由数据通路和控制部件组成

- 数据通路：ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑
    > 数据通路中专门进行数据运算的部件称为执行部件或功能部件

- 控制部件：数据通路由控制部件进行控制


**ALU**

- 在多总线数据通路中，若将一个寄存器内容传送到另一个寄存器，则需要通过ALU来完成（ALU的直送功能）

- 多总线结构中，临时寄存器Y和Z都可以不要：这是因为ALU的输入通路分别为总线A和总线B，输出通路为总线C，三者无冲突；而单总线通路中，若缺少了Y或Z，则ALU的输入操作数和输出结果中必定有两个数据同时被送到同一个总线上，因而会发生总线数据冲突



**单周期处理器**

单周期处理器时钟周期取最复杂指令所用的指令周期，远远大于许多指令实际的执行时间，因而效率低下


**多周期处理器**

把每条指令的执行分为若干阶段，每个阶段执行用一个时钟周期，各阶段最多一次访存/寄存器读写/ALU操作

时钟周期宽度通常取一次存储器读写时间






















**硬件多线程**

硬件多线程为每个线程提供了单独的通用寄存器组、单独的PC，进程切换只需要选中寄存器、PC

1. 细粒度多线程：每个线程执行的指令是不相关的，可以乱序执行。处理器能之每个时钟周期切换线程`指令级并行`

2. 粗粒度多线程：可以连续几个时钟周期都执行同一线程的指令序列，仅当前线程出现了较大开销的阻塞时，才切换线程（如Cache缺失），线程切换占用一个时钟周期。新线程的指令在执行前需要重载流水线，开销比细粒度要大 `指令级并行`

3. 同时多线程：一个时钟周期中可以执行多个不同线程的多条指令 `线程级并行`


****






















## 第6章 总线



## 第7章 I/O

