<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ooopSok</title>
  
  <subtitle>Be Happy Every Day</subtitle>
  <link href="https://sun-gliang.github.io/atom.xml" rel="self"/>
  
  <link href="https://sun-gliang.github.io/"/>
  <updated>2023-04-05T09:40:14.515Z</updated>
  <id>https://sun-gliang.github.io/</id>
  
  <author>
    <name>ooopSok</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux命令总结</title>
    <link href="https://sun-gliang.github.io/post/linuxNote.html"/>
    <id>https://sun-gliang.github.io/post/linuxNote.html</id>
    <published>2023-04-04T09:05:24.000Z</published>
    <updated>2023-04-05T09:40:14.515Z</updated>
    
    <content type="html"><![CDATA[<hr><center>Linux基本命令的总结与笔记（方便查阅</center><hr><span id="more"></span><p><del>首先介绍的当然是提桶跑路的必杀技能，<code>rm /* -rf</code>啦（危</del></p><!-- <font face="黑体">黑体字</font><font face="微软雅黑">微软雅黑</font><font face="STCAIYUN">华文彩云</font><font color=blue>蓝色</font><font color=#008000>绿色</font><font color=Red>红色</font><font size=5>尺寸</font> --><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><ul><li><code>ctrl c</code>: 取消命令，并且换行</li><li><code>ctrl u</code>: 清空本行命令</li><li><code>cp XXX YYY</code>: 将XXX文件复制成YYY，XXX和YYY可以是一个路径</li><li><code>mkdir XXX</code>: 创建目录XXX</li><li><code>rm XXX</code>: 删除普通文件</li><li><code>rm XXX -r</code>: 删除文件夹</li><li><code>mv XXX YYY</code>: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；<strong>重命名</strong>也是用这个命令</li><li><code>touch</code>、<code>cat</code></li></ul><h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><p>tmux中复制&#x2F;粘贴文本的通用方式：</p><ol><li>按下Ctrl + a后松开手指，然后按[</li><li>用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</li><li>按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</li></ol><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><ul><li><code>n&lt;Space&gt;</code>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</li><li><code>0 或 功能键[Home]</code>：光标移动到本行开头</li><li><code>$ 或 功能键[End]</code>：光标移动到本行末尾</li><li><code>G</code>：光标移动到最后一行</li><li><code>:n 或 nG</code>：n为数字，光标移动到第n行</li><li><code>gg</code>：光标移动到第一行，相当于1G</li><li><code>n&lt;Enter&gt;</code>：n为数字，光标向下移动n行</li><li><code>/word</code>：向光标之下寻找第一个值为word的字符串。</li><li><code>?word</code>：向光标之上寻找第一个值为word的字符串。</li><li><code>n</code>：重复前一个查找操作</li><li><code>N</code>：反向重复前一个查找操作</li><li><code>:n1,n2s/word1/word2/g</code>：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</li><li><code>:1,$s/word1/word2/g</code>：将全文的word1替换为word2</li><li><code>:1,$s/word1/word2/gc</code>：将全文的word1替换为word2，且在替换前要求用户确认。</li><li><code>v</code>：选中文本</li><li><code>d</code>：删除选中的文本</li><li><code>dd</code>: 删除当前行</li><li><code>y</code>：复制选中的文本</li><li><code>yy</code>: 复制当前行</li><li><code>p</code>: 将复制的数据在光标的下一行&#x2F;下一个位置粘贴</li><li><code>u</code>：撤销</li><li><code>Ctrl + r</code>：取消撤销</li><li><code>大于号 &gt;</code>：将选中的文本整体向右缩进一次</li><li><code>小于号 &lt;</code>：将选中的文本整体向左缩进一次</li><li><code>:set paste</code> 设置成粘贴模式，取消代码自动缩进</li><li><code>:set nopaste</code> 取消粘贴模式，开启代码自动缩进</li><li><code>:set nu</code> 显示行号</li><li><code>:set nonu</code> 隐藏行号</li><li><code>gg=G</code>：将全文代码格式化</li><li><code>:noh</code> 关闭查找关键词高亮</li><li><code>Ctrl + q</code>：当vim卡死时，可以取消当前正在执行的命令</li></ul><h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>远程登录服务器：</p><ul><li><code>ssh user@hostname</code><br>user: 用户名<br>hostname: IP地址或域名</li><li>默认登录端口号为22。如果想登录某一特定端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@hostname -p 端口号</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>创建文件 <code>~/.ssh/config</code></p><p>然后在文件中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host myserver1</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line"></span><br><span class="line">Host myserver2</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><p>之后再次使用服务器时，可以直接使用别名myserver1、myserver2。</p><h2 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h2><p>创建密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>执行结束后，<code>~/.ssh/</code>目录下会多两个文件：<br>id_rsa：私钥<br>id_rsa.pub：公钥<br>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p><p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的<br><code>~/.ssh/authorized_keys</code>文件里即可。</p><p>也可以使用如下命令一键添加公钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id myserver</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="系统状况"><a href="#系统状况" class="headerlink" title="系统状况"></a>系统状况</h2><ul><li><code>top</code>：查看所有进程的信息（Linux的任务管理器）<ul><li>打开后，输入M：按使用内存排序</li><li>打开后，输入P：按使用CPU排序</li><li>打开后，输入q：退出</li></ul></li><li><code>df -h</code>：查看硬盘使用情况</li><li><code>free -h</code>：查看内存使用情况</li><li><code>du -sh</code>：查看当前目录占用的硬盘空间</li><li><code>ps aux</code>：查看所有进程</li><li><code>kill -9 pid</code>：杀死编号为pid的进程<ul><li>传递某个具体的信号：kill -s SIGTERM pid</li></ul></li><li><code>netstat -nt</code>：查看所有网络连接</li><li><code>w</code>：列出当前登陆的用户</li><li><code>ping www.baidu.com</code>：检查是否连网</li></ul><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><ul><li><code>chmod</code>：修改文件权限<ul><li><code>chmod +x xxx</code>：给xxx添加可执行权限</li><li><code>chmod -x xxx</code>：去掉xxx的可执行权限&#96;</li><li><code>chmod 777 xxx</code>：将xxx的权限改成777&#96;</li><li><code>chmod 777 xxx -R</code>：递归修改整个文件夹的权限</li></ul></li></ul><h2 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h2><ul><li><code>find /path/to/directory/ -name &#39;*.py&#39;</code>：搜索某个文件路径下的所有*.py文件</li><li><code>grep xxx</code>：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。</li><li><code>wc</code>：统计行数、单词数、字节数；既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；<ul><li><code>wc -l</code>：统计行数</li><li><code>wc -w</code>：统计单词数</li><li><code>wc -c</code>：统计字节数</li></ul></li><li><code>tree</code>：展示当前目录的文件结构<ul><li><code>tree /path/to/directory/</code>：展示某个目录的文件结构</li><li><code>tree -a</code>：展示隐藏文件</li></ul></li><li><code>ag xxx</code>：搜索当前目录下的所有文件，检索xxx字符串</li><li><code>cut</code>：分割一行内容<ul><li>从<code>stdin</code>中读入多行数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3,5</code>：输出PATH用:分割后第3、5列数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3-5</code>：输出PATH用:分割后第3-5列数据</li><li><code>echo $PATH | cut -c 3,5</code>：输出PATH的第3、5个字符</li><li><code>echo $PATH | cut -c 3-5</code>：输出PATH的第3-5个字符</li></ul></li><li><code>sort</code>：将每行内容按字典序排序<ul><li>可以从stdin中读取多行数据</li><li>可以从命令行参数中读取文件名列表</li></ul></li><li><code>xargs</code>：将stdin中的数据用空格或回车分割成命令行参数</li><li><code>find . -name &#39;*.py&#39; | xargs cat | wc -l</code>：统计当前目录下所有python文件的总行数</li></ul><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><ul><li><code>more</code>：浏览文件内容<ul><li>回车：下一行</li><li>空格：下一页</li><li><code>b</code>：上一页</li><li><code>q</code>：退出</li></ul></li><li><code>less</code>：与<code>more</code>类似，功能更全<ul><li>回车：下一行</li><li><code>y</code>：上一行</li><li><code>Page Down</code>：下一页</li><li><code>Page Up</code>：上一页</li><li><code>q</code>：退出</li></ul></li><li><code>head -3 xxx</code>：展示xxx的前3行内容<ul><li>同时支持从stdin读入内容</li></ul></li><li><code>tail -3 xxx</code>：展示xxx末尾3行内容<ul><li>同时支持从stdin读入内容</li></ul></li></ul><h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><ul><li><code>history</code>：展示当前用户的历史操作。内容存放在<code>~/.bash_history</code>中</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><code>md5sum</code>：计算md5哈希值<ul><li>可以从<code>stdin</code>读入内容</li><li>也可以在命令行参数中传入文件名列表；</li></ul></li><li><code>time command</code>：统计command命令的执行时间</li><li><code>ipython3</code>：交互式python3环境。可以当做计算器，或者批量管理文件。<ul><li><code>! echo &quot;Hello World&quot;</code>：!表示执行shell脚本</li></ul></li><li><code>watch -n 0.1 command</code>：每0.1秒执行一次command命令</li><li><code>tar</code>：压缩文件<ul><li><code>tar -zcvf xxx.tar.gz /path/to/file/*</code>：压缩</li><li><code>tar -zxvf xxx.tar.gz</code>：解压缩</li></ul></li><li><code>diff xxx yyy</code>：查找文件xxx与yyy的不同点</li></ul><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ul><li><code>sudo command</code>：以root身份执行<code>command</code>命令</li><li><code>apt-get install xxx</code>：安装软件</li><li><code>pip install xxx --user --upgrade</code>：安装python包</li></ul><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><strong>复制文本</strong><br>    windows&#x2F;Linux下：<code>Ctrl + insert</code>，Mac下：<code>command + c</code><br><strong>粘贴文本</strong><br>    windows&#x2F;Linux下：<code>Shift + insert</code>，Mac下：<code>command + v</code></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;center&gt;Linux基本命令的总结与笔记（方便查阅&lt;/center&gt;

&lt;hr&gt;</summary>
    
    
    
    <category term="Learning" scheme="https://sun-gliang.github.io/categories/Learning/"/>
    
    <category term="Note" scheme="https://sun-gliang.github.io/categories/Learning/Note/"/>
    
    <category term="Linux" scheme="https://sun-gliang.github.io/categories/Learning/Note/Linux/"/>
    
    
    <category term="linux" scheme="https://sun-gliang.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Remind</title>
    <link href="https://sun-gliang.github.io/post/9ebdcc7b.html"/>
    <id>https://sun-gliang.github.io/post/9ebdcc7b.html</id>
    <published>2023-03-24T18:08:42.000Z</published>
    <updated>2023-04-06T13:23:48.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><ul><li><input disabled="" type="checkbox"> <strong>网站访问数量</strong></li><li><input disabled="" type="checkbox"> <strong>404报错页面</strong></li><li><input disabled="" type="checkbox"> <strong>dark or light设置</strong></li><li><input disabled="" type="checkbox"> <strong>博文置顶功能</strong></li><li><input disabled="" type="checkbox"> <strong>等等</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总纲&quot;&gt;&lt;a href=&quot;#总纲&quot; class=&quot;headerlink&quot; title=&quot;总纲&quot;&gt;&lt;/a&gt;总纲&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;strong&gt;网站访问数量&lt;/strong&gt;&lt;/li&gt;</summary>
      
    
    
    
    
    <category term="MEMO" scheme="https://sun-gliang.github.io/tags/MEMO/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm</title>
    <link href="https://sun-gliang.github.io/post/d92ce365.html"/>
    <id>https://sun-gliang.github.io/post/d92ce365.html</id>
    <published>2023-03-24T16:25:41.000Z</published>
    <updated>2023-04-07T16:09:41.377Z</updated>
    
    <content type="html"><![CDATA[<hr><center>算法笔记</center><hr><span id="more"></span><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1. 快速排序"></a>1. 快速排序</h2><p><font color=#dd0000><strong>平均为nlogn ，最坏为n^2，分治思想</strong></font></p><ol><li>选择分界点<code>x</code><blockquote><p><code>x = q[l]</code> || <code>q[(l+r)/2]</code> || <code>q[r]</code> </p></blockquote></li><li>调整区间       <strong>重难点</strong></li><li>递归处理左右两段</li></ol><p><strong>思想</strong>：通过设置两个指针i，j分别指向初始序列的两端<br> i 和 j 相遇后只可能会出现  <code>i == j</code>   和   <code>i = j + 1</code>  两种情况</p><p><strong>注意  i &#x3D; l - 1 ,   r &#x3D; r + 1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x 取q的中间值万能</span></span><br><span class="line">    <span class="type">int</span> x = q[(l + r) / <span class="number">2</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指针i 和 j 一旦相遇就结束</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);  <span class="comment">// 注意是j--</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    注意若取j j+1，则x=q[*]，*不能取右边界 </span></span><br><span class="line"><span class="comment">    若取i-1 i，则x=q[*]，不能取左边界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    quick_sort(q, l, i - 1);</span></span><br><span class="line"><span class="comment">    quick_sort(q, i, r);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-快速选择"><a href="#2-快速选择" class="headerlink" title="2. 快速选择"></a>2. 快速选择</h2><p><font color=#dd0000><strong>O(n)</strong></font></p><p>与快速排序差不多，只是快速选择需要再输入一个 k 值，最后不用对左右两个区间递归，而只需要对左或右区间进行递归</p><p><img src="/../images/image-20211213234826044.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++里面的函数参数与全局变量重名，优先使用局部变量</span></span><br></pre></td></tr></table></figure><h2 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3. 归并排序"></a>3. 归并排序</h2><p><font color=#dd0000><strong>O(nlogn)，分治思想</strong></font></p><ol><li>确定分界点  x &#x3D; (l + r) &#x2F; 2</li><li>递归排序左右两端</li><li>对左右两端排序好的序列归并（合二为一） <strong>重难点</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], tmp[N];</span><br><span class="line"><span class="comment">// 因为q[N]已经是全局变量了， 所以函数参数有没有q无所谓 了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid); <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-二分"><a href="#4-二分" class="headerlink" title="4. 二分"></a>4. 二分</h2><p><font color=#dd0000><strong><u>用来查找</u></strong></font></p><h3 id="4-1-整数二分"><a href="#4-1-整数二分" class="headerlink" title="4.1 整数二分"></a>4.1 整数二分</h3><ul><li>二分的本质是找到一个<strong>性质</strong>，可以确定一个边界问题</li><li>有单调性一定可以二分， 而可以二分的不一定有单调性</li><li>求最值考虑一下二分</li></ul><p><font color=#FF00><strong>板子</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>while里面的模板直接使用，具体<code>check函数</code>根据题目来分析</li><li>二分一定是有解的；无解情况取决于题目性质</li><li>每次二分之后保证答案在所选区间内部</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到第一个大于等于 x 的位置</span></span><br><span class="line"><span class="comment">// 可以这么思考：数轴上有若干个连续分布着的 x ，且mid左右两边都有x存在，则q[mid] &gt;= x的判定条件即可将区间划分为[l, mid]，逐次进行即可找到第一个x；反之，q[mid] &lt;= x的判定条件即可将区间划分为[mid, r]</span></span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-浮点数二分"><a href="#4-2-浮点数二分" class="headerlink" title="4.2 浮点数二分"></a>4.2 浮点数二分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dou_bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l - r &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dou_bsearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l - r &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一般1e8这个地方看题目要求， 总是比题目要求保留小数位数多2<br><code>eg</code>：保留4位小数，1e6</li></ul><h2 id="5-高精度"><a href="#5-高精度" class="headerlink" title="5. 高精度"></a>5. 高精度</h2><h3 id="5-1-高精度相加"><a href="#5-1-高精度相加" class="headerlink" title="5.1 高精度相加"></a>5.1 高精度相加</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A + B      len(A), len(B) &lt;= 1e6</span><br></pre></td></tr></table></figure><h3 id="5-2-高精度相减"><a href="#5-2-高精度相减" class="headerlink" title="5.2 高精度相减"></a>5.2 高精度相减</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A - B       len(A), len(B) &lt;= 1e6</span><br></pre></td></tr></table></figure><h3 id="5-3-高精度乘法"><a href="#5-3-高精度乘法" class="headerlink" title="5.3 高精度乘法"></a>5.3 高精度乘法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A * a      len(A) &lt;= 1e6      a &lt;= 1e9</span><br></pre></td></tr></table></figure><h3 id="5-4-高精度除法"><a href="#5-4-高精度除法" class="headerlink" title="5.4 高精度除法"></a>5.4 高精度除法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A * a      len(A) &lt;= 1e6      a &lt;= 1e9</span><br></pre></td></tr></table></figure><h3 id="5-5-大整数"><a href="#5-5-大整数" class="headerlink" title="5.5 大整数"></a>5.5 大整数</h3><ul><li>大整数在c++里面用数组来表示（存储）</li><li>把大整数的每一位存到数组里面，按照低位在前进行存储（即第零位存个位）<blockquote><p><code>原因</code>：两个数进行运算会出现进位的可能，这时将高位数放到数组最后一位会使得数据处理起来更方便（否则便会从数组第一位依次后移，效率降低）（栈？？？）</p></blockquote></li><li>用库函数<vector>来表示一个大整数，一个size函数， 表示一个数组的长度，就不用再额外开一个内存来存储数组的长度了</li><li>模拟人工加法</li></ul><h2 id="6-前缀和"><a href="#6-前缀和" class="headerlink" title="6. 前缀和"></a>6. 前缀和</h2><p><font color=#dd0000><strong>数组下标从1开始</strong></font></p><h3 id="6-1-一维前缀和"><a href="#6-1-一维前缀和" class="headerlink" title="6.1 一维前缀和"></a>6.1 一维前缀和</h3><p>$S_i &#x3D; a_1 + a_2 + … + a_i$</p><p>意味着$S_0 &#x3D; 0$，对应于后面，与后面$S_r - S_{l-1}$ 保持一致</p><p>如何求$S_i$<br><strong>一维前缀和</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    S_i = S_&#123;i - <span class="number">1</span>&#125; + a_i</span><br></pre></td></tr></table></figure><p>作用：<strong>能够快速地求出原数组中一段数的和</strong></p><p>区间<code>[l, r]</code>这一段的和：$S_r - S_{l-1}$</p><p>前缀和$S[i] &#x3D; a[1] + a[2] + … a[i]$</p><p>原数组中一段数的和$a[l] + … + a[r] &#x3D; S[r] - S[l - 1]$</p><h3 id="6-2-二维前缀和"><a href="#6-2-二维前缀和" class="headerlink" title="6.2 二维前缀和"></a>6.2 二维前缀和</h3><ul><li><p>S[i, j] 表示 第 i 行 j 列格子左上部分所有元素的和</p><blockquote><p>$S[i, j] &#x3D; S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j]$</p></blockquote></li><li><p>以 ( x1 ,  y1 ) 为左上角， ( x2 ,  y2 ) 为右下角的子矩阵的和为：</p><blockquote><p>$S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]$</p></blockquote></li></ul><h2 id="7-差分"><a href="#7-差分" class="headerlink" title="7. 差分"></a>7. 差分</h2><p><font color=#dd0000><strong>数组下标从1开始</strong></font></p><p><strong>前缀和的逆运算</strong></p><h3 id="7-1-一维差分"><a href="#7-1-一维差分" class="headerlink" title="7.1 一维差分"></a>7.1 一维差分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定a[<span class="number">1</span>], a[<span class="number">2</span>], ... , a[n]，构造差分数组b[N] ，使得 a[i] = b[<span class="number">1</span>] + b[<span class="number">2</span>] + ... + b[i]，即 a 数组是 b 数组的一个前缀和</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心操作：将a[L, R]区间所有数字加上C， 等价于 b[L] += C, b[R + <span class="number">1</span>] -= C</span><br></pre></td></tr></table></figure><p><strong>构造b数组</strong>—即假设a数组全为0， 则b数组也全为0，但实际上，a数组不全为0。这里需要构造一个插入函数，</p><h3 id="7-2-二维差分"><a href="#7-2-二维差分" class="headerlink" title="7.2 二维差分"></a>7.2 二维差分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br></pre></td></tr></table></figure><h2 id="8-双指针算法"><a href="#8-双指针算法" class="headerlink" title="8. 双指针算法"></a>8. 双指针算法</h2><p><font color=#dd0000><strong>优化</strong></font></p><ul><li><strong>单调</strong> 考虑二分或双指针</li><li>先写出暴力解法，再看枚举时i j 的单调关系</li></ul><p><strong>核心思想</strong>：将双重for循环的O(n^2)的暴力法优化到O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>()) j++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check()寻找i j 之间的关系（比如单调性）</span></span><br><span class="line">    <span class="comment">// 以上是基本模板格式，下面具体问题具体分析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-位运算"><a href="#9-位运算" class="headerlink" title="9.位运算"></a>9.位运算</h2><h3 id="9-1-n的二进制表示中第k位是几（个位是第0位，依次）"><a href="#9-1-n的二进制表示中第k位是几（个位是第0位，依次）" class="headerlink" title="9.1 n的二进制表示中第k位是几（个位是第0位，依次）"></a>9.1 n的二进制表示中第k位是几（个位是第0位，依次）</h3><ol><li>​先把n的第k位移到第0位   n &gt;&gt; k</li><li>​再看个位数是几   (n &gt;&gt; k) &amp; 1</li><li>​综述        (n &gt;&gt; k) &amp; 1</li></ol><h3 id="9-2-lobit-x"><a href="#9-2-lobit-x" class="headerlink" title="9.2 lobit(x)"></a>9.2 lobit(x)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> x&amp;-x; <span class="comment">// 与运算，将x变为二进制进行与运算  </span></span><br></pre></td></tr></table></figure><ul><li>​返回x的二进制的最右边的一个1 <blockquote><p>例如：lowbit(100100) &#x3D;&gt; 100</p></blockquote></li></ul><h2 id="10-离散化"><a href="#10-离散化" class="headerlink" title="10. 离散化"></a>10. 离散化</h2><p>类似于在一个很大的给定区间范围上，但是可以用到的区域占比很小（类比稀疏矩阵）</p><p>通过将所需要用到的数据点坐标映射为1， 2， 3， … 这样的有序（因为提前将数据进行了排序去重）序列（二分实现），来达到离散化算法的功效。</p><p>在大数轴上有很多数据，但是仅仅只用到了很少的一部分，我们只需要将用到过的数据，比如将数据值<code>x</code>的坐标映射到1，2，3…这个小数轴上面的坐标值即可。如果需要计算大数轴上面<code>L~R</code>之间的数据和，只需要将<code>L</code>与<code>R</code>分别映射到小数轴上面的<code>l</code>与<code>r</code>，再在小数轴上面求前缀和即可。最终避免了开很大的数组造成的空间浪费。</p><ul><li>必须加入下面这两行代码（先排序，再去重）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>())</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><p><strong>Java&#x2F;Python</strong>实现unique()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针算法</span></span><br><span class="line"><span class="comment">// 满足性质：第一个数 或者 当前这个数与前一个数不同 说明这个数是第一次出现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>])</span><br><span class="line">        a[j++] = a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a[0]~a[j - 1]即为a[n]中所有不重复元素 </span></span><br></pre></td></tr></table></figure><h2 id="11-区间合并"><a href="#11-区间合并" class="headerlink" title="11.区间合并"></a>11.区间合并</h2><p><font color=#dd0000><strong>贪心思想</strong></font></p><blockquote><p>跟区间有关的题目，大部分都是贪心；可以对区间左端点 || 右端点 || 左右端点双关键字排序 </p></blockquote><p>将有交集的区间合并为一个区间（取并集） </p><ol><li>按区间左端点进行排序</li><li>对于当前所维护的区间<code>I</code>而言，其下一个区间<code>J</code>与当前的区间<code>I</code>仅可能存在3种位置关系<ol><li><code>J</code>完全包含于<code>I</code>区间中；此时答案为<code>I</code></li><li><code>J</code>与<code>I</code>有部分交集；此时两个区间取并集</li><li><code>J</code>与<code>I</code>没有交集；此时即可将<code>I</code>区间存放如答案中，以<code>J</code>区间作为下一个维护的区间进行讨论</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">    </span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li><u><del>都是用来做优化的</del></u></li></ul><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h2><h3 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h3><p>在算法中用的最多的是邻接表（n个链表）</p><p>邻接表主要存储数和图</p><p>用数组模拟链表（用于笔试）</p><p>结构体指针构造链表会超时（用于面试）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i]表示结点i的值</span></span><br><span class="line"><span class="comment">// ne[i]表示结点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx表示当前所用的是第几个结点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>, idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插入到头结点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插入到下标是k的结点的后面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点的后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-双链表"><a href="#1-2-双链表" class="headerlink" title="1.2 双链表"></a>1.2 双链表</h3><p>用来优化某些问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[Nl, l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0表示左端点，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下标是k的点的右边，插入x</span></span><br><span class="line"><span class="comment">// 在下标是k的点的左边插入x只要执行操作add(l[k], x);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第k个点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">stk[++tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">tt--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>) <span class="keyword">not</span> empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出栈顶元素</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单调栈应用"><a href="#单调栈应用" class="headerlink" title="单调栈应用"></a>单调栈应用</h3><p>给定一个序列，求序列中每一个数左边离它最近的且比它小的数字，若不存在则返回-1</p><p>与双指针思路类似，先暴力求解，再探究规律</p><h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="type">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">q[++tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">hh++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出队头元素</span></span><br><span class="line">q[hh]</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>典型应用：<strong>滑动窗口</strong> 求滑动窗口里面的最大值或最小值</p><p>与双指针思路类似，先暴力求解，再探究规律，删去没有用的元素，就得到单调性了，利用单调性求极值</p><ul><li>比如要<strong>寻找一个滑动块内的最小值</strong> 利用队列来维护滑动块内的信息<blockquote><p> 假设有队列<code>q</code>（数组存储的是下标），队头<code>hh</code>，队尾<code>tt</code>，滑动块长度为<code>k</code>，队头处存储的永远是滑动块内的最小值的下标</p><p>假设滑动块移动到了某一区域，此时在滑动区间内有最小值<code>x</code>，坐标为<code>q[hh]</code>；随着滑动块的移动，只要这个<code>x</code>还未移出滑动块内（<code>i - k + 1 &lt;= q[hh]</code>），那么滑动块内的最小值就仍是<code>x</code>，保持不变；如果随着滑动块的移动，此时从队尾入队的元素<code>y</code>，有<code>y &lt;= 队头元素所存储的最小值，即x</code>，则<code>x</code>出队<code>y</code>入队，<code>y</code>的坐标就变为了<code>q[hh]</code>。循环往复…</p></blockquote></li></ul><p><strong>代码参考</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh++;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">    q[++tt] = i;</span><br><span class="line">    <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-KMP"><a href="#4-KMP" class="headerlink" title="4. KMP"></a>4. KMP</h2><p>$O(n)$</p><ul><li><p><strong><code>next</code>数组</strong><br><code>next[i] = j</code>的含义：模板串<code>P</code>中以<code>i</code>为终点的后缀子串和以<code>1</code>开始的前缀子串长度相等，均为<code>j</code>，且有子串的长度最长；即<code>P[1 ~ j] = P[i - j + 1 ~ i]</code></p></li><li><p><strong><code>KMP</code>匹配过程</strong><br>在对目标串<code>S</code>进行匹配时，假设匹配到<code>S</code>串的第<code>i - 1</code>个位置与<code>P</code>串的第<code>j</code>个位置之前都是相等的；但是当匹配到<code>S</code>串的第<code>i</code>个位置与<code>P</code>串的第<code>j + 1</code>个位置时，有<code>S[i] != P[j + 1]</code>而且此时模板串的指针还没有回退到模板串的起始位置，则此时调用<code>next</code>数组，将模板串<code>P</code>向前移动<code>next[j]</code>再继续看<code>S</code>串的第<code>i</code>个位置与<code>P</code>串的第<code>next[j] + 1</code>个位置是否相等，若不等且此时模板串的指针还没有回退到模板串的起始位置则继续移动<code>next[next[j]]</code>，否则如果相等，则指针向前移动，直至结束匹配；匹配结束时，仍要令模板串向前移动<code>next[指针位置]</code>（因为匹配成功后，目标串可能还有剩余的元素未进行匹配，进行<code>next</code>操作以进行后续的下一次匹配</p></li></ul><p><strong>代码参考</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求next数组</span></span><br><span class="line"><span class="comment">// 由于next[1] = 0，故从i = 2开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP匹配过程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">    <span class="keyword">if</span> (j == n)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i - n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        j = ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用来求循环节，其他体型好像都不如字符串前缀哈希了</p><h2 id="5-Trie"><a href="#5-Trie" class="headerlink" title="5. Trie"></a>5. Trie</h2><p>应用：AC自动机</p><p><u><strong>一般出现的字符串类型：全是小写字母、全是大写字母、只有数字、只有0&#x2F;1</strong></u></p><p><u>用来快速（高效）<strong>存储</strong>和<strong>查找</strong>字符串集合的数据结构</u></p><p><strong>Trie树的存储</strong><br>构造过程可以想想FP_tree的构造过程（<del>关联规则的一种方法，如果还可以想起来的话</del>；Trie树会在每个字符串的结尾处做一个标记，表示这个字符串的结束</p><p><strong>代码参考</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// son[N][26]表示存储的是`Trie`树中每个节点的所有儿子；cnt[N]表示以当前节点结尾的元素有多少个；idx表示当前用到了哪个下标（下标为0的点，既是根节点也是空结点） </span></span><br><span class="line"><span class="comment">// 插入节点，建立Trie树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][t]) son[p][t] = ++idx;</span><br><span class="line">        p = son[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][t]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-并查集"><a href="#6-并查集" class="headerlink" title="6. 并查集"></a>6. 并查集</h2><p><strong><del>面试笔试    思维</del></strong></p><ul><li>应用之一：Kruskal</li></ul><p><strong>用途：</strong></p><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合中</li></ol><p>近乎$O(1)$的时间复杂度，快速地支持上面的两个操作</p><p><strong>基本原理</strong>：每个集合用一棵<strong>树</strong>来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，即p[x]表示x的父节点。</p><p><strong>问题</strong></p><ol><li>判断树根： <code>if（p[x] == x）</code></li><li>求x的集合编号：<code>while（p[x] != x） x = p[x];</code>；此时该操作的复杂度还是很高，可以看出，与树高成正比<blockquote><p><strong>优化</strong>：<strong>路径压缩</strong>：节点x沿着它的父亲节点一路找，一旦找到根节点，就将节点x寻找根节点路径上的所有节点都指向根节点</p></blockquote></li><li>合并两个集合：设p[x]是x的集合编号，p[y]是y的集合编号。则合并操作：<code>p[x] = y</code>或<code>p[y] = x</code></li></ol><p><u><strong>核心操作</strong></u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找x结点的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- **食物链**不论两个动物之间是不是同一种生物、是不是被吃的关系，都将它们放到一个集合中，即一个树中那么如何确定其中两个动物之间的关系呢？记录一下每个点与根节点之间的关系；只要我们知道了每个点与根节点的关系了，就可以知道每两个点之间的关系了利用每个点与根节点之间的距离表示其与根节点之间的关系- 距离 % 3 = 1 表示可以吃根节点- 距离 % 3 = 2 表示可以被根节点吃- 距离 % 3 = 0 表示与根节点同类在这道题中，利用并查集维护每个点到根节点的距离   --><h2 id="7-堆"><a href="#7-堆" class="headerlink" title="7. 堆"></a>7. 堆</h2><p><u>维护一个数据集合</u></p><ul><li>基本操作</li><li>插入与删除都只与树的高度有关，故是logn的</li></ul><ol><li>向集合中插入一个数</li><li>求集合当中的最小值</li><li>在集合中删除最小值</li><li>删除集合中任意一个元素</li><li>修改集合中任意一个元素</li></ol><p>这里规定高度&#x2F;深度&#x2F;层数都是从1开始的</p><p>直接建堆是O(nlogn)的       -PS：因为插入是logn的</p><p>可以使用O(n)来建堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><p>完全二叉树的第n&#x2F;2个结点是最后一个非叶子节点</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设堆是heap[], 堆的大小是size</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">heap[++size] = x; <span class="built_in">up</span>(size);</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">heap[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//3.  拿最后一个结点把第一个结点覆盖掉，再down      PS：因为是用一维数组存储的，所有删掉第一个元素是O(n)的，而删除最后一个元素是O(1)的</span></span><br><span class="line">heap[<span class="number">1</span>] = heap[size]; size--; <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line">heap[k] = heap[size]; size--; <span class="built_in">down</span>(k) / <span class="built_in">up</span>(k);</span><br><span class="line"><span class="comment">//5.</span></span><br><span class="line">heap[k] = x; <span class="built_in">down</span>(k) / <span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure><p>堆是一个完全二叉树           堆中某个节点的值总是不大于或不小于其父节点的值</p><p>小根堆：每个节点的值都 ≤ 它的左右儿子的值</p><ul><li>堆的存储结构（堆状数据结构&#x2F;完全二叉树）：一维数组         一维数组就可以存下一棵树</li></ul><p><em><strong>1号点是根节点   下标是x的结点的左儿子下标是2x，右儿子下标是2x+1</strong></em></p><p>下面的一维数组即表示下面的小根堆</p><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">1--&gt;2;</span><br><span class="line">1--&gt;3;</span><br><span class="line">2--&gt;4;</span><br><span class="line">2--&gt;5;</span><br><span class="line">3--&gt;6;</span><br><span class="line">3--&gt;7;</span><br><span class="line">4--&gt;8;</span><br><span class="line">4--&gt;9;</span><br><span class="line">5--&gt;10;</span><br></pre></td></tr></table></figure><p><em><strong>基本操作</strong></em></p><ol><li>down(x)（将结点往下调整）</li><li>up(x)（将结点往上调整）</li></ol><h2 id="8-Hash"><a href="#8-Hash" class="headerlink" title="8. Hash"></a>8. Hash</h2><ul><li><strong>离散化</strong><ul><li>离散化是一种特殊的hash   </li><li>离散化 &#x3D; 排序 + hash</li><li>离散化保证了映射后原数据的顺序保持不变，hash并没有保证</li><li>离散化是nlogn（maybe），hash是O(1)的</li></ul></li></ul><p>把一堆数据映射到$0$<del>$N$的小空间（$N$&#x3D;$10^5$</del>$10^6$）</p><!-- 将所有的数放在小空间中，解决冲突问题 --><p><strong>冲突问题是指利用hash函数映射后，可能会出现多个数映射到同一个数的情况</strong></p><p>利用hash函数进行映射，一般取对$10^5$取模这个操作作为hash函数 $h(x) &#x3D; x\mod10^5$，<strong>其中$10^5$取质数，且取距离2的整次幂尽可能远</strong>（冲突的概率是最低的）</p><p>根据处理冲突问题的不同的解决方案，分为<strong>开放寻址法</strong>和<strong>拉链法</strong></p><h3 id="8-1-哈希表的存储结构"><a href="#8-1-哈希表的存储结构" class="headerlink" title="8.1 哈希表的存储结构"></a>8.1 哈希表的存储结构</h3><p>hashmap是拉链法，threadlocal是开放寻址法？？？？</p><p>hash在算法题中一般只有插入和查找这两个操作，没有删除</p><h3 id="8-2-开放寻址法"><a href="#8-2-开放寻址法" class="headerlink" title="8.2 开放寻址法"></a>8.2 开放寻址法</h3><p>开了一个一维数组，数组大小为题目要求大小的2~3倍</p><p><strong>插入过程</strong> 先找到<code>k=hash(x)</code>，然后从<code>k</code>开始往后找，直到找到第一个空的坑位为止，插进去</p><p><strong>查找过程</strong> 先找到<code>k=hash(x)</code>，从前往后找，先看一下当前位置有没有人，如果<strong>当前位置有人且这个人为x</strong>，那么就找到了<code>x</code>；如果当前位置有人但是这个人不是<code>x</code>，就继续看下一个位置；如果当前位置没有人，则<code>x</code>不存在</p><p><strong>删除过程</strong> 按照查找的方式找<code>x</code>，当找到<code>x</code>后，给他一个标记，代表删除了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心函数</span></span><br><span class="line"><span class="comment">// find函数  如果x在哈希表中已经存在，就返回x所在的位置；如果x在哈希表中不存在，则返回x应该存储的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 茅厕寻址法：当当前坑位有人且当前坑位中的人不是你要找的人才进入循环</span></span><br><span class="line">    <span class="comment">// null = 0x3f3f3f3f &gt; 1e9</span></span><br><span class="line">    <span class="keyword">while</span> (h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span> (k == N) k = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-拉链法"><a href="#8-3-拉链法" class="headerlink" title="8.3 拉链法"></a>8.3 拉链法</h3><p>利用邻接链表的结构存储hash的映射值</p><p>开一个一维数组来存储所有的hash值，该一维数组每个结点都表示一个表头</p><blockquote><p>其中数组大小为“利用hash函数进行映射，一般取对$10^5$取模这个操作作为hash函数 $h(x)$&#x3D;$x \mod 10^5$，其中$10^5$取质数，且取距离$2$的整次幂尽可能远（冲突的概率是最低的）“这样大小的）</p></blockquote><p><strong>插入过程</strong> 若经过hash映射后，出现了两个相同的映射值，则依次将这两个数插到对应一维数组头节点下面，形成邻接链表。</p><p><strong>查找过程</strong> 对于要查找的x的映射值，有hash(x)，找到对应的位置，再对该位置的链表进行遍历</p><p><strong>删除过程</strong> 开一个bool数组，把要进行删除的元素打一个标记</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x, ne[idx] = h[k], h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-字符串前缀哈希法"><a href="#8-4-字符串前缀哈希法" class="headerlink" title="8.4 字符串前缀哈希法"></a>8.4 字符串前缀哈希法</h3><p>假定不存在冲突</p><p>快速判断两个字符串是否相等</p><hr><ol><li>先预处理出所有前缀的哈希值</li><li>求出所有的前缀字符串的哈希值</li><li>利用这些前缀字符串哈希值可以表示出字符串中任意子串</li></ol><hr><hr><p><strong><u>将任意字符串转化为哈希值的方法：</u></strong></p><p>把字符串看作p进制数</p><p>把p进制数转化为10进制数</p><p>对该字符串哈希值mod Q</p><p>则对于任意一个字符串，都可以将其表示为0~Q-1的一个数字（通常不将字符串映射成0）</p><p><em><strong>取p &#x3D; 131或13331，Q &#x3D; 2^64</strong></em></p><hr><h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><p>DFS和BFS都可以对整个空间搜索，搜索结构都是树的形式。</p><p>但是DFS尽可能往深了搜，一旦达到叶节点就会回溯</p><p>BFS会将当前这一层搜索完了才会继续搜索下一层</p><h2 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1. DFS"></a>1. DFS</h2><p><strong>思路比较奇怪就用DFS或对空间要求比较高</strong></p><p>依靠stack</p><p>空间复杂度为 O(h)   即与高度成正比</p><p>不具有最短路性质</p><p>时间复杂度为线性的</p><p>DFS俗称“暴搜”</p><p>要考虑好<strong>顺序</strong></p><p>从搜索树的角度考虑</p><p>回溯</p><p>剪枝</p><h2 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2. BFS"></a>2. BFS</h2><p><strong>问最短距离，最小步数，最少操作几次</strong> （前提是每个边的权重都是一样的）</p><p><img src="/bfs.png"></p><p>依靠queue</p><p>空间复杂度为O(2^h)</p><p>具有最短路性质</p><h2 id="3-树和图的存储"><a href="#3-树和图的存储" class="headerlink" title="3. 树和图的存储"></a>3. 树和图的存储</h2><p>树是无环连通图，是一种特殊的图</p><p>可以把无向图变成两个方向的有向图，只用考虑有向图的存储即可实现无向图的存储</p><p>存储方式分为<strong>邻接矩阵</strong>和<strong>邻接表</strong>两种</p><p><strong>邻接矩阵</strong> 用一个二维数组实现 g[a][b] 存储边a到边b的信息（即权重）不能存储重边 适合存储稠密图  O(n^2)</p><p><strong>邻接表</strong> 就是n个单链表（其中n表示节点个数），每个单链表用来存储这个结点可以到达的结点 </p><p>往邻接表中插入数据时，选择在链表头进行插入</p><p>常用<strong>邻接表</strong>来存储</p><h2 id="4-树和图的遍历"><a href="#4-树和图的遍历" class="headerlink" title="4. 树和图的遍历"></a>4. 树和图的遍历</h2><p>分为深度优先遍历和广度优先遍历，每个点只需遍历一次   时间复杂度是O(n + m)   n为节点数，m为边数</p><p>只用考虑有向图的遍历即可（无向图是一种特殊的有向图，树是一种特殊的图）</p><p>遍历只需要找到一条路即可，不必再像dfs中再恢复现场</p><p>这两种搜索方式的思想就是dfs和bfs</p><p>####深度优先遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dfs会求得每一个子树的大小</p><p>####广度优先遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-拓扑序列"><a href="#5-拓扑序列" class="headerlink" title="5. 拓扑序列"></a>5. 拓扑序列</h2><p>针对有向图，无向图没有拓扑序列</p><p>是广度优先算法的应用</p><p>有向无环图一定存在一个拓扑序列    有向无环图也被称为拓扑图</p><p>有向环图一定不存在拓扑序列</p><p>所有入度为0的点都可以排在当前序列中最前面的位置</p><h2 id="6-最短路"><a href="#6-最短路" class="headerlink" title="6. 最短路"></a>6. 最短路</h2><p>n表示结点数，m表示边数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">最短路--&gt;单源最短路;</span><br><span class="line">最短路--&gt;多源汇最短路;</span><br><span class="line">单源最短路--&gt;所有边权都是正数;</span><br><span class="line">单源最短路--&gt;存在负权边;</span><br><span class="line">所有边权都是正数--&gt;朴素Dijkstra算法;</span><br><span class="line">所有边权都是正数--&gt;堆优化版的Dijkstra算法;</span><br><span class="line">朴素Dijkstra算法--&gt;n2适合稠密图;</span><br><span class="line">堆优化版的Dijkstra算法--&gt;mlongn适合稀疏图;</span><br><span class="line">存在负权边--&gt;Bellman-Ford;</span><br><span class="line">Bellman-Ford--&gt;nm;</span><br><span class="line">Bellman-Ford--&gt;不超过k条边的最短路问题;</span><br><span class="line">存在负权边--&gt;SPFA;</span><br><span class="line">SPFA--&gt;一般是m,最坏是nm;</span><br><span class="line">多源汇最短路--&gt;Floyd算法;</span><br><span class="line">Floyd算法--&gt;n3;</span><br></pre></td></tr></table></figure><p>最短路问题的核心是如何把题干抽象为一个图，如何定义点和边来确定最短路问题</p><h3 id="6-1-朴素Dijkstra算法"><a href="#6-1-朴素Dijkstra算法" class="headerlink" title="6.1 朴素Dijkstra算法"></a>6.1 朴素Dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.初始化dist数组</span></span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>, dist[i] = <span class="number">0x3f3f3f3f</span>; <span class="comment">// i = 2,3,...,n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// （1）</span></span><br><span class="line">    先找出不在s中的最短距离的点t</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// （2）</span></span><br><span class="line">    将此最短距离的点t加入最短路数组s中</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// （3）</span></span><br><span class="line">    用此次的最短距离的点t来更新其他点的距离</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-堆优化版Dijkstra算法"><a href="#6-2-堆优化版Dijkstra算法" class="headerlink" title="6.2 堆优化版Dijkstra算法"></a>6.2 堆优化版Dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化dist数组</span></span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>, dist[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">利用priority_queue来存储，可以将朴素Dijkstra的（<span class="number">1</span>）优化到<span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line">priority_queue 更新操作是logn的，而低（<span class="number">3</span>）步一共需要更新所有的边共m次，故时间复杂度为mlogn</span><br><span class="line">但是priority_queue 中不支持修改任意一个元素，只能接受冗余的存在，即每次修改都往堆里面插入一个新的数</span><br><span class="line">所以本来堆里面是有n个数（手写堆可以保证），但是此时用的STL，priority_queue里面会有m个数</span><br><span class="line">所以实际上的时间复杂度为mlogm</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// （1）</span></span><br><span class="line">    先找出不在s中的最短距离的点t <span class="comment">// O(1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// （2）</span></span><br><span class="line">    将此最短距离的点t加入最短路数组s中 <span class="comment">// O(1)</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// （3）</span></span><br><span class="line">    用此次的最短距离的点t来更新其他点的距离 <span class="comment">// logn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Bellman-Ford算法"><a href="#6-3-Bellman-Ford算法" class="headerlink" title="6.3 Bellman-Ford算法"></a>6.3 Bellman-Ford算法</h3><p>如果图中存在负权回路，则最短路可能会不存在（为-∞）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    备份<span class="function">dist</span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="params">(循环所有边 a b w  由a-&gt;b，权重为w)</span></span></span><br><span class="line"><span class="function">        更新每一条边 dist[b] </span>= <span class="built_in">min</span>(dist[b], dist[a] + w); <span class="comment">// 松弛操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h3 id="6-4-SPFA"><a href="#6-4-SPFA" class="headerlink" title="6.4 SPFA"></a>6.4 SPFA</h3><p>只要图中没有负环，就可以用SPFA</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列中存储的是从起点到该节点距离变小的结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    取出队列的首元素t，弹出首元素</span><br><span class="line">    </span><br><span class="line">    更新t的所有出边，并把对应的出边的结点加到队列里面（因为t的所有出边由于t是变小的，所以它的所有出边也变小了，也要加入到队列中）（如果队列里面有了就不用了）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-Floyd"><a href="#6-5-Floyd" class="headerlink" title="6.5 Floyd"></a>6.5 Floyd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵存储所有的边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br></pre></td></tr></table></figure><h2 id="7-最小生成树"><a href="#7-最小生成树" class="headerlink" title="7. 最小生成树"></a>7. 最小生成树</h2><p>最小生成树一般涉及到的图都是无向图</p><p>稠密图，一般就用朴素版Prim算法</p><p>稀疏图，一般用Kruskal算法</p><p>堆优化版Prim算法不常用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">最小生成树--&gt;Prim算法;</span><br><span class="line">最小生成树--&gt;Kruskal算法;</span><br><span class="line">Prim算法--&gt;朴素版Prim算法;</span><br><span class="line">Prim算法--&gt;堆优化版Prim算法;</span><br><span class="line">朴素版Prim算法--&gt;适用于稠密图n2;</span><br><span class="line">堆优化版Prim算法--&gt;适用于稀疏图mlogn;</span><br><span class="line">Kruskal算法--&gt;mlogm;</span><br></pre></td></tr></table></figure><h3 id="7-1-朴素版Prim算法"><a href="#7-1-朴素版Prim算法" class="headerlink" title="7.1 朴素版Prim算法"></a>7.1 朴素版Prim算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化dist[N] &lt;- <span class="number">0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 循环n次</span></span><br><span class="line">&#123;</span><br><span class="line">    找到集合外距离最近的点t</span><br><span class="line">    </span><br><span class="line">    用t来更新其他点到集合的距离</span><br><span class="line">        </span><br><span class="line">    st[t] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Kruskal算法"><a href="#7-2-Kruskal算法" class="headerlink" title="7.2 Kruskal算法"></a>7.2 Kruskal算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将所有边按权重从小到大进行排序  <span class="comment">//O(mlongm)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 并查集思想   并查集是O(1) 总共就是O(m)</span></span><br><span class="line">枚举每条边a-b，权重为c</span><br><span class="line">    若a-b不连通，则将a-b这条边加入到集合中</span><br></pre></td></tr></table></figure><h2 id="8-二分图"><a href="#8-二分图" class="headerlink" title="8. 二分图"></a>8. 二分图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">二分图--&gt;染色法...就是一个dfs,判断图是否为二分图--&gt;m+n;</span><br><span class="line">二分图--&gt;匈牙利算法--&gt;最坏是mn,实际运行时间一般远小于mn;</span><br></pre></td></tr></table></figure><h3 id="8-1-染色法"><a href="#8-1-染色法" class="headerlink" title="8.1 染色法"></a>8.1 染色法</h3><p>一个图是二分图当且仅当图中不含奇数环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (i未被染色)</span><br><span class="line">        <span class="built_in">dfs</span>(i, color)</span><br></pre></td></tr></table></figure><h3 id="8-2-匈牙利算法-NTR算法bushi"><a href="#8-2-匈牙利算法-NTR算法bushi" class="headerlink" title="8.2 匈牙利算法[NTR算法bushi]"></a>8.2 匈牙利算法[NTR算法bushi]</h3><p>存储用邻接表</p><p>最坏时间复杂度是</p><h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><h2 id="1-数论"><a href="#1-数论" class="headerlink" title="1. 数论"></a>1. 数论</h2><h3 id="1-1-质数"><a href="#1-1-质数" class="headerlink" title="1.1 质数"></a>1.1 质数</h3><p>在大于1的整数中，如果只包含1和其本身这两个约数，则该数就称为质数&#x2F;素数</p><h4 id="1-1-1-质数的判定—-试除法"><a href="#1-1-1-质数的判定—-试除法" class="headerlink" title="1.1.1 质数的判定—-试除法"></a>1.1.1 质数的判定—-试除法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从定义来</span></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; x; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="comment">// O(sqrt(n))</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原理见下方的数学块中内容</span></span><br></pre></td></tr></table></figure><p>$$<br>如果d|n，则\frac{n}{d}|n。因此若要枚举n的所有大于1的约数，只需要有d \lt \frac{n}{d}，即枚举到\frac{n}{d}即可\<br>$$</p><h4 id="1-1-2-分解质因数—-试除法"><a href="#1-1-2-分解质因数—-试除法" class="headerlink" title="1.1.2 分解质因数—-试除法"></a>1.1.2 分解质因数—-试除法</h4><p>$$<br>分解质因数：一个数x可以分解为，x &#x3D; {p_1}^{\alpha_1}{p_2}^{\alpha_2}…{p_k}^{\alpha_k}，其中p_1,p_2,…,p_k均为质数<br>$$</p><p>$$<br>一个数x中至多只包含一个大于\sqrt{n}的质因数<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最坏是O(sqrt(x))，最好的O(logn)---比如x=2^k;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-筛质数"><a href="#1-1-3-筛质数" class="headerlink" title="1.1.3 筛质数"></a>1.1.3 筛质数</h4><p>将所有小于等于x的质数筛出来</p><h5 id="1-1-3-1-朴素筛法"><a href="#1-1-3-1-朴素筛法" class="headerlink" title="1.1.3.1 朴素筛法"></a>1.1.3.1 朴素筛法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N]; <span class="comment">// 用来存储筛出来的质数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 如果当前这个数被筛去了，则赋值为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素筛法 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>朴素筛法时间复杂度分析</strong><br>$$<br>朴素筛法时间复杂度分析：当i&#x3D;2时，第二层循环循环\frac{n}{2}；当i&#x3D;3时，第二层循环循环\frac{n}{3}…当i&#x3D;n时，第三层循环循环1次。\故第二层循环总的循环次数为\frac{n}{2} + … + \frac{n}{n}&#x3D;n(\frac{1}{2} + … + \frac{1}{n})，取极限有\lim_{t-&gt;+\infty}n(\frac{1}{2} + … + \frac{1}{n})≈nlnn≈nlogn<br>$$</p><p>$$<br>\lim_{t-&gt;+\infty}(1 + \frac{1}{2} + … + \frac{1}{n}) &#x3D; lnn + C，其中C为欧拉常数，lnn为log_en<br>$$</p><h5 id="1-1-3-2-埃氏筛法"><a href="#1-1-3-2-埃氏筛法" class="headerlink" title="1.1.3.2 埃氏筛法"></a>1.1.3.2 埃氏筛法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">实际上，上面的第二层循环将<span class="number">2</span>~x中所有数的倍数都枚举了一遍，但实际上，只需要将<span class="number">2</span>~x中的所有质数的倍数枚举删去它们即可，故可做优化</span><br><span class="line"><span class="comment">// 埃氏筛法 O(nloglogn)    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) st[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>埃氏筛法时间复杂度分析</strong><br>$$<br>埃氏筛法时间复杂度分析：由于只用筛去质数的所有倍数，故有\lim_{t-&gt;+\infty}n({\frac{1}{2} + … + \frac{1}{n}}_{质数})≈nlnn&#x2F;lnn≈nlogn&#x2F;lnn≈n\<br>实际上真实的理论上的时间复杂度为O(nloglogn)<br>$$</p><p>$$<br>质数定理：1-n当中一共有\frac{n}{lnn}个质数<br>$$</p><h5 id="1-1-3-3-线性筛法"><a href="#1-1-3-3-线性筛法" class="headerlink" title="1.1.3.3 线性筛法"></a>1.1.3.3 线性筛法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性筛法</span></span><br><span class="line"><span class="comment">// 把每一个合数只会被它的最小质因子筛掉</span></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j]一定是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从小到大枚举的所有质数</span></span><br><span class="line">        <span class="comment">// 1. i % primes[j] == 0    primes[j]一定是i的最小质因子,primes[j]一定是primes[j]*i的最小质因子</span></span><br><span class="line">        <span class="comment">// 2. i % primes[j] != 0primes[j]一定小于i的所有质因子,primes[j]一定是primes[j]*i的最小质因子</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 对于一个合数x，假设primes[j]是x的最小质因子，则当i枚举到x / primes[j]时，该合数x一定会被筛掉，而且仅用最小质因子来筛，又每个数只有一个最小质因子，所以每个合数只会被筛掉一次，所以是线性的</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-约数"><a href="#1-2-约数" class="headerlink" title="1.2. 约数"></a>1.2. 约数</h3><h4 id="1-2-1-试除法求一个数的所有约数"><a href="#1-2-1-试除法求一个数的所有约数" class="headerlink" title="1.2.1 试除法求一个数的所有约数"></a>1.2.1 试除法求一个数的所有约数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vertor&lt;<span class="type">int</span>&gt; <span class="title">get_divitors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-约数个数"><a href="#1-2-2-约数个数" class="headerlink" title="1.2.2 约数个数"></a>1.2.2 约数个数</h4><p>$$<br>算数基本定理\<br>任何一个数x可以进行质因数分解，分解为x &#x3D; {p_1}^{\alpha_1}{p_2}^{\alpha_2}…{p_k}^{\alpha_k}，其中p_1,p_2,…,p_k均为质数<br>$$</p><p><strong>约数个数为</strong><br>$$<br>(\alpha_1+1)(\alpha_2+1)…(\alpha_k+1)<br>$$</p><p>$$<br>由于一个数x可以进行质因数分解，分解为x &#x3D; {p_1}^{\alpha_1}{p_2}^{\alpha_2}…{p_k}^{\alpha_k}\<br>假设x的其中一个约数为d，则d也可以进行质因数分解，分解为d &#x3D; {p_1}^{\beta_1}{p_2}^{\beta_2}…{p_k}^{\beta_k}\<br>由于每个数的质因数分解形式都是一样的，且对于不同的指数的组合，对应不同的数，所以约数个数就是\beta_1,…,\beta_k的选法的个数\<br>又0 \leq \beta_i \leq \alpha_i，因此\beta_i共有\alpha_i + 1种取法\<br>所以由乘法原理有约数个数为(\alpha_1+1)(\alpha_2+1)…(\alpha_k+1)<br>$$</p><p>int范围内，拥有最多约数的数的约数个数仅为1536</p><h4 id="1-2-3-约数之和"><a href="#1-2-3-约数之和" class="headerlink" title="1.2.3 约数之和"></a>1.2.3 约数之和</h4><p>$$<br>(p_1^0+p_1^1+…+p_1^{\alpha_1})…(p_k^0+p_k^1+…+p_k^{\alpha_k})<br>$$</p><h3 id="1-3-欧几里得算法-x2F-辗转相除法"><a href="#1-3-欧几里得算法-x2F-辗转相除法" class="headerlink" title="1.3. 欧几里得算法&#x2F;辗转相除法"></a>1.3. 欧几里得算法&#x2F;辗转相除法</h3><p>$$<br>(a, b) &#x3D; (b, a % b)\<br>a % b &lt;&#x3D;&#x3D;&#x3D;&gt; a-\lfloor \frac{a}{b} \rfloor *b\<br>Proof:\<br>必要性：如果d&#x3D;(a, b),则d|a, d|b,即d为a，b的最大公约数；又有d|(ax+by),所以d|(a-\lfloor \frac{a}{b} \rfloor *b)&#x3D;d|(a%b),所以d&#x3D;(b, a % b)\<br>充分性：如果d&#x3D;(b, a % b),有d|b,d|(a%b)&#x3D;d|(a-\lfloor \frac{a}{b} \rfloor *b),所以d|(a-\lfloor \frac{a}{b} \rfloor *b + \lfloor \frac{a}{b} \rfloor *b)&#x3D;d|a,所以d&#x3D;(a,b)<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(g, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-欧拉函数"><a href="#1-4-欧拉函数" class="headerlink" title="1.4. 欧拉函数"></a>1.4. 欧拉函数</h3><p>$$<br>欧拉函数，记作\varphi(n)，表示1-n中与n互质的数的个数（互质就是指两个数的gcd&#x3D;1）<br>$$</p><p>$$<br>求欧拉函数的公式：\<br>设数N的质因数分解为N&#x3D;{p_1}^{\alpha_1}{p_2}^{\alpha_2}…{p_k}^{\alpha_k}，则\varphi(N)&#x3D;N(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})<br>$$</p><p>$$<br>欧拉函数公式证明（用到了容斥原理）\<br>要想求得1-N中和N互质的数的个数就要：①从1-N中减去p_1,p_2,…,p_k的所有倍数;②加上所有p_i<em>p_j的倍数;③减去所有p_i</em>p_j<em>p_k的倍数;④加上所有…\<br>就有个数为N-\frac{N}{p_1}-\frac{N}{p_2}-…-\frac{N}{p_k}+\frac{N}{p_1</em>p_2}+\frac{N}{p_1<em>p_3}-…+\frac{N}{p_{k-1}<em>p_k}-\frac{N}{p_1</em>p_2</em>p_3}-\frac{N}{p_1<em>p_2</em>p_4}-…-\frac{N}{p_{k-2}p_{k-1}*p_k}+…&#x3D;欧拉函数<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度主要取决于分解质因数</span></span><br><span class="line"><span class="comment">// O(logx)-O(sqrt(x))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">求1-N中每一个数的欧拉函数，用上述做法，就要将每一个数进行质因数分解，则时间复杂度为O(Nsqrt(N))</span><br><span class="line"></span><br><span class="line">利用线性筛法来去欧拉函数，会使得时间复杂度降低到O(N)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果i % primes[j] == 0，则primes[j]是i的最小质因数，即i的质因数分解和i * primes[j]的质因数分解得到的质数是相同的（有相同的质因数），因此phi[i * primes[j]]与phi[i]只差primes[j]倍</span></span><br><span class="line">                phi[i * primes[j]] = phi[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果i % primes[j] != 0，则primes[j]是i * primes[j]的最小质因数，就有phi[i * primes[j]] = phi[i] * phi[j]，而j是质因数，所以phi[j] = primes[j] - 1</span></span><br><span class="line">            phi[i * primes[j]] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>欧拉定理</strong><br>$$<br>若a与n互质，则a^{\varphi(n)}\equiv1(mod \ \ n)，其中\varphi(n)为欧拉函数<br>$$</p><p>$$<br>Proof:\<br>假设1-n中与n互质的数分别为a_1,a_2,…,a_{\varphi(n)}(因为欧拉函数为\varphi(n)),则又由于a与n互质，可知有aa_1,aa_2,…,aa_{\varphi(n)}也与n互质，\且互不相同（反证法）,而且aa_1,aa_2,…,aa_{\varphi(n)}在模n的情况下是与a_1,a_2,…,a_{\varphi(n)}为同一组数。因此有\a^{\varphi(n)}a_1a_2…a_{\varphi(n)}\equiv a_1a_2…a_{\varphi(n)}(mod \ n)—-&gt;a^{\varphi(n)}\equiv 1(mod \ n)<br>$$</p><p><strong>费马小定理</strong><br>$$<br>在欧拉定理中，当n为质数时，有a^{n-1}\equiv 1(mod \ n)\<br>因为\varphi(n)&#x3D;n-1<br>$$</p><h3 id="1-5-快速幂"><a href="#1-5-快速幂" class="headerlink" title="1.5. 快速幂"></a>1.5. 快速幂</h3><ul><li>快速幂的<strong>核心思路</strong>：反复平方法</li><li>能够快速地求出$a^k\ mod\ p$</li><li>可以在$O(logk)$的时间复杂度下求得上面的结果，其中$0\le a,\ k,\ p\le10^9$</li></ul><p><strong>二进制思想</strong><br>预处理出来$logk$个基值 $a^{2^0}mod\ p，a^{2^1}mod\ p，…，a^{2^{log{k}}}mod\ p$</p><p>$a^k$可以由上面预处理出来的基来表示（即将<code>k</code>转换为二进制表示），而且上面的基有关系为$(a^{2^0})^2&#x3D;a^{2^1},(a^{2^1})^2&#x3D;a^{2^2}…$，即当前的数&#x3D;上一个数的平方再模<code>p</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (<span class="type">long</span> <span class="type">long</span>)res * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (<span class="type">long</span> <span class="type">long</span>)a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用快速幂求逆元</strong></p><p><strong>乘法逆元</strong>的定义：若整数$b$，$m$互质，并且对于任意的整数$a$，如果满足$b|a$，则存在一个整数$x$，使得$\frac{a}{b}≡a×x(mod \ m)$，则称$x$为$b$的模$m$乘法逆元，记为$b^{−1}(mod\ m)$。</p><p>b存在乘法逆元的充要条件是$b$与模数$m$互质。</p><p>当模数$m$为质数时，$b^{m−2}$即为$b$的乘法逆元。（参见费马小定理）</p><p>当$x$为$b$的乘法逆元时，有$x&#x3D;b^{-1}(mod \ m)$。带入乘法逆元定义式，有$\frac{a}{b}\equiv a×b^{-1}(mod\ m)$，化简得$bb^{-1}\equiv 1(mod\ m)$<br>由于$m$为质数，由费马小定理可知，$b^{m-1}\equiv1(mod\ m)$，联立有$b^{-1}(mod\ m)&#x3D;b^{m-2}$</p><h3 id="1-6-扩展欧几里得算法"><a href="#1-6-扩展欧几里得算法" class="headerlink" title="1.6. 扩展欧几里得算法"></a>1.6. 扩展欧几里得算法</h3><p><strong>裴蜀定理</strong><br>$$<br>对于任意的正整数a，b，一定存在非零整数x，y，使得ax+by&#x3D;gcd(a, b)<br>$$<br>利用扩展欧几里得算法可以求得一组x,y使得x,y满足ax+by&#x3D;gcd(a,b)</p><p><strong>线性同余方程</strong></p><h3 id="1-7-中国剩余定理"><a href="#1-7-中国剩余定理" class="headerlink" title="1.7. 中国剩余定理"></a>1.7. 中国剩余定理</h3><p>$$<br>有m_1,m_2,…m_k两两互质，则对于如下的线性同余方程组\<br>\begin{cases}<br>x &#x3D; a_1(mod \ m_1) \<br>x &#x3D; a_2(mod \ m_2) \<br>…\<br>x &#x3D; a_k(mod \ m_k)<br>\end{cases}\<br>有解为x&#x3D;a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_kM_kM_k^{-1}\<br>其中M&#x3D;m_1m_2…m_k,M_i&#x3D;\frac{M}{m_{i}},M_i^{-1}表示M_i模m_i的逆<br>$$</p><h2 id="2-组合计数"><a href="#2-组合计数" class="headerlink" title="2. 组合计数"></a>2. 组合计数</h2><h2 id="3-高斯消元"><a href="#3-高斯消元" class="headerlink" title="3. 高斯消元"></a>3. 高斯消元</h2><h2 id="4-简单博弈论"><a href="#4-简单博弈论" class="headerlink" title="4. 简单博弈论"></a>4. 简单博弈论</h2><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><p>时间复杂度分析：状态数量*计算每个状态需要的计算量</p><h2 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1. 背包问题"></a>1. 背包问题</h2><p>N个物品和容量为V的背包，每个物品的体积v_i，价值w_i</p><h3 id="1-1-0-1背包问题"><a href="#1-1-0-1背包问题" class="headerlink" title="1.1 0-1背包问题"></a>1.1 0-1背包问题</h3><p>每件物品最多只能用一次</p><p>状态—未知数</p><p>状态表示指的是整个问题需要用几维的状态来表示，背包问题一般为两维</p><p>状态计算指的是如何一步一步把每一个状态算出来</p><p>Dp问题的优化是对状态方程&#x2F;程序做一个等价变形</p><p>每一个状态表示的都是一个集合，集合里面是一堆选法，是所有选法的一个集合</p><p>状态计算就是考虑如何把当前的集合划分为若干个更小的子集，使得每一个子集都可以用更小的集合表示出来</p><p>集合划分的原则—不重不漏（求num），不漏（求max，min）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">Dp--&gt;状态表示f_ij--&gt;集合--&gt;所有选法的集合;</span><br><span class="line">集合--&gt;条件--&gt;1.只从前i个物品中选;</span><br><span class="line">条件--&gt;2.选出来物品的总体积小于等于j;</span><br><span class="line">状态表示f_ij--&gt;属性--&gt;Max;</span><br><span class="line">Dp--&gt;状态计算--&gt;集合的划分--&gt;按照第i个物品有没有选上来划分;</span><br></pre></td></tr></table></figure><h3 id="1-2-完全背包问题"><a href="#1-2-完全背包问题" class="headerlink" title="1.2 完全背包问题"></a>1.2 完全背包问题</h3><p>每件物品可以用无限次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">Dp--&gt;状态表示f_ij--&gt;集合--&gt;所有从前i个物品中选且总体积不超过j的所有选法的集合;</span><br><span class="line">状态表示f_ij--&gt;属性--&gt;Max;</span><br><span class="line">Dp--&gt;状态计算--&gt;集合的划分--&gt;按照第i个物品选0,1,2...k个来划分;</span><br></pre></td></tr></table></figure><p>三维时的状态转移方程为 f[i, j] &#x3D; f[i - 1, j - k * v[i]] + k * w[i]</p><p>枚举k将状态转移方程展开</p><p>f[i, j] &#x3D; max(f[i - 1, j], f[i - 1, j - v] + w, f[i - 1, j - 2v] + 2w + …)</p><p>f[i, j - v] &#x3D;           max(f[i - 1, j - v], f[i - 1, j - 2v] + w, …)</p><p>因此状态转移方程优化为f[i, j] &#x3D; max(f[i - 1, j], f[i, j - v] + w)</p><h3 id="1-3-多重背包问题"><a href="#1-3-多重背包问题" class="headerlink" title="1.3 多重背包问题"></a>1.3 多重背包问题</h3><p>每件物品最多只能用s_i次</p><p>优化：二进制优化</p><p>每件物品最多可以用s_i次<br>通过二进制优化，可以将s_i拆解为logs_i个（1,2,4,8…），且拆解出来的每一项仅可用一次<br>因此，所有的物品总共会最多拆解出Nlogs_i个<br>而每件拆解出来的物品又只能用一次<br>因此变为了一个0-1背包问题<br>时间复杂度由NVs降为NVlogs</p><h3 id="1-4-分组背包问题"><a href="#1-4-分组背包问题" class="headerlink" title="1.4 分组背包问题"></a>1.4 分组背包问题</h3><p>物品有N组，每一组物品有若干种物品，每一组里最多只能选一种物品</p><h2 id="2-线性Dp"><a href="#2-线性Dp" class="headerlink" title="2. 线性Dp"></a>2. 线性Dp</h2><p>递推的顺序有一个明显的线性顺序</p><h3 id="2-1-数字三角形"><a href="#2-1-数字三角形" class="headerlink" title="2.1 数字三角形"></a>2.1 数字三角形</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">Dp--&gt;状态表示f_ij--&gt;集合--&gt;从起点到点i,j的所有路径的集合;</span><br><span class="line">状态表示f_ij--&gt;属性--&gt;Max;</span><br><span class="line">Dp--&gt;状态计算--&gt;集合的划分--&gt;按照走到i,j这个点的路径是从左上角走来的还是右上角走来的进行划分;</span><br></pre></td></tr></table></figure><p>左上角走来的状态转移方程f[i - 1, j - 1] + a[i, j]</p><p>右上角走来的状态转移方程f[i - 1, j] + a[i, j]</p><h3 id="2-2-最长上升子序列"><a href="#2-2-最长上升子序列" class="headerlink" title="2.2 最长上升子序列"></a>2.2 最长上升子序列</h3><p>动态规划时间复杂度分析：<br>状态数量*计算每一个状态需要的的时间</p><p>这个算法的时间复杂度为O(n^2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">Dp--&gt;状态表示f_i--&gt;集合--&gt;所有以第i个数结尾的上升子序列;</span><br><span class="line">状态表示f_i--&gt;属性--&gt;Max;</span><br><span class="line">Dp--&gt;状态计算--&gt;集合的划分--&gt;按第i个数前一位是原序列的第几位来分类;</span><br></pre></td></tr></table></figure><p>动态规划求方案就是把状态转移记录下来</p><h3 id="2-3-最长公共子序列"><a href="#2-3-最长公共子序列" class="headerlink" title="2.3 最长公共子序列"></a>2.3 最长公共子序列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   graph TD;</span><br><span class="line">Dp--&gt;状态表示f_i--&gt;集合--&gt;所有在第一个序列的前i个字母中出现且在第二个序列的前j个字母中出现的子序列;</span><br><span class="line">状态表示f_i--&gt;属性--&gt;Max;</span><br><span class="line">Dp--&gt;状态计算--&gt;集合的划分--&gt;按子序列中是否包含第一个序列的第i个字母第二个序列第j个字母划分;</span><br></pre></td></tr></table></figure><h3 id="2-4-区间Dp"><a href="#2-4-区间Dp" class="headerlink" title="2.4 区间Dp"></a>2.4 区间Dp</h3><h4 id="2-4-1-石子划分"><a href="#2-4-1-石子划分" class="headerlink" title="2.4.1 石子划分"></a>2.4.1 石子划分</h4><p>以最后一次分界的位置来分类</p><p>区间Dp要保证算每个f_ij所依赖的状态都已经算好了<br>顺序：枚举区间长度，从小到大枚举</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   graph TD;</span><br><span class="line">Dp--&gt;状态表示f_ij--&gt;集合--&gt;所有将第i堆石子到第j堆石子合并成一堆石子的合并方式;</span><br><span class="line">状态表示f_ij--&gt;属性--&gt;Min;</span><br><span class="line">Dp--&gt;状态计算--&gt;集合的划分--&gt;以最后一次合并的分界线的位置来分类;</span><br></pre></td></tr></table></figure><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><ul><li>数据规模在100万以上，采用scanf和printf，否则cin和cout与他俩效率差不多</li><li>bits&#x2F;stdc++.h  ——-     万能头文件</li></ul><p>$$<br>S_i<br>$$</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><ul><li><p><code>vector</code>（变长数组），倍增的思想，支持比较运算（按字典序）<br>定义：：<br>    <code>vector &lt;int&gt; a</code>; 定义：一个vector数组a<br>    <code>vector &lt;int&gt; a(10)</code>; 定义：一个长度为10的vector数组a<br>    <code>vector &lt;int&gt; a(10,3)</code>; 定义：一个长度为10的vector数组a，并且所有元素都为3<br><strong>常用函数</strong>：：<br>    size(); 返回元素个数  O(1)<br>    empty(); 返回是否是空  O(1)<br>    clear(); 清空<br>    front(); 返回vector的第一个数<br>    back(); 返回vector的最后一个数<br>    push_back(); 向vector的最后插入一个数<br>    pop_back(); 把vector的最后一个数删掉<br>    begin(); vector的第0个数<br>    end(); vector的最后一个的数的后面一个数<br><strong>倍增的思想</strong>：<br>​操作系统为某一进程分配空间时所花费的时间与空间大小无关，而与申请的次数有关。</p><p>​************************************</p><p>​    <strong>遍历方法</strong><br>​        假设有个vector <int> a;</p><p>​a.begin() &#x3D; a[0],   a.end() &#x3D; a[s.size()]</p><p>​        第一种</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) </span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure><p>​        第二种</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector &lt;<span class="type">int</span>&gt;::iterator i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++)</span><br><span class="line">    cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;  </span><br><span class="line"><span class="comment">//vector &lt;int&gt;::iterator可以写为auto</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++)</span><br><span class="line">    cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;  </span><br></pre></td></tr></table></figure><p>​        第三种       </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : a) </span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>​<strong>支持比较运算</strong></p><p>​按字典序比较，从第一个值开始比较，如果当前值小于则小于，如果等于则比较下一位</p><ul><li><p><code>pair</code>，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）<br>定义：：<br>​        pair &lt;类型,类型&gt; 变量名; 存储一个二元组    两个类型可以不同<br>​    初始化方式：<br>​        假设有个pair &lt;int,string&gt; p;<br>​        第一种        </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">make_pair</span>(<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>​        第二种         </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &#123;<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>​也可以用pair存两个以上的不同类型的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, string&gt;&gt; p;</span><br></pre></td></tr></table></figure><p>常用函数：：<br>    first(); 第一个元素<br>    second(); 第二个元素</p></li><li><p><code>string</code>（字符串）<br>常用函数：：<br>    substr(); 返回某一个子串<br>    c_str(); 返回string对应的字符数组的头指针<br>    size(); 返回字母个数<br>    length(); 返回字母个数<br>    empty(); 返回字符串是否为空<br>    clear(); 把字符串清空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string  a = <span class="string">&quot;sgl&quot;</span>;</span><br><span class="line"></span><br><span class="line">a += <span class="string">&#x27;def&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">substr</span>( , ) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// printf无法直接输出string，依靠string头指针来进行输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure></li><li><p><code>queue</code>（队列）队尾插入队头弹出<br>定义：：<br>    queue &lt;类型&gt; 变量名;<br>常用函数：：<br>    size(); 这个队列的长度<br>    empty(); 返回这个队列是否为空<br>    push(); 往队尾插入一个元素<br>    front(); 返回队头元素<br>    back(); 返回队尾元素<br>    pop(); 把队头弹出<br>    注意：队列没有clear函数！！！<br>清空queue：     </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = queue &lt;int&gt; ();</span><br></pre></td></tr></table></figure></li><li><p><code>priority_queue</code>（优先队列，是一个堆）<br>注意：默认是大根堆！！！<br>定义：：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大根堆：priority_queue &lt;类型&gt; 变量名;</span><br><span class="line">小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名</span><br></pre></td></tr></table></figure><p>​    常用函数：<br>​        size(); 这个堆的长度<br>​        empty(); 返回这个堆是否为空<br>​        push();往堆里插入一个元素<br>​        top(); 返回堆顶元素<br>​        pop(); 弹出堆顶元素<br>​        注意：堆没有clear函数！！！</p></li></ul><p><code>stack</code>（栈）<br>    常用函数：<br>        size(); 这个栈的长度<br>        empty(); 返回这个栈是否为空<br>        push(); 向栈顶插入一个元素<br>        top(); 返回栈顶元素<br>        pop(); 弹出栈顶元素</p><p><code>deque</code>（双端队列）队头队尾都可以插入删除，支持随机访问<br>    常用函数：<br>        size(); 这个双端队列的长度<br>        empty(); 返回这个双端队列是否为空<br>        clear(); 清空这个双端队列<br>        front(); 返回第一个元素<br>        back(); 返回最后一个元素<br>        push_back(); 向最后插入一个元素<br>        pop_back(); 弹出最后一个元素<br>        push_front(); 向队首插入一个元素<br>        pop_front(); 弹出第一个元素<br>        begin(); 双端队列的第0个数<br>        end(); 双端队列的最后一个的数的后面一个数</p><p>​[] 类似数组</p><p><code>set</code>，<code>map</code>，<code>multiset</code>，<code>multimap</code> 基于平衡二叉树（红黑树：一种平衡二叉树），动态维护<strong>有序序列</strong><br>    <code>set/multiset</code><br>        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！<br>        常用函数：<br>            size(); 返回元素个数<br>            empty(); 返回set是否是空的<br>            clear(); 清空<br>            begin(); 第0个数，支持++或–，返回前驱和后继<br>            end(); 最后一个的数的后面一个数，支持++或–，返回前驱和后继<br>            insert(); 插入一个数<br>            find(); 查找一个数<br>            count(); 返回某一个数的个数<br>            erase();<br>                （1）输入是一个数x，删除所有x    O(k + log n)      k是x的个数<br>                （2）输入一个迭代器，删除这个迭代器<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器<br>    <code>map/multimap</code>  类似python字典<br>        常用函数：<br>            insert(); 插入一个数，插入的数是一个pair<br>            erase();<br>                （1）输入是pair<br>                （2）输入一个迭代器，删除这个迭代器<br>            find(); 查找一个数<br>            lower_bound(x); 返回大于等于x的最小的数的迭代器<br>            upper_bound(x); 返回大于x的最小的数的迭代器</p><p>​[] 数组类似，但是是O(logn) 增删改查都是O(logn)</p><p><code>unordered_set</code>，<code>unordered_map</code>，<code>unordered_muliset</code>, <code>unordered_multimap</code> 基于哈希表实现<br>    和上面类似，增删改查的时间复杂度是O(1)<br>    不支持lower_bound()和upper_bound()，迭代器++–；；；；；；凡是和排序有关的操作都不支持</p><p><code>bitset</code> 压位</p><p>​可以将一字节的大小存储在1bit中，即可以把内存大小减少为原来的1&#x2F;8</p><p>​    定义：<br>​        bitset &lt;个数&gt; 变量名;<br>​    支持：<br>​        <del>，&amp;，|，^<br>​        &gt;&gt;，&lt;&lt;<br>​        &#x3D;&#x3D;，!&#x3D;<br>​        []<br>​    常用函数：<br>​        count(); 返回有多少个1<br>​        any(); 判断是否至少有一个1<br>​        none(); 判断是否全为0<br>​        set(); 把所有位置赋值为1<br>​        set(k,v); 将第k位变成v<br>​        reset(); 把所有位变成0<br>​        flip(); 把所有位取反，等价于</del><br>​        flip(k); 把第k位取反</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;center&gt;算法笔记&lt;/center&gt;

&lt;hr&gt;</summary>
    
    
    
    <category term="Learning" scheme="https://sun-gliang.github.io/categories/Learning/"/>
    
    <category term="Note" scheme="https://sun-gliang.github.io/categories/Learning/Note/"/>
    
    <category term="Algorithm" scheme="https://sun-gliang.github.io/categories/Learning/Note/Algorithm/"/>
    
    
    <category term="algorithm" scheme="https://sun-gliang.github.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
